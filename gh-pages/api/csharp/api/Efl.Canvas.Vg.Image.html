<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class Efl.Canvas.Vg.Image
   </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class Efl.Canvas.Vg.Image
   ">
    <meta name="generator" content="docfx 2.40.4.0">
    
    <link rel="shortcut icon" href="../e-logo-title.png">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../e-logo-title.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Efl.Canvas.Vg.Image">
  
  
  <h1 id="Efl_Canvas_Vg_Image" data-uid="Efl.Canvas.Vg.Image" class="text-break">Class Efl.Canvas.Vg.Image
  </h1>
  <div class="markdown level0 summary"><p>Efl vector graphics image class</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="remarks">
  <h5 id="Efl_Canvas_Vg_Image_remarks"><strong>Remarks</strong></h5>
  <p>This is a <strong>BETA</strong> class. It can be modified or removed in the future. Do not use it for product development.</p>

  </div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><span class="xref">System.Object</span></div>
    <div class="level1"><a class="xref" href="Efl.Eo.EoWrapper.html">Efl.Eo.EoWrapper</a></div>
    <div class="level2"><a class="xref" href="Efl.Object.html">Efl.Object</a></div>
    <div class="level3"><a class="xref" href="Efl.Canvas.Vg.Node.html">Efl.Canvas.Vg.Node</a></div>
    <div class="level4"><span class="xref"><b>Efl.Canvas.Vg.Image</b></span></div>
  </div>
  
  <h5 id="Efl_Canvas_Vg_Image_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public class Image : Node, IDuplicate, IColor, IEntity, IPath, IStack, IImage, IWrapper, IDisposable</code></pre>
  </div>
  <h3 id="constructors">Constructors
  </h3>
  
  
  <a id="Efl_Canvas_Vg_Image__ctor_" data-uid="Efl.Canvas.Vg.Image.#ctor*"></a>
  <h4 id="Efl_Canvas_Vg_Image__ctor_Efl_Object_" data-uid="Efl.Canvas.Vg.Image.#ctor(Efl.Object)">Image(Object)</h4>
  <div class="markdown level1 summary"><p>Initializes a new instance of the <a class="xref" href="Efl.Canvas.Vg.Image.html">Efl.Canvas.Vg.Image</a> class.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Image(Object parent = null)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Object.html">Efl.Object</a></td>
        <td><span class="parametername">parent</span></td>
        <td><p>Parent instance.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="properties">Properties
  </h3>
  
  
  <a id="Efl_Canvas_Vg_Image_BorderCenterFill_" data-uid="Efl.Canvas.Vg.Image.BorderCenterFill*"></a>
  <h4 id="Efl_Canvas_Vg_Image_BorderCenterFill" data-uid="Efl.Canvas.Vg.Image.BorderCenterFill">BorderCenterFill</h4>
  <div class="markdown level1 summary"><p>Specifies how the center part of the object (not the borders) should be drawn when EFL is rendering it.
This function sets how the center part of the image object's source image is to be drawn, which must be one of the values in <a class="xref" href="Efl.Gfx.BorderFillMode.html">Efl.Gfx.BorderFillMode</a>. By center we mean the complementary part of that defined by <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>. This is very useful for making frames and decorations. You would most probably also be using a filled image (as in <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_FillAuto">Efl.Gfx.IFill.FillAuto</a>) to use as a frame.</p>
<p>The default value is <a class="xref" href="Efl.Gfx.BorderFillMode.html#Efl_Gfx_BorderFillMode_Default">Efl.Gfx.BorderFillMode.Default</a>, ie. render and scale the center area, respecting its transparency.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BorderFillMode BorderCenterFill { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.BorderFillMode.html">Efl.Gfx.BorderFillMode</a></td>
        <td><p>Fill mode of the center region.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_BorderScale_" data-uid="Efl.Canvas.Vg.Image.BorderScale*"></a>
  <h4 id="Efl_Canvas_Vg_Image_BorderScale" data-uid="Efl.Canvas.Vg.Image.BorderScale">BorderScale</h4>
  <div class="markdown level1 summary"><p>Scaling factor applied to the image borders.
This value multiplies the size of the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a> when scaling an object.</p>
<p>Default value is 1.0 (no scaling).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public double BorderScale { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><p>The scale factor.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_ContentHint_" data-uid="Efl.Canvas.Vg.Image.ContentHint*"></a>
  <h4 id="Efl_Canvas_Vg_Image_ContentHint" data-uid="Efl.Canvas.Vg.Image.ContentHint">ContentHint</h4>
  <div class="markdown level1 summary"><p>Get the content hint setting of a given image object of the canvas.
This returns #EVAS_IMAGE_CONTENT_HINT_NONE on error.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ImageContentHint ContentHint { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageContentHint.html">Efl.Gfx.ImageContentHint</a></td>
        <td><p>Dynamic or static content hint, see <a class="xref" href="Efl.Gfx.ImageContentHint.html">Efl.Gfx.ImageContentHint</a></p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_ContentRegion_" data-uid="Efl.Canvas.Vg.Image.ContentRegion*"></a>
  <h4 id="Efl_Canvas_Vg_Image_ContentRegion" data-uid="Efl.Canvas.Vg.Image.ContentRegion">ContentRegion</h4>
  <div class="markdown level1 summary"><p>Return the relative area enclosed inside the image where content is expected.
We do expect content to be inside the limit defined by the border or inside the stretch region. If a stretch region is provided, the content region will encompass the non strechable area that are surrounded by stretchable area. If no border and no stretch region is set, they are assumed to be zero and the full object geometry is where content can be layout on top. The area size change with the object size.</p>
<p>The geometry of the area is expressed relative to the geometry of the object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Rect ContentRegion { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><p>A rectangle inside the object boundary that where content is expected.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_ImageLoadError_" data-uid="Efl.Canvas.Vg.Image.ImageLoadError*"></a>
  <h4 id="Efl_Canvas_Vg_Image_ImageLoadError" data-uid="Efl.Canvas.Vg.Image.ImageLoadError">ImageLoadError</h4>
  <div class="markdown level1 summary"><p>Gets the (last) file loading error for a given object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Error ImageLoadError { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Error.html">Eina.Error</a></td>
        <td><p>The load error code.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_ImageSize_" data-uid="Efl.Canvas.Vg.Image.ImageSize*"></a>
  <h4 id="Efl_Canvas_Vg_Image_ImageSize" data-uid="Efl.Canvas.Vg.Image.ImageSize">ImageSize</h4>
  <div class="markdown level1 summary"><p>This represents the size of the original image in pixels.
This may be different from the actual geometry on screen or even the size of the loaded pixel buffer. This is the size of the image as stored in the original file.</p>
<p>This is a read-only property, and may return 0x0.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Size2D ImageSize { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>The size in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_NativeClass_" data-uid="Efl.Canvas.Vg.Image.NativeClass*"></a>
  <h4 id="Efl_Canvas_Vg_Image_NativeClass" data-uid="Efl.Canvas.Vg.Image.NativeClass">NativeClass</h4>
  <div class="markdown level1 summary"><p>Pointer to the native class description.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public override IntPtr NativeClass { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.IntPtr</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><a class="xref" href="Efl.Canvas.Vg.Node.html#Efl_Canvas_Vg_Node_NativeClass">Node.NativeClass</a></div>
  
  
  <a id="Efl_Canvas_Vg_Image_Ratio_" data-uid="Efl.Canvas.Vg.Image.Ratio*"></a>
  <h4 id="Efl_Canvas_Vg_Image_Ratio" data-uid="Efl.Canvas.Vg.Image.Ratio">Ratio</h4>
  <div class="markdown level1 summary"><p>The native width/height ratio of the image.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public double Ratio { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><p>The image's ratio.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_ScaleHint_" data-uid="Efl.Canvas.Vg.Image.ScaleHint*"></a>
  <h4 id="Efl_Canvas_Vg_Image_ScaleHint" data-uid="Efl.Canvas.Vg.Image.ScaleHint">ScaleHint</h4>
  <div class="markdown level1 summary"><p>Get the scale hint of a given image of the canvas.
This function returns the scale hint value of the given image object of the canvas.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ImageScaleHint ScaleHint { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleHint.html">Efl.Gfx.ImageScaleHint</a></td>
        <td><p>Scalable or static size hint, see <a class="xref" href="Efl.Gfx.ImageScaleHint.html">Efl.Gfx.ImageScaleHint</a></p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_ScaleType_" data-uid="Efl.Canvas.Vg.Image.ScaleType*"></a>
  <h4 id="Efl_Canvas_Vg_Image_ScaleType" data-uid="Efl.Canvas.Vg.Image.ScaleType">ScaleType</h4>
  <div class="markdown level1 summary"><p>Control how the image is scaled.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ImageScaleType ScaleType { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleType.html">Efl.Gfx.ImageScaleType</a></td>
        <td><p>Image scale type</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_SmoothScale_" data-uid="Efl.Canvas.Vg.Image.SmoothScale*"></a>
  <h4 id="Efl_Canvas_Vg_Image_SmoothScale" data-uid="Efl.Canvas.Vg.Image.SmoothScale">SmoothScale</h4>
  <div class="markdown level1 summary"><p>Whether to use high-quality image scaling algorithm for this image.
When enabled, a higher quality image scaling algorithm is used when scaling images to sizes other than the source image's original one. This gives better results but is more computationally expensive.</p>
<p><code>true</code> by default</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool SmoothScale { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether to use smooth scale or not.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="Efl_Canvas_Vg_Image_GetBorder_" data-uid="Efl.Canvas.Vg.Image.GetBorder*"></a>
  <h4 id="Efl_Canvas_Vg_Image_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__" data-uid="Efl.Canvas.Vg.Image.GetBorder(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">GetBorder(out Int32, out Int32, out Int32, out Int32)</h4>
  <div class="markdown level1 summary"><p>Dimensions of this image's border, a region that does not scale with the center area.
When EFL renders an image, its source may be scaled to fit the size of the object. This function sets an area from the borders of the image inwards which is not to be scaled. This function is useful for making frames and for widget theming, where, for example, buttons may be of varying sizes, but their border size must remain constant.</p>
<p>The units used for <code>l</code>, <code>r</code>, <code>t</code> and <code>b</code> are canvas units (pixels).</p>
<p>Note: The border region itself may be scaled by the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_SetBorderScale_System_Double_">Efl.Gfx.IImage.SetBorderScale(System.Double)</a> function.</p>
<p>Note: By default, image objects have no borders set, i.e. <code>l</code>, <code>r</code>, <code>t</code> and <code>b</code> start as 0.</p>
<p>Note: Similar to the concepts of 9-patch images or cap insets.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetBorder(out int l, out int r, out int t, out int b)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">l</span></td>
        <td><p>The border's left width.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">r</span></td>
        <td><p>The border's right width.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">t</span></td>
        <td><p>The border's top height.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">b</span></td>
        <td><p>The border's bottom height.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_GetBorderCenterFill_" data-uid="Efl.Canvas.Vg.Image.GetBorderCenterFill*"></a>
  <h4 id="Efl_Canvas_Vg_Image_GetBorderCenterFill" data-uid="Efl.Canvas.Vg.Image.GetBorderCenterFill">GetBorderCenterFill()</h4>
  <div class="markdown level1 summary"><p>Specifies how the center part of the object (not the borders) should be drawn when EFL is rendering it.
This function sets how the center part of the image object's source image is to be drawn, which must be one of the values in <a class="xref" href="Efl.Gfx.BorderFillMode.html">Efl.Gfx.BorderFillMode</a>. By center we mean the complementary part of that defined by <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>. This is very useful for making frames and decorations. You would most probably also be using a filled image (as in <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_FillAuto">Efl.Gfx.IFill.FillAuto</a>) to use as a frame.</p>
<p>The default value is <a class="xref" href="Efl.Gfx.BorderFillMode.html#Efl_Gfx_BorderFillMode_Default">Efl.Gfx.BorderFillMode.Default</a>, ie. render and scale the center area, respecting its transparency.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual BorderFillMode GetBorderCenterFill()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.BorderFillMode.html">Efl.Gfx.BorderFillMode</a></td>
        <td><p>Fill mode of the center region.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_GetBorderScale_" data-uid="Efl.Canvas.Vg.Image.GetBorderScale*"></a>
  <h4 id="Efl_Canvas_Vg_Image_GetBorderScale" data-uid="Efl.Canvas.Vg.Image.GetBorderScale">GetBorderScale()</h4>
  <div class="markdown level1 summary"><p>Scaling factor applied to the image borders.
This value multiplies the size of the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a> when scaling an object.</p>
<p>Default value is 1.0 (no scaling).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual double GetBorderScale()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><p>The scale factor.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_GetContentHint_" data-uid="Efl.Canvas.Vg.Image.GetContentHint*"></a>
  <h4 id="Efl_Canvas_Vg_Image_GetContentHint" data-uid="Efl.Canvas.Vg.Image.GetContentHint">GetContentHint()</h4>
  <div class="markdown level1 summary"><p>Get the content hint setting of a given image object of the canvas.
This returns #EVAS_IMAGE_CONTENT_HINT_NONE on error.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual ImageContentHint GetContentHint()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageContentHint.html">Efl.Gfx.ImageContentHint</a></td>
        <td><p>Dynamic or static content hint, see <a class="xref" href="Efl.Gfx.ImageContentHint.html">Efl.Gfx.ImageContentHint</a></p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_GetContentRegion_" data-uid="Efl.Canvas.Vg.Image.GetContentRegion*"></a>
  <h4 id="Efl_Canvas_Vg_Image_GetContentRegion" data-uid="Efl.Canvas.Vg.Image.GetContentRegion">GetContentRegion()</h4>
  <div class="markdown level1 summary"><p>Return the relative area enclosed inside the image where content is expected.
We do expect content to be inside the limit defined by the border or inside the stretch region. If a stretch region is provided, the content region will encompass the non strechable area that are surrounded by stretchable area. If no border and no stretch region is set, they are assumed to be zero and the full object geometry is where content can be layout on top. The area size change with the object size.</p>
<p>The geometry of the area is expressed relative to the geometry of the object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Rect GetContentRegion()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><p>A rectangle inside the object boundary that where content is expected.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_GetImageLoadError_" data-uid="Efl.Canvas.Vg.Image.GetImageLoadError*"></a>
  <h4 id="Efl_Canvas_Vg_Image_GetImageLoadError" data-uid="Efl.Canvas.Vg.Image.GetImageLoadError">GetImageLoadError()</h4>
  <div class="markdown level1 summary"><p>Gets the (last) file loading error for a given object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Error GetImageLoadError()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Error.html">Eina.Error</a></td>
        <td><p>The load error code.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_GetImageSize_" data-uid="Efl.Canvas.Vg.Image.GetImageSize*"></a>
  <h4 id="Efl_Canvas_Vg_Image_GetImageSize" data-uid="Efl.Canvas.Vg.Image.GetImageSize">GetImageSize()</h4>
  <div class="markdown level1 summary"><p>This represents the size of the original image in pixels.
This may be different from the actual geometry on screen or even the size of the loaded pixel buffer. This is the size of the image as stored in the original file.</p>
<p>This is a read-only property, and may return 0x0.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Size2D GetImageSize()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>The size in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_GetRatio_" data-uid="Efl.Canvas.Vg.Image.GetRatio*"></a>
  <h4 id="Efl_Canvas_Vg_Image_GetRatio" data-uid="Efl.Canvas.Vg.Image.GetRatio">GetRatio()</h4>
  <div class="markdown level1 summary"><p>Returns 1.0 if not applicable (eg. height = 0).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual double GetRatio()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><p>The image's ratio.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_GetScaleHint_" data-uid="Efl.Canvas.Vg.Image.GetScaleHint*"></a>
  <h4 id="Efl_Canvas_Vg_Image_GetScaleHint" data-uid="Efl.Canvas.Vg.Image.GetScaleHint">GetScaleHint()</h4>
  <div class="markdown level1 summary"><p>Get the scale hint of a given image of the canvas.
This function returns the scale hint value of the given image object of the canvas.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual ImageScaleHint GetScaleHint()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleHint.html">Efl.Gfx.ImageScaleHint</a></td>
        <td><p>Scalable or static size hint, see <a class="xref" href="Efl.Gfx.ImageScaleHint.html">Efl.Gfx.ImageScaleHint</a></p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_GetScaleType_" data-uid="Efl.Canvas.Vg.Image.GetScaleType*"></a>
  <h4 id="Efl_Canvas_Vg_Image_GetScaleType" data-uid="Efl.Canvas.Vg.Image.GetScaleType">GetScaleType()</h4>
  <div class="markdown level1 summary"><p>Control how the image is scaled.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual ImageScaleType GetScaleType()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleType.html">Efl.Gfx.ImageScaleType</a></td>
        <td><p>Image scale type</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_GetSmoothScale_" data-uid="Efl.Canvas.Vg.Image.GetSmoothScale*"></a>
  <h4 id="Efl_Canvas_Vg_Image_GetSmoothScale" data-uid="Efl.Canvas.Vg.Image.GetSmoothScale">GetSmoothScale()</h4>
  <div class="markdown level1 summary"><p>Whether to use high-quality image scaling algorithm for this image.
When enabled, a higher quality image scaling algorithm is used when scaling images to sizes other than the source image's original one. This gives better results but is more computationally expensive.</p>
<p><code>true</code> by default</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetSmoothScale()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether to use smooth scale or not.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_GetStretchRegion_" data-uid="Efl.Canvas.Vg.Image.GetStretchRegion*"></a>
  <h4 id="Efl_Canvas_Vg_Image_GetStretchRegion_Eina_Iterator_Efl_Gfx_Image_StretchRegion___Eina_Iterator_Efl_Gfx_Image_StretchRegion___" data-uid="Efl.Canvas.Vg.Image.GetStretchRegion(Eina.Iterator{Efl.Gfx.Image.StretchRegion}@,Eina.Iterator{Efl.Gfx.Image.StretchRegion}@)">GetStretchRegion(out Iterator&lt;StretchRegion&gt;, out Iterator&lt;StretchRegion&gt;)</h4>
  <div class="markdown level1 summary"><p>This property defines the stretchable pixels region of an image.
When the regions are set by the user, the method will walk the iterators once and then destroy them. When the regions are retrieved by the user, it is his responsibility to destroy the iterators.. It will remember the information for the lifetime of the object. It will ignore all value of <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>, <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_BorderScale">Efl.Gfx.IImage.BorderScale</a> and <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_BorderCenterFill">Efl.Gfx.IImage.BorderCenterFill</a> . To reset the object you can just pass <code>null</code> to both horizontal and vertical at the same time.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetStretchRegion(out Iterator&lt;StretchRegion&gt; horizontal, out Iterator&lt;StretchRegion&gt; vertical)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">Eina.Iterator&lt;Efl.Gfx.Image.StretchRegion&gt;</span></td>
        <td><span class="parametername">horizontal</span></td>
        <td><p>Representation of area that are stretchable in the image horizontal space.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">Eina.Iterator&lt;Efl.Gfx.Image.StretchRegion&gt;</span></td>
        <td><span class="parametername">vertical</span></td>
        <td><p>Representation of area that are stretchable in the image vertical space.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_OnImagePreloadEvt_" data-uid="Efl.Canvas.Vg.Image.OnImagePreloadEvt*"></a>
  <h4 id="Efl_Canvas_Vg_Image_OnImagePreloadEvt_EventArgs_" data-uid="Efl.Canvas.Vg.Image.OnImagePreloadEvt(EventArgs)">OnImagePreloadEvt(EventArgs)</h4>
  <div class="markdown level1 summary"><p>Method to raise event ImagePreloadEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnImagePreloadEvt(EventArgs e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventArgs</span></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_OnImageResizeEvt_" data-uid="Efl.Canvas.Vg.Image.OnImageResizeEvt*"></a>
  <h4 id="Efl_Canvas_Vg_Image_OnImageResizeEvt_EventArgs_" data-uid="Efl.Canvas.Vg.Image.OnImageResizeEvt(EventArgs)">OnImageResizeEvt(EventArgs)</h4>
  <div class="markdown level1 summary"><p>Method to raise event ImageResizeEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnImageResizeEvt(EventArgs e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventArgs</span></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_OnImageUnloadEvt_" data-uid="Efl.Canvas.Vg.Image.OnImageUnloadEvt*"></a>
  <h4 id="Efl_Canvas_Vg_Image_OnImageUnloadEvt_EventArgs_" data-uid="Efl.Canvas.Vg.Image.OnImageUnloadEvt(EventArgs)">OnImageUnloadEvt(EventArgs)</h4>
  <div class="markdown level1 summary"><p>Method to raise event ImageUnloadEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnImageUnloadEvt(EventArgs e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventArgs</span></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_SetBorder_" data-uid="Efl.Canvas.Vg.Image.SetBorder*"></a>
  <h4 id="Efl_Canvas_Vg_Image_SetBorder_System_Int32_System_Int32_System_Int32_System_Int32_" data-uid="Efl.Canvas.Vg.Image.SetBorder(System.Int32,System.Int32,System.Int32,System.Int32)">SetBorder(Int32, Int32, Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Dimensions of this image's border, a region that does not scale with the center area.
When EFL renders an image, its source may be scaled to fit the size of the object. This function sets an area from the borders of the image inwards which is not to be scaled. This function is useful for making frames and for widget theming, where, for example, buttons may be of varying sizes, but their border size must remain constant.</p>
<p>The units used for <code>l</code>, <code>r</code>, <code>t</code> and <code>b</code> are canvas units (pixels).</p>
<p>Note: The border region itself may be scaled by the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_SetBorderScale_System_Double_">Efl.Gfx.IImage.SetBorderScale(System.Double)</a> function.</p>
<p>Note: By default, image objects have no borders set, i.e. <code>l</code>, <code>r</code>, <code>t</code> and <code>b</code> start as 0.</p>
<p>Note: Similar to the concepts of 9-patch images or cap insets.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetBorder(int l, int r, int t, int b)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">l</span></td>
        <td><p>The border's left width.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">r</span></td>
        <td><p>The border's right width.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">t</span></td>
        <td><p>The border's top height.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">b</span></td>
        <td><p>The border's bottom height.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_SetBorderCenterFill_" data-uid="Efl.Canvas.Vg.Image.SetBorderCenterFill*"></a>
  <h4 id="Efl_Canvas_Vg_Image_SetBorderCenterFill_Efl_Gfx_BorderFillMode_" data-uid="Efl.Canvas.Vg.Image.SetBorderCenterFill(Efl.Gfx.BorderFillMode)">SetBorderCenterFill(BorderFillMode)</h4>
  <div class="markdown level1 summary"><p>Specifies how the center part of the object (not the borders) should be drawn when EFL is rendering it.
This function sets how the center part of the image object's source image is to be drawn, which must be one of the values in <a class="xref" href="Efl.Gfx.BorderFillMode.html">Efl.Gfx.BorderFillMode</a>. By center we mean the complementary part of that defined by <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>. This is very useful for making frames and decorations. You would most probably also be using a filled image (as in <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_FillAuto">Efl.Gfx.IFill.FillAuto</a>) to use as a frame.</p>
<p>The default value is <a class="xref" href="Efl.Gfx.BorderFillMode.html#Efl_Gfx_BorderFillMode_Default">Efl.Gfx.BorderFillMode.Default</a>, ie. render and scale the center area, respecting its transparency.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetBorderCenterFill(BorderFillMode fill)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.BorderFillMode.html">Efl.Gfx.BorderFillMode</a></td>
        <td><span class="parametername">fill</span></td>
        <td><p>Fill mode of the center region.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_SetBorderScale_" data-uid="Efl.Canvas.Vg.Image.SetBorderScale*"></a>
  <h4 id="Efl_Canvas_Vg_Image_SetBorderScale_System_Double_" data-uid="Efl.Canvas.Vg.Image.SetBorderScale(System.Double)">SetBorderScale(Double)</h4>
  <div class="markdown level1 summary"><p>Scaling factor applied to the image borders.
This value multiplies the size of the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a> when scaling an object.</p>
<p>Default value is 1.0 (no scaling).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetBorderScale(double scale)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">scale</span></td>
        <td><p>The scale factor.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_SetContentHint_" data-uid="Efl.Canvas.Vg.Image.SetContentHint*"></a>
  <h4 id="Efl_Canvas_Vg_Image_SetContentHint_Efl_Gfx_ImageContentHint_" data-uid="Efl.Canvas.Vg.Image.SetContentHint(Efl.Gfx.ImageContentHint)">SetContentHint(ImageContentHint)</h4>
  <div class="markdown level1 summary"><p>Set the content hint setting of a given image object of the canvas.
This function sets the content hint value of the given image of the canvas. For example, if you're on the GL engine and your driver implementation supports it, setting this hint to #EVAS_IMAGE_CONTENT_HINT_DYNAMIC will make it need zero copies at texture upload time, which is an &quot;expensive&quot; operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetContentHint(ImageContentHint hint)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageContentHint.html">Efl.Gfx.ImageContentHint</a></td>
        <td><span class="parametername">hint</span></td>
        <td><p>Dynamic or static content hint, see <a class="xref" href="Efl.Gfx.ImageContentHint.html">Efl.Gfx.ImageContentHint</a></p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_SetData_" data-uid="Efl.Canvas.Vg.Image.SetData*"></a>
  <h4 id="Efl_Canvas_Vg_Image_SetData_System_IntPtr_Eina_Size2D_" data-uid="Efl.Canvas.Vg.Image.SetData(System.IntPtr,Eina.Size2D)">SetData(IntPtr, Size2D)</h4>
  <div class="markdown level1 summary"><p>Set image data</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetData(IntPtr pixels, Size2D size)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.IntPtr</span></td>
        <td><span class="parametername">pixels</span></td>
        <td><p>Image pixels data. The pixel data type is 32bit RGBA</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>The size in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_SetScaleHint_" data-uid="Efl.Canvas.Vg.Image.SetScaleHint*"></a>
  <h4 id="Efl_Canvas_Vg_Image_SetScaleHint_Efl_Gfx_ImageScaleHint_" data-uid="Efl.Canvas.Vg.Image.SetScaleHint(Efl.Gfx.ImageScaleHint)">SetScaleHint(ImageScaleHint)</h4>
  <div class="markdown level1 summary"><p>Set the scale hint of a given image of the canvas.
This function sets the scale hint value of the given image object in the canvas, which will affect how Evas is to cache scaled versions of its original source image.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetScaleHint(ImageScaleHint hint)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleHint.html">Efl.Gfx.ImageScaleHint</a></td>
        <td><span class="parametername">hint</span></td>
        <td><p>Scalable or static size hint, see <a class="xref" href="Efl.Gfx.ImageScaleHint.html">Efl.Gfx.ImageScaleHint</a></p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_SetScaleType_" data-uid="Efl.Canvas.Vg.Image.SetScaleType*"></a>
  <h4 id="Efl_Canvas_Vg_Image_SetScaleType_Efl_Gfx_ImageScaleType_" data-uid="Efl.Canvas.Vg.Image.SetScaleType(Efl.Gfx.ImageScaleType)">SetScaleType(ImageScaleType)</h4>
  <div class="markdown level1 summary"><p>Control how the image is scaled.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetScaleType(ImageScaleType scale_type)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleType.html">Efl.Gfx.ImageScaleType</a></td>
        <td><span class="parametername">scale_type</span></td>
        <td><p>Image scale type</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_SetSmoothScale_" data-uid="Efl.Canvas.Vg.Image.SetSmoothScale*"></a>
  <h4 id="Efl_Canvas_Vg_Image_SetSmoothScale_System_Boolean_" data-uid="Efl.Canvas.Vg.Image.SetSmoothScale(System.Boolean)">SetSmoothScale(Boolean)</h4>
  <div class="markdown level1 summary"><p>Whether to use high-quality image scaling algorithm for this image.
When enabled, a higher quality image scaling algorithm is used when scaling images to sizes other than the source image's original one. This gives better results but is more computationally expensive.</p>
<p><code>true</code> by default</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetSmoothScale(bool smooth_scale)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">smooth_scale</span></td>
        <td><p>Whether to use smooth scale or not.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Vg_Image_SetStretchRegion_" data-uid="Efl.Canvas.Vg.Image.SetStretchRegion*"></a>
  <h4 id="Efl_Canvas_Vg_Image_SetStretchRegion_Eina_Iterator_Efl_Gfx_Image_StretchRegion__Eina_Iterator_Efl_Gfx_Image_StretchRegion__" data-uid="Efl.Canvas.Vg.Image.SetStretchRegion(Eina.Iterator{Efl.Gfx.Image.StretchRegion},Eina.Iterator{Efl.Gfx.Image.StretchRegion})">SetStretchRegion(Iterator&lt;StretchRegion&gt;, Iterator&lt;StretchRegion&gt;)</h4>
  <div class="markdown level1 summary"><p>This property defines the stretchable pixels region of an image.
When the regions are set by the user, the method will walk the iterators once and then destroy them. When the regions are retrieved by the user, it is his responsibility to destroy the iterators.. It will remember the information for the lifetime of the object. It will ignore all value of <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>, <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_BorderScale">Efl.Gfx.IImage.BorderScale</a> and <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_BorderCenterFill">Efl.Gfx.IImage.BorderCenterFill</a> . To reset the object you can just pass <code>null</code> to both horizontal and vertical at the same time.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Error SetStretchRegion(Iterator&lt;StretchRegion&gt; horizontal, Iterator&lt;StretchRegion&gt; vertical)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">Eina.Iterator&lt;Efl.Gfx.Image.StretchRegion&gt;</span></td>
        <td><span class="parametername">horizontal</span></td>
        <td><p>Representation of area that are stretchable in the image horizontal space.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">Eina.Iterator&lt;Efl.Gfx.Image.StretchRegion&gt;</span></td>
        <td><span class="parametername">vertical</span></td>
        <td><p>Representation of area that are stretchable in the image vertical space.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Error.html">Eina.Error</a></td>
        <td><p>return an error code if the stretch_region provided are incorrect.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="events">Events
  </h3>
  
  
  <h4 id="Efl_Canvas_Vg_Image_ImagePreloadEvt" data-uid="Efl.Canvas.Vg.Image.ImagePreloadEvt">ImagePreloadEvt</h4>
  <div class="markdown level1 summary"><p>Image data has been preloaded.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler ImagePreloadEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Vg_Image_ImageResizeEvt" data-uid="Efl.Canvas.Vg.Image.ImageResizeEvt">ImageResizeEvt</h4>
  <div class="markdown level1 summary"><p>Image was resized (its pixel data).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler ImageResizeEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Vg_Image_ImageUnloadEvt" data-uid="Efl.Canvas.Vg.Image.ImageUnloadEvt">ImageUnloadEvt</h4>
  <div class="markdown level1 summary"><p>Image data has been unloaded (by some mechanism in EFL that threw out the original image data).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler ImageUnloadEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h3 id="implements">Implements</h3>
  <div>
      <a class="xref" href="Efl.IDuplicate.html">Efl.IDuplicate</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IColor.html">Efl.Gfx.IColor</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IEntity.html">Efl.Gfx.IEntity</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IPath.html">Efl.Gfx.IPath</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IStack.html">Efl.Gfx.IStack</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IImage.html">Efl.Gfx.IImage</a>
  </div>
  <div>
      <a class="xref" href="Efl.Eo.IWrapper.html">Efl.Eo.IWrapper</a>
  </div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
