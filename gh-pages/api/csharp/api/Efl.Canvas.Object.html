<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class Efl.Canvas.Object
   </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class Efl.Canvas.Object
   ">
    <meta name="generator" content="docfx 2.40.4.0">
    
    <link rel="shortcut icon" href="../e-logo-title.png">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../e-logo-title.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Efl.Canvas.Object">
  
  
  <h1 id="Efl_Canvas_Object" data-uid="Efl.Canvas.Object" class="text-break">Class Efl.Canvas.Object
  </h1>
  <div class="markdown level0 summary"><p>Efl canvas object abstract class
(Since EFL 1.22)</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><span class="xref">System.Object</span></div>
    <div class="level1"><a class="xref" href="Efl.Eo.EoWrapper.html">Efl.Eo.EoWrapper</a></div>
    <div class="level2"><a class="xref" href="Efl.Object.html">Efl.Object</a></div>
    <div class="level3"><a class="xref" href="Efl.LoopConsumer.html">Efl.LoopConsumer</a></div>
    <div class="level4"><span class="xref"><b>Efl.Canvas.Object</b></span></div>
      <div class="level5"><a class="xref" href="Efl.Canvas.Group.html">Efl.Canvas.Group</a></div>
      <div class="level5"><a class="xref" href="Efl.Canvas.ImageInternal.html">Efl.Canvas.ImageInternal</a></div>
      <div class="level5"><a class="xref" href="Efl.Canvas.Polygon.html">Efl.Canvas.Polygon</a></div>
      <div class="level5"><a class="xref" href="Efl.Canvas.Rectangle.html">Efl.Canvas.Rectangle</a></div>
      <div class="level5"><a class="xref" href="Efl.Canvas.Text.html">Efl.Canvas.Text</a></div>
      <div class="level5"><a class="xref" href="Efl.Canvas.Vg.Object.html">Efl.Canvas.Vg.Object</a></div>
  </div>
  
  <h5 id="Efl_Canvas_Object_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public abstract class Object : LoopConsumer, IPointer, IEvents, IColor, IEntity, IHint, IMapping, IStack, IInterface, II18n, IWrapper, IDisposable</code></pre>
  </div>
  <h3 id="constructors">Constructors
  </h3>
  
  
  <a id="Efl_Canvas_Object__ctor_" data-uid="Efl.Canvas.Object.#ctor*"></a>
  <h4 id="Efl_Canvas_Object__ctor_Efl_Eo_EoWrapper_ConstructingHandle_" data-uid="Efl.Canvas.Object.#ctor(Efl.Eo.EoWrapper.ConstructingHandle)">Object(EoWrapper.ConstructingHandle)</h4>
  <div class="markdown level1 summary"><p>Subclasses should override this constructor if they are expected to be instantiated from native code.
Do not call this constructor directly.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected Object(EoWrapper.ConstructingHandle ch)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Eo.EoWrapper.ConstructingHandle.html">Efl.Eo.EoWrapper.ConstructingHandle</a></td>
        <td><span class="parametername">ch</span></td>
        <td><p>Tag struct storing the native handle of the object being constructed.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object__ctor_" data-uid="Efl.Canvas.Object.#ctor*"></a>
  <h4 id="Efl_Canvas_Object__ctor_Efl_Object_" data-uid="Efl.Canvas.Object.#ctor(Efl.Object)">Object(Object)</h4>
  <div class="markdown level1 summary"><p>Initializes a new instance of the <a class="xref" href="Efl.Canvas.Object.html">Efl.Canvas.Object</a> class.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Object(Object parent = null)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Object.html">Efl.Object</a></td>
        <td><span class="parametername">parent</span></td>
        <td><p>Parent instance.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="properties">Properties
  </h3>
  
  
  <a id="Efl_Canvas_Object_Above_" data-uid="Efl.Canvas.Object.Above*"></a>
  <h4 id="Efl_Canvas_Object_Above" data-uid="Efl.Canvas.Object.Above">Above</h4>
  <div class="markdown level1 summary"><p>Get the Evas object stacked right above <code>obj</code>
This function will traverse layers in its search, if there are objects on layers above the one <code>obj</code> is placed at.</p>
<p>See also <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_GetLayer">Efl.Gfx.IStack.GetLayer()</a>, <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_SetLayer_System_Int16_">Efl.Gfx.IStack.SetLayer(System.Int16)</a> and <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_GetBelow">Efl.Gfx.IStack.GetBelow()</a>
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public IStack Above { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IStack.html">Efl.Gfx.IStack</a></td>
        <td><p>The <a class="xref" href="Efl.Gfx.IStack.html">Efl.Gfx.IStack</a> object directly below <code>obj</code>, if any, or <code>null</code>, if none.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_AntiAlias_" data-uid="Efl.Canvas.Object.AntiAlias*"></a>
  <h4 id="Efl_Canvas_Object_AntiAlias" data-uid="Efl.Canvas.Object.AntiAlias">AntiAlias</h4>
  <div class="markdown level1 summary"><p>Retrieves whether or not the given Evas object is to be drawn anti_aliased.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool AntiAlias { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if the object is to be anti_aliased, <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Below_" data-uid="Efl.Canvas.Object.Below*"></a>
  <h4 id="Efl_Canvas_Object_Below" data-uid="Efl.Canvas.Object.Below">Below</h4>
  <div class="markdown level1 summary"><p>Get the Evas object stacked right below <code>obj</code>
This function will traverse layers in its search, if there are objects on layers below the one <code>obj</code> is placed at.</p>
<p>See also <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_GetLayer">Efl.Gfx.IStack.GetLayer()</a>, <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_SetLayer_System_Int16_">Efl.Gfx.IStack.SetLayer(System.Int16)</a> and <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_GetBelow">Efl.Gfx.IStack.GetBelow()</a>
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public IStack Below { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IStack.html">Efl.Gfx.IStack</a></td>
        <td><p>The <a class="xref" href="Efl.Gfx.IStack.html">Efl.Gfx.IStack</a> object directly below <code>obj</code>, if any, or <code>null</code>, if none.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_ClippedObjects_" data-uid="Efl.Canvas.Object.ClippedObjects*"></a>
  <h4 id="Efl_Canvas_Object_ClippedObjects" data-uid="Efl.Canvas.Object.ClippedObjects">ClippedObjects</h4>
  <div class="markdown level1 summary"><p>Return a list of objects currently clipped by <code>obj</code>.
This returns the internal list handle containing all objects clipped by the object <code>obj</code>. If none are clipped by it, the call returns <code>null</code>. This list is only valid until the clip list is changed and should be fetched again with another call to this function if any objects being clipped by this object are unclipped, clipped by a new object, deleted or get the clipper deleted. These operations will invalidate the list returned, so it should not be used anymore after that point. Any use of the list after this may have undefined results, possibly leading to crashes.</p>
<p>See also <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_Clipper">Efl.Canvas.Object.Clipper</a>.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Iterator&lt;Object&gt; ClippedObjects { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">Eina.Iterator&lt;Efl.Canvas.Object&gt;</span></td>
        <td><p>An iterator over the list of objects clipped by <code>obj</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Clipper_" data-uid="Efl.Canvas.Object.Clipper*"></a>
  <h4 id="Efl_Canvas_Object_Clipper" data-uid="Efl.Canvas.Object.Clipper">Clipper</h4>
  <div class="markdown level1 summary"><p>Get the object clipping <code>obj</code> (if any).
This function returns the object clipping <code>obj</code>. If <code>obj</code> is not being clipped at all, <code>null</code> is returned. The object <code>obj</code> must be a valid Evas_Object.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Object Clipper { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Canvas.Object.html">Efl.Canvas.Object</a></td>
        <td><p>The object to clip <code>obj</code> by.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_ColorCode_" data-uid="Efl.Canvas.Object.ColorCode*"></a>
  <h4 id="Efl_Canvas_Object_ColorCode" data-uid="Efl.Canvas.Object.ColorCode">ColorCode</h4>
  <div class="markdown level1 summary"><p>Get hex color code of given Evas object. This returns a short lived hex color code string.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public string ColorCode { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><p>the hex color code.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Geometry_" data-uid="Efl.Canvas.Object.Geometry*"></a>
  <h4 id="Efl_Canvas_Object_Geometry" data-uid="Efl.Canvas.Object.Geometry">Geometry</h4>
  <div class="markdown level1 summary"><p>Rectangular geometry that combines both position and size.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Rect Geometry { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><p>The X,Y position and W,H size, in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_HintSizeCombinedMin_" data-uid="Efl.Canvas.Object.HintSizeCombinedMin*"></a>
  <h4 id="Efl_Canvas_Object_HintSizeCombinedMin" data-uid="Efl.Canvas.Object.HintSizeCombinedMin">HintSizeCombinedMin</h4>
  <div class="markdown level1 summary"><p>Read-only minimum size combining both <a class="xref" href="Efl.Gfx.IHint.html#Efl_Gfx_IHint_HintSizeRestrictedMin">Efl.Gfx.IHint.HintSizeRestrictedMin</a> and <a class="xref" href="Efl.Gfx.IHint.html#Efl_Gfx_IHint_HintSizeMin">Efl.Gfx.IHint.HintSizeMin</a> hints.
<a class="xref" href="Efl.Gfx.IHint.html#Efl_Gfx_IHint_HintSizeRestrictedMin">Efl.Gfx.IHint.HintSizeRestrictedMin</a> is intended for mostly internal usage and widget developers, and <a class="xref" href="Efl.Gfx.IHint.html#Efl_Gfx_IHint_HintSizeMin">Efl.Gfx.IHint.HintSizeMin</a> is intended to be set from application side. <a class="xref" href="Efl.Gfx.IHint.html#Efl_Gfx_IHint_GetHintSizeCombinedMin">Efl.Gfx.IHint.GetHintSizeCombinedMin()</a> combines both values by taking their repective maximum (in both width and height), and is used internally to get an object's minimum size.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Size2D HintSizeCombinedMin { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>Minimum size (hint) in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_HintSizeMax_" data-uid="Efl.Canvas.Object.HintSizeMax*"></a>
  <h4 id="Efl_Canvas_Object_HintSizeMax" data-uid="Efl.Canvas.Object.HintSizeMax">HintSizeMax</h4>
  <div class="markdown level1 summary"><p>Hints on the object's maximum size.
This is not a size enforcement in any way, it's just a hint that should be used whenever appropriate.</p>
<p>The object container is in charge of fetching this property and placing the object accordingly.</p>
<p>Values -1 will be treated as unset hint components, when queried by managers.</p>
<p>Note: Smart objects (such as elementary) can have their own hint policy. So calling this API may or may not affect the size of smart objects.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Size2D HintSizeMax { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>Maximum size (hint) in pixels, (-1, -1) by default for canvas objects).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_HintSizeMin_" data-uid="Efl.Canvas.Object.HintSizeMin*"></a>
  <h4 id="Efl_Canvas_Object_HintSizeMin" data-uid="Efl.Canvas.Object.HintSizeMin">HintSizeMin</h4>
  <div class="markdown level1 summary"><p>Hints on the object's minimum size.
This is not a size enforcement in any way, it's just a hint that should be used whenever appropriate. The object container is in charge of fetching this property and placing the object accordingly.</p>
<p>Value 0 will be treated as unset hint components, when queried by managers.</p>
<p>Note: This property is meant to be set by applications and not by EFL itself. Use this to request a specific size (treated as minimum size).
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Size2D HintSizeMin { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>Minimum size (hint) in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_HintSizeRestrictedMin_" data-uid="Efl.Canvas.Object.HintSizeRestrictedMin*"></a>
  <h4 id="Efl_Canvas_Object_HintSizeRestrictedMin" data-uid="Efl.Canvas.Object.HintSizeRestrictedMin">HintSizeRestrictedMin</h4>
  <div class="markdown level1 summary"><p>Internal hints for an object's minimum size.
This is not a size enforcement in any way, it's just a hint that should be used whenever appropriate.</p>
<p>Values 0 will be treated as unset hint components, when queried by managers.</p>
<p>Note: This property is internal and meant for widget developers to define the absolute minimum size of the object. EFL itself sets this size internally, so any change to it from an application might be ignored. Use <a class="xref" href="Efl.Gfx.IHint.html#Efl_Gfx_IHint_HintSizeMin">Efl.Gfx.IHint.HintSizeMin</a> instead.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Size2D HintSizeRestrictedMin { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>Minimum size (hint) in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_KeyFocus_" data-uid="Efl.Canvas.Object.KeyFocus*"></a>
  <h4 id="Efl_Canvas_Object_KeyFocus" data-uid="Efl.Canvas.Object.KeyFocus">KeyFocus</h4>
  <div class="markdown level1 summary"><p>Indicates that this object is the keyboard event receiver on its canvas.
Changing focus only affects where (key) input events go. There can be only one object focused at any time. If <code>focus</code> is <code>true</code>, <code>obj</code> will be set as the currently focused object and it will receive all keyboard events that are not exclusive key grabs on other objects. See also <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_CheckSeatFocus_Efl_Input_Device_">Efl.Canvas.Object.CheckSeatFocus(Efl.Input.Device)</a>, <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_AddSeatFocus_Efl_Input_Device_">Efl.Canvas.Object.AddSeatFocus(Efl.Input.Device)</a>, <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_DelSeatFocus_Efl_Input_Device_">Efl.Canvas.Object.DelSeatFocus(Efl.Input.Device)</a>.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool KeyFocus { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> when set as focused or <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Language_" data-uid="Efl.Canvas.Object.Language*"></a>
  <h4 id="Efl_Canvas_Object_Language" data-uid="Efl.Canvas.Object.Language">Language</h4>
  <div class="markdown level1 summary"><p>The (human) language for this object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public string Language { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><p>The current language.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Layer_" data-uid="Efl.Canvas.Object.Layer*"></a>
  <h4 id="Efl_Canvas_Object_Layer" data-uid="Efl.Canvas.Object.Layer">Layer</h4>
  <div class="markdown level1 summary"><p>Retrieves the layer of its canvas that the given object is part of.
See also <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_SetLayer_System_Int16_">Efl.Gfx.IStack.SetLayer(System.Int16)</a>
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public short Layer { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int16</span></td>
        <td><p>The number of the layer to place the object on. Must be between <a class="xref" href="Efl.Gfx.Constants.html#Efl_Gfx_Constants_StackLayerMin">Efl.Gfx.Constants.StackLayerMin</a> and <a class="xref" href="Efl.Gfx.Constants.html#Efl_Gfx_Constants_StackLayerMax">Efl.Gfx.Constants.StackLayerMax</a>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_MappingAlpha_" data-uid="Efl.Canvas.Object.MappingAlpha*"></a>
  <h4 id="Efl_Canvas_Object_MappingAlpha" data-uid="Efl.Canvas.Object.MappingAlpha">MappingAlpha</h4>
  <div class="markdown level1 summary"><p>Alpha flag for map rendering.
This sets alpha flag for map rendering. If the object is a type that has its own alpha settings, then this will take precedence. Only image objects support this currently (<a class="xref" href="Efl.Canvas.Image.html">Efl.Canvas.Image</a> and its friends). Setting this to off stops alpha blending of the map area, and is useful if you know the object and/or all sub-objects is 100% solid.</p>
<p>Note that this may conflict with <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_MappingSmooth">Efl.Gfx.IMapping.MappingSmooth</a> depending on which algorithm is used for anti-aliasing.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool MappingAlpha { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> by default.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_MappingClockwise_" data-uid="Efl.Canvas.Object.MappingClockwise*"></a>
  <h4 id="Efl_Canvas_Object_MappingClockwise" data-uid="Efl.Canvas.Object.MappingClockwise">MappingClockwise</h4>
  <div class="markdown level1 summary"><p>Clockwise state of a map (read-only).
This determines if the output points (X and Y. Z is not used) are clockwise or counter-clockwise. This can be used for &quot;back-face culling&quot;. This is where you hide objects that &quot;face away&quot; from you. In this case objects that are not clockwise.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool MappingClockwise { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if clockwise, <code>false</code> if counter clockwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_MappingPointCount_" data-uid="Efl.Canvas.Object.MappingPointCount*"></a>
  <h4 id="Efl_Canvas_Object_MappingPointCount" data-uid="Efl.Canvas.Object.MappingPointCount">MappingPointCount</h4>
  <div class="markdown level1 summary"><p>Number of points of a map.
This sets the number of points of map. Currently, the number of points must be multiples of 4.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int MappingPointCount { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of points of map</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_MappingSmooth_" data-uid="Efl.Canvas.Object.MappingSmooth*"></a>
  <h4 id="Efl_Canvas_Object_MappingSmooth" data-uid="Efl.Canvas.Object.MappingSmooth">MappingSmooth</h4>
  <div class="markdown level1 summary"><p>Smoothing state for map rendering.
This sets smoothing for map rendering. If the object is a type that has its own smoothing settings, then both the smooth settings for this object and the map must be turned off. By default smooth maps are enabled.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool MappingSmooth { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> by default.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Mirrored_" data-uid="Efl.Canvas.Object.Mirrored*"></a>
  <h4 id="Efl_Canvas_Object_Mirrored" data-uid="Efl.Canvas.Object.Mirrored">Mirrored</h4>
  <div class="markdown level1 summary"><p>Whether this object should be mirrored.
If mirrored, an object is in RTL (right to left) mode instead of LTR (left to right).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool Mirrored { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> for RTL, <code>false</code> for LTR (default).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_MirroredAutomatic_" data-uid="Efl.Canvas.Object.MirroredAutomatic*"></a>
  <h4 id="Efl_Canvas_Object_MirroredAutomatic" data-uid="Efl.Canvas.Object.MirroredAutomatic">MirroredAutomatic</h4>
  <div class="markdown level1 summary"><p>Whether the property <a class="xref" href="Efl.Ui.II18n.html#Efl_Ui_II18n_Mirrored">Efl.Ui.II18n.Mirrored</a> should be set automatically.
If enabled, the system or application configuration will be used to set the value of <a class="xref" href="Efl.Ui.II18n.html#Efl_Ui_II18n_Mirrored">Efl.Ui.II18n.Mirrored</a>.</p>
<p>This property may be implemented by high-level widgets (in Efl.Ui) but not by low-level widgets (in <a class="xref" href="Efl.Canvas.IScene.html">Efl.Canvas.IScene</a>) as the configuration should affect only high-level widgets.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool MirroredAutomatic { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether the widget uses automatic mirroring</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_NoRender_" data-uid="Efl.Canvas.Object.NoRender*"></a>
  <h4 id="Efl_Canvas_Object_NoRender" data-uid="Efl.Canvas.Object.NoRender">NoRender</h4>
  <div class="markdown level1 summary"><p>Returns the state of the &quot;no-render&quot; flag, which means, when true, that an object should never be rendered on the canvas.
This flag can be used to avoid rendering visible clippers on the canvas, even if they currently don't clip any object.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool NoRender { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Enable &quot;no-render&quot; mode.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_ParagraphDirection_" data-uid="Efl.Canvas.Object.ParagraphDirection*"></a>
  <h4 id="Efl_Canvas_Object_ParagraphDirection" data-uid="Efl.Canvas.Object.ParagraphDirection">ParagraphDirection</h4>
  <div class="markdown level1 summary"><p>This handles text paragraph direction of the given object. Even if the given object is not textblock or text, its smart child objects can inherit the paragraph direction from the given object. The default paragraph direction is <code>inherit</code>.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TextBidirectionalType ParagraphDirection { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.TextBidirectionalType.html">Efl.TextBidirectionalType</a></td>
        <td><p>Paragraph direction for the given object.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_PassEvents_" data-uid="Efl.Canvas.Object.PassEvents*"></a>
  <h4 id="Efl_Canvas_Object_PassEvents" data-uid="Efl.Canvas.Object.PassEvents">PassEvents</h4>
  <div class="markdown level1 summary"><p>Determine whether an object is set to pass (ignore) events.
See also <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetRepeatEvents">Efl.Canvas.Object.GetRepeatEvents()</a>, <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetPropagateEvents">Efl.Canvas.Object.GetPropagateEvents()</a>.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool PassEvents { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether <code>obj</code> is to pass events (<code>true</code>) or not (<code>false</code>).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_PointerMode_" data-uid="Efl.Canvas.Object.PointerMode*"></a>
  <h4 id="Efl_Canvas_Object_PointerMode" data-uid="Efl.Canvas.Object.PointerMode">PointerMode</h4>
  <div class="markdown level1 summary"><p>Low-level pointer behaviour.
This function has a direct effect on event callbacks related to pointers (mouse, ...).</p>
<p>If the value is <a class="xref" href="Efl.Input.ObjectPointerMode.html#Efl_Input_ObjectPointerMode_AutoGrab">Efl.Input.ObjectPointerMode.AutoGrab</a> (default), then when mouse is pressed down over this object, events will be restricted to it as source, mouse moves, for example, will be emitted even when the pointer goes outside this objects geometry.</p>
<p>If the value is <a class="xref" href="Efl.Input.ObjectPointerMode.html#Efl_Input_ObjectPointerMode_NoGrab">Efl.Input.ObjectPointerMode.NoGrab</a>, then events will be emitted just when inside this object area.</p>
<p>The default value is <a class="xref" href="Efl.Input.ObjectPointerMode.html#Efl_Input_ObjectPointerMode_AutoGrab">Efl.Input.ObjectPointerMode.AutoGrab</a>. See also: <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetPointerModeByDevice_Efl_Input_Device_">Efl.Canvas.Object.GetPointerModeByDevice(Efl.Input.Device)</a> and <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetPointerModeByDevice_Efl_Input_Device_">Efl.Canvas.Object.GetPointerModeByDevice(Efl.Input.Device)</a> Note: This function will only set/get the mode for the default pointer.
(Since EFL 1.22)</p>
<p><strong>This is a BETA property</strong>. It can be modified or removed in the future. Do not use it for product development.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ObjectPointerMode PointerMode { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.ObjectPointerMode.html">Efl.Input.ObjectPointerMode</a></td>
        <td><p>Input pointer mode</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Position_" data-uid="Efl.Canvas.Object.Position*"></a>
  <h4 id="Efl_Canvas_Object_Position" data-uid="Efl.Canvas.Object.Position">Position</h4>
  <div class="markdown level1 summary"><p>The 2D position of a canvas object.
The position is absolute, in pixels, relative to the top-left corner of the window, within its border decorations (application space).
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Position2D Position { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Position2D.html">Eina.Position2D</a></td>
        <td><p>A 2D coordinate in pixel units.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_PreciseIsInside_" data-uid="Efl.Canvas.Object.PreciseIsInside*"></a>
  <h4 id="Efl_Canvas_Object_PreciseIsInside" data-uid="Efl.Canvas.Object.PreciseIsInside">PreciseIsInside</h4>
  <div class="markdown level1 summary"><p>Determine whether an object is set to use precise point collision detection.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool PreciseIsInside { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether to use precise point collision detection or not. The default value is false.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_PropagateEvents_" data-uid="Efl.Canvas.Object.PropagateEvents*"></a>
  <h4 id="Efl_Canvas_Object_PropagateEvents" data-uid="Efl.Canvas.Object.PropagateEvents">PropagateEvents</h4>
  <div class="markdown level1 summary"><p>Retrieve whether an Evas object is set to propagate events.
See also <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetRepeatEvents">Efl.Canvas.Object.GetRepeatEvents()</a>, <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetPassEvents">Efl.Canvas.Object.GetPassEvents()</a>.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool PropagateEvents { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether to propagate events (<code>true</code>) or not (<code>false</code>).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_RenderOp_" data-uid="Efl.Canvas.Object.RenderOp*"></a>
  <h4 id="Efl_Canvas_Object_RenderOp" data-uid="Efl.Canvas.Object.RenderOp">RenderOp</h4>
  <div class="markdown level1 summary"><p>Render mode to be used for compositing the Evas object.
Only two modes are supported: - <a class="xref" href="Efl.Gfx.RenderOp.html#Efl_Gfx_RenderOp_Blend">Efl.Gfx.RenderOp.Blend</a> means the object will be merged on top of objects below it using simple alpha compositing. - <a class="xref" href="Efl.Gfx.RenderOp.html#Efl_Gfx_RenderOp_Copy">Efl.Gfx.RenderOp.Copy</a> means this object's pixels will replace everything that is below, making this object opaque.</p>
<p>Please do not assume that <a class="xref" href="Efl.Gfx.RenderOp.html#Efl_Gfx_RenderOp_Copy">Efl.Gfx.RenderOp.Copy</a> mode can be used to &quot;poke&quot; holes in a window (to see through it), as only the compositor can ensure that. Copy mode should only be used with otherwise opaque widgets or inside non-window surfaces (eg. a transparent background inside a buffer canvas).
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public RenderOp RenderOp { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.RenderOp.html">Efl.Gfx.RenderOp</a></td>
        <td><p>Blend or copy.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_RenderParent_" data-uid="Efl.Canvas.Object.RenderParent*"></a>
  <h4 id="Efl_Canvas_Object_RenderParent" data-uid="Efl.Canvas.Object.RenderParent">RenderParent</h4>
  <div class="markdown level1 summary"><p>Gets the parent smart object of a given Evas object, if it has one.
This can be different from <a class="xref" href="Efl.Object.html#Efl_Object_Parent">Efl.Object.Parent</a> because this one is used internally for rendering and the normal parent is what the user expects to be the parent.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected Object RenderParent { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Canvas.Object.html">Efl.Canvas.Object</a></td>
        <td><p>The parent smart object of <code>obj</code> or <code>null</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_RepeatEvents_" data-uid="Efl.Canvas.Object.RepeatEvents*"></a>
  <h4 id="Efl_Canvas_Object_RepeatEvents" data-uid="Efl.Canvas.Object.RepeatEvents">RepeatEvents</h4>
  <div class="markdown level1 summary"><p>Determine whether an object is set to repeat events.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool RepeatEvents { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether <code>obj</code> is to repeat events (<code>true</code>) or not (<code>false</code>).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Scale_" data-uid="Efl.Canvas.Object.Scale*"></a>
  <h4 id="Efl_Canvas_Object_Scale" data-uid="Efl.Canvas.Object.Scale">Scale</h4>
  <div class="markdown level1 summary"><p>The scaling factor of an object.
This property is an individual scaling factor on the object (Edje or UI widget). This property (or Edje's global scaling factor, when applicable), will affect this object's part sizes. If scale is not zero, than the individual scaling will override any global scaling set, for the object obj's parts. Set it back to zero to get the effects of the global scaling again.</p>
<p>Warning: In Edje, only parts which, at EDC level, had the &quot;scale&quot; property set to 1, will be affected by this function. Check the complete &quot;syntax reference&quot; for EDC files.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public double Scale { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><p>The scaling factor (the default value is 0.0, meaning individual scaling is not set)</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SeatFocus_" data-uid="Efl.Canvas.Object.SeatFocus*"></a>
  <h4 id="Efl_Canvas_Object_SeatFocus" data-uid="Efl.Canvas.Object.SeatFocus">SeatFocus</h4>
  <div class="markdown level1 summary"><p>Check if this object is focused.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool SeatFocus { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if focused by at least one seat or <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Size_" data-uid="Efl.Canvas.Object.Size*"></a>
  <h4 id="Efl_Canvas_Object_Size" data-uid="Efl.Canvas.Object.Size">Size</h4>
  <div class="markdown level1 summary"><p>The 2D size of a canvas object.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Size2D Size { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>A 2D size in pixel units.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Visible_" data-uid="Efl.Canvas.Object.Visible*"></a>
  <h4 id="Efl_Canvas_Object_Visible" data-uid="Efl.Canvas.Object.Visible">Visible</h4>
  <div class="markdown level1 summary"><p>The visibility of a canvas object.
All canvas objects will become visible by default just before render. This means that it is not required to call <a class="xref" href="Efl.Gfx.IEntity.html#Efl_Gfx_IEntity_SetVisible_System_Boolean_">Efl.Gfx.IEntity.SetVisible(System.Boolean)</a> after creating an object unless you want to create it without showing it. Note that this behavior is new since 1.21, and only applies to canvas objects created with the EO API (i.e. not the legacy C-only API). Other types of Gfx objects may or may not be visible by default.</p>
<p>Note that many other parameters can prevent a visible object from actually being &quot;visible&quot; on screen. For instance if its color is fully transparent, or its parent is hidden, or it is clipped out, etc...
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool Visible { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if to make the object visible, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="Efl_Canvas_Object_AddSeatFocus_" data-uid="Efl.Canvas.Object.AddSeatFocus*"></a>
  <h4 id="Efl_Canvas_Object_AddSeatFocus_Efl_Input_Device_" data-uid="Efl.Canvas.Object.AddSeatFocus(Efl.Input.Device)">AddSeatFocus(Device)</h4>
  <div class="markdown level1 summary"><p>Add a seat to the focus list.
Evas allows the Efl.Canvas.Object to be focused by multiple seats at the same time. This function adds a new seat to the focus list. In other words, after the seat is added to the list this object will now be also focused by this new seat.</p>
<p>Note: The old focus APIs still work, however they will only act on the default seat.
(Since EFL 1.22)</p>
<p><strong>This is a BETA method</strong>. It can be modified or removed in the future. Do not use it for product development.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool AddSeatFocus(Device seat)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.Device.html">Efl.Input.Device</a></td>
        <td><span class="parametername">seat</span></td>
        <td><p>The seat that should be added to the focus list. Use <code>null</code> for the default seat.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if the focus has been set or <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_CheckSeatFocus_" data-uid="Efl.Canvas.Object.CheckSeatFocus*"></a>
  <h4 id="Efl_Canvas_Object_CheckSeatFocus_Efl_Input_Device_" data-uid="Efl.Canvas.Object.CheckSeatFocus(Efl.Input.Device)">CheckSeatFocus(Device)</h4>
  <div class="markdown level1 summary"><p>Check if this object is focused by a given seat
(Since EFL 1.22)</p>
<p><strong>This is a BETA method</strong>. It can be modified or removed in the future. Do not use it for product development.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool CheckSeatFocus(Device seat)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.Device.html">Efl.Input.Device</a></td>
        <td><span class="parametername">seat</span></td>
        <td><p>The seat to check if the object is focused. Use <code>null</code> for the default seat.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if focused or <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_ClippedObjectsCount_" data-uid="Efl.Canvas.Object.ClippedObjectsCount*"></a>
  <h4 id="Efl_Canvas_Object_ClippedObjectsCount" data-uid="Efl.Canvas.Object.ClippedObjectsCount">ClippedObjectsCount()</h4>
  <div class="markdown level1 summary"><p>Returns the number of objects clipped by <code>obj</code>
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual uint ClippedObjectsCount()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><p>The number of objects clipped by <code>obj</code></p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_DelSeatFocus_" data-uid="Efl.Canvas.Object.DelSeatFocus*"></a>
  <h4 id="Efl_Canvas_Object_DelSeatFocus_Efl_Input_Device_" data-uid="Efl.Canvas.Object.DelSeatFocus(Efl.Input.Device)">DelSeatFocus(Device)</h4>
  <div class="markdown level1 summary"><p>Remove a seat from the focus list.
(Since EFL 1.22)</p>
<p><strong>This is a BETA method</strong>. It can be modified or removed in the future. Do not use it for product development.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool DelSeatFocus(Device seat)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.Device.html">Efl.Input.Device</a></td>
        <td><span class="parametername">seat</span></td>
        <td><p>The seat that should be removed from the focus list. Use <code>null</code> for the default seat.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if the seat was removed from the focus list or <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetAbove_" data-uid="Efl.Canvas.Object.GetAbove*"></a>
  <h4 id="Efl_Canvas_Object_GetAbove" data-uid="Efl.Canvas.Object.GetAbove">GetAbove()</h4>
  <div class="markdown level1 summary"><p>Get the Evas object stacked right above <code>obj</code>
This function will traverse layers in its search, if there are objects on layers above the one <code>obj</code> is placed at.</p>
<p>See also <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_GetLayer">Efl.Gfx.IStack.GetLayer()</a>, <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_SetLayer_System_Int16_">Efl.Gfx.IStack.SetLayer(System.Int16)</a> and <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_GetBelow">Efl.Gfx.IStack.GetBelow()</a>
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual IStack GetAbove()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IStack.html">Efl.Gfx.IStack</a></td>
        <td><p>The <a class="xref" href="Efl.Gfx.IStack.html">Efl.Gfx.IStack</a> object directly below <code>obj</code>, if any, or <code>null</code>, if none.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetAntiAlias_" data-uid="Efl.Canvas.Object.GetAntiAlias*"></a>
  <h4 id="Efl_Canvas_Object_GetAntiAlias" data-uid="Efl.Canvas.Object.GetAntiAlias">GetAntiAlias()</h4>
  <div class="markdown level1 summary"><p>Retrieves whether or not the given Evas object is to be drawn anti_aliased.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetAntiAlias()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if the object is to be anti_aliased, <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetBelow_" data-uid="Efl.Canvas.Object.GetBelow*"></a>
  <h4 id="Efl_Canvas_Object_GetBelow" data-uid="Efl.Canvas.Object.GetBelow">GetBelow()</h4>
  <div class="markdown level1 summary"><p>Get the Evas object stacked right below <code>obj</code>
This function will traverse layers in its search, if there are objects on layers below the one <code>obj</code> is placed at.</p>
<p>See also <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_GetLayer">Efl.Gfx.IStack.GetLayer()</a>, <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_SetLayer_System_Int16_">Efl.Gfx.IStack.SetLayer(System.Int16)</a> and <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_GetBelow">Efl.Gfx.IStack.GetBelow()</a>
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual IStack GetBelow()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IStack.html">Efl.Gfx.IStack</a></td>
        <td><p>The <a class="xref" href="Efl.Gfx.IStack.html">Efl.Gfx.IStack</a> object directly below <code>obj</code>, if any, or <code>null</code>, if none.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetClippedObjects_" data-uid="Efl.Canvas.Object.GetClippedObjects*"></a>
  <h4 id="Efl_Canvas_Object_GetClippedObjects" data-uid="Efl.Canvas.Object.GetClippedObjects">GetClippedObjects()</h4>
  <div class="markdown level1 summary"><p>Return a list of objects currently clipped by <code>obj</code>.
This returns the internal list handle containing all objects clipped by the object <code>obj</code>. If none are clipped by it, the call returns <code>null</code>. This list is only valid until the clip list is changed and should be fetched again with another call to this function if any objects being clipped by this object are unclipped, clipped by a new object, deleted or get the clipper deleted. These operations will invalidate the list returned, so it should not be used anymore after that point. Any use of the list after this may have undefined results, possibly leading to crashes.</p>
<p>See also <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_Clipper">Efl.Canvas.Object.Clipper</a>.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Iterator&lt;Object&gt; GetClippedObjects()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">Eina.Iterator&lt;Efl.Canvas.Object&gt;</span></td>
        <td><p>An iterator over the list of objects clipped by <code>obj</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetClipper_" data-uid="Efl.Canvas.Object.GetClipper*"></a>
  <h4 id="Efl_Canvas_Object_GetClipper" data-uid="Efl.Canvas.Object.GetClipper">GetClipper()</h4>
  <div class="markdown level1 summary"><p>Get the object clipping <code>obj</code> (if any).
This function returns the object clipping <code>obj</code>. If <code>obj</code> is not being clipped at all, <code>null</code> is returned. The object <code>obj</code> must be a valid Evas_Object.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Object GetClipper()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Canvas.Object.html">Efl.Canvas.Object</a></td>
        <td><p>The object to clip <code>obj</code> by.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetColor_" data-uid="Efl.Canvas.Object.GetColor*"></a>
  <h4 id="Efl_Canvas_Object_GetColor_System_Int32__System_Int32__System_Int32__System_Int32__" data-uid="Efl.Canvas.Object.GetColor(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">GetColor(out Int32, out Int32, out Int32, out Int32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the general/main color of the given Evas object.
Retrieves the main color's RGB component (and alpha channel) values, which range from 0 to 255. For the alpha channel, which defines the object's transparency level, 0 means totally transparent, while 255 means opaque. These color values are premultiplied by the alpha value.</p>
<p>Usually youll use this attribute for text and rectangle objects, where the main color is their unique one. If set for objects which themselves have colors, like the images one, those colors get modulated by this one.</p>
<p>All newly created Evas rectangles get the default color values of 255 255 255 255 (opaque white).</p>
<p>Use null pointers on the components you're not interested in: they'll be ignored by the function.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetColor(out int r, out int g, out int b, out int a)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">r</span></td>
        <td></td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">g</span></td>
        <td></td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">b</span></td>
        <td></td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">a</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetColorCode_" data-uid="Efl.Canvas.Object.GetColorCode*"></a>
  <h4 id="Efl_Canvas_Object_GetColorCode" data-uid="Efl.Canvas.Object.GetColorCode">GetColorCode()</h4>
  <div class="markdown level1 summary"><p>Get hex color code of given Evas object. This returns a short lived hex color code string.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual string GetColorCode()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><p>the hex color code.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetCoordsInside_" data-uid="Efl.Canvas.Object.GetCoordsInside*"></a>
  <h4 id="Efl_Canvas_Object_GetCoordsInside_Eina_Position2D_" data-uid="Efl.Canvas.Object.GetCoordsInside(Eina.Position2D)">GetCoordsInside(Position2D)</h4>
  <div class="markdown level1 summary"><p>Returns whether the coords are logically inside the object.
When this function is called it will return a value of either <code>false</code> or <code>true</code>, depending on if the coords are inside the object's current geometry.</p>
<p>A return value of <code>true</code> indicates the position is logically inside the object, and <code>false</code> implies it is logically outside the object.</p>
<p>If <code>e</code> is not a valid object, the return value is undefined.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetCoordsInside(Position2D pos)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Position2D.html">Eina.Position2D</a></td>
        <td><span class="parametername">pos</span></td>
        <td><p>The position in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if the coords are inside the object, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetGeometry_" data-uid="Efl.Canvas.Object.GetGeometry*"></a>
  <h4 id="Efl_Canvas_Object_GetGeometry" data-uid="Efl.Canvas.Object.GetGeometry">GetGeometry()</h4>
  <div class="markdown level1 summary"><p>Rectangular geometry that combines both position and size.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Rect GetGeometry()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><p>The X,Y position and W,H size, in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetGestureManager_" data-uid="Efl.Canvas.Object.GetGestureManager*"></a>
  <h4 id="Efl_Canvas_Object_GetGestureManager" data-uid="Efl.Canvas.Object.GetGestureManager">GetGestureManager()</h4>
  <div class="markdown level1 summary"><p>Returns current canvas's gesture manager
(Since EFL 1.22)</p>
<p><strong>This is a BETA method</strong>. It can be modified or removed in the future. Do not use it for product development.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual GestureManager GetGestureManager()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Canvas.GestureManager.html">Efl.Canvas.GestureManager</a></td>
        <td><p>The gesture manager</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetHintAlign_" data-uid="Efl.Canvas.Object.GetHintAlign*"></a>
  <h4 id="Efl_Canvas_Object_GetHintAlign_System_Double__System_Double__" data-uid="Efl.Canvas.Object.GetHintAlign(System.Double@,System.Double@)">GetHintAlign(out Double, out Double)</h4>
  <div class="markdown level1 summary"><p>Hints for an object's alignment.
These are hints on how to align an object inside the boundaries of a container/manager. Accepted values are in the 0.0 to 1.0 range.</p>
<p>For the horizontal component, 0.0 means to the left, 1.0 means to the right. Analogously, for the vertical component, 0.0 to the top, 1.0 means to the bottom.</p>
<p>This is not a size enforcement in any way, it's just a hint that should be used whenever appropriate.</p>
<p>Note: Default alignment hint values are 0.5, for both axes.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetHintAlign(out double x, out double y)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">x</span></td>
        <td><p>Double, ranging from 0.0 to 1.0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">y</span></td>
        <td><p>Double, ranging from 0.0 to 1.0.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetHintAspect_" data-uid="Efl.Canvas.Object.GetHintAspect*"></a>
  <h4 id="Efl_Canvas_Object_GetHintAspect_Efl_Gfx_HintAspect__Eina_Size2D__" data-uid="Efl.Canvas.Object.GetHintAspect(Efl.Gfx.HintAspect@,Eina.Size2D@)">GetHintAspect(out HintAspect, out Size2D)</h4>
  <div class="markdown level1 summary"><p>Defines the aspect ratio to respect when scaling this object.
The aspect ratio is defined as the width / height ratio of the object. Depending on the object and its container, this hint may or may not be fully respected.</p>
<p>If any of the given aspect ratio terms are 0, the object's container will ignore the aspect and scale this object to occupy the whole available area, for any given policy.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetHintAspect(out HintAspect mode, out Size2D sz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.HintAspect.html">Efl.Gfx.HintAspect</a></td>
        <td><span class="parametername">mode</span></td>
        <td><p>Mode of interpretation.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><span class="parametername">sz</span></td>
        <td><p>Base size to use for aspecting.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetHintFill_" data-uid="Efl.Canvas.Object.GetHintFill*"></a>
  <h4 id="Efl_Canvas_Object_GetHintFill_System_Boolean__System_Boolean__" data-uid="Efl.Canvas.Object.GetHintFill(System.Boolean@,System.Boolean@)">GetHintFill(out Boolean, out Boolean)</h4>
  <div class="markdown level1 summary"><p>Hints for an object's fill property that used to specify &quot;justify&quot; or &quot;fill&quot; by some users. <a class="xref" href="Efl.Gfx.IHint.html#Efl_Gfx_IHint_GetHintFill_System_Boolean__System_Boolean__">Efl.Gfx.IHint.GetHintFill(out System.Boolean, out System.Boolean)</a> specify whether to fill the space inside the boundaries of a container/manager.
Maximum hints should be enforced with higher priority, if they are set. Also, any <a class="xref" href="Efl.Gfx.IHint.html#Efl_Gfx_IHint_GetHintMargin_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IHint.GetHintMargin(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a> set on objects should add up to the object space on the final scene composition.</p>
<p>See documentation of possible users: in Evas, they are the <a class="xref" href="Efl.Ui.Box.html">Efl.Ui.Box</a> &quot;box&quot; and <a class="xref" href="Efl.Ui.Table.html">Efl.Ui.Table</a> &quot;table&quot; smart objects.</p>
<p>This is not a size enforcement in any way, it's just a hint that should be used whenever appropriate.</p>
<p>Note: Default fill hint values are true, for both axes.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetHintFill(out bool x, out bool y)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">x</span></td>
        <td><p><code>true</code> if to fill the object space, <code>false</code> otherwise, to use as horizontal fill hint.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">y</span></td>
        <td><p><code>true</code> if to fill the object space, <code>false</code> otherwise, to use as vertical fill hint.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetHintMargin_" data-uid="Efl.Canvas.Object.GetHintMargin*"></a>
  <h4 id="Efl_Canvas_Object_GetHintMargin_System_Int32__System_Int32__System_Int32__System_Int32__" data-uid="Efl.Canvas.Object.GetHintMargin(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">GetHintMargin(out Int32, out Int32, out Int32, out Int32)</h4>
  <div class="markdown level1 summary"><p>Hints for an object's margin or padding space.
This is not a size enforcement in any way, it's just a hint that should be used whenever appropriate.</p>
<p>The object container is in charge of fetching this property and placing the object accordingly.</p>
<p>Note: Smart objects (such as elementary) can have their own hint policy. So calling this API may or may not affect the size of smart objects.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetHintMargin(out int l, out int r, out int t, out int b)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">l</span></td>
        <td><p>Integer to specify left padding.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">r</span></td>
        <td><p>Integer to specify right padding.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">t</span></td>
        <td><p>Integer to specify top padding.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">b</span></td>
        <td><p>Integer to specify bottom padding.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetHintSizeCombinedMin_" data-uid="Efl.Canvas.Object.GetHintSizeCombinedMin*"></a>
  <h4 id="Efl_Canvas_Object_GetHintSizeCombinedMin" data-uid="Efl.Canvas.Object.GetHintSizeCombinedMin">GetHintSizeCombinedMin()</h4>
  <div class="markdown level1 summary"><p>Read-only minimum size combining both <a class="xref" href="Efl.Gfx.IHint.html#Efl_Gfx_IHint_HintSizeRestrictedMin">Efl.Gfx.IHint.HintSizeRestrictedMin</a> and <a class="xref" href="Efl.Gfx.IHint.html#Efl_Gfx_IHint_HintSizeMin">Efl.Gfx.IHint.HintSizeMin</a> hints.
<a class="xref" href="Efl.Gfx.IHint.html#Efl_Gfx_IHint_HintSizeRestrictedMin">Efl.Gfx.IHint.HintSizeRestrictedMin</a> is intended for mostly internal usage and widget developers, and <a class="xref" href="Efl.Gfx.IHint.html#Efl_Gfx_IHint_HintSizeMin">Efl.Gfx.IHint.HintSizeMin</a> is intended to be set from application side. <a class="xref" href="Efl.Gfx.IHint.html#Efl_Gfx_IHint_GetHintSizeCombinedMin">Efl.Gfx.IHint.GetHintSizeCombinedMin()</a> combines both values by taking their repective maximum (in both width and height), and is used internally to get an object's minimum size.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Size2D GetHintSizeCombinedMin()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>Minimum size (hint) in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetHintSizeMax_" data-uid="Efl.Canvas.Object.GetHintSizeMax*"></a>
  <h4 id="Efl_Canvas_Object_GetHintSizeMax" data-uid="Efl.Canvas.Object.GetHintSizeMax">GetHintSizeMax()</h4>
  <div class="markdown level1 summary"><p>Hints on the object's maximum size.
This is not a size enforcement in any way, it's just a hint that should be used whenever appropriate.</p>
<p>The object container is in charge of fetching this property and placing the object accordingly.</p>
<p>Values -1 will be treated as unset hint components, when queried by managers.</p>
<p>Note: Smart objects (such as elementary) can have their own hint policy. So calling this API may or may not affect the size of smart objects.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Size2D GetHintSizeMax()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>Maximum size (hint) in pixels, (-1, -1) by default for canvas objects).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetHintSizeMin_" data-uid="Efl.Canvas.Object.GetHintSizeMin*"></a>
  <h4 id="Efl_Canvas_Object_GetHintSizeMin" data-uid="Efl.Canvas.Object.GetHintSizeMin">GetHintSizeMin()</h4>
  <div class="markdown level1 summary"><p>Hints on the object's minimum size.
This is not a size enforcement in any way, it's just a hint that should be used whenever appropriate. The object container is in charge of fetching this property and placing the object accordingly.</p>
<p>Value 0 will be treated as unset hint components, when queried by managers.</p>
<p>Note: This property is meant to be set by applications and not by EFL itself. Use this to request a specific size (treated as minimum size).
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Size2D GetHintSizeMin()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>Minimum size (hint) in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetHintSizeRestrictedMin_" data-uid="Efl.Canvas.Object.GetHintSizeRestrictedMin*"></a>
  <h4 id="Efl_Canvas_Object_GetHintSizeRestrictedMin" data-uid="Efl.Canvas.Object.GetHintSizeRestrictedMin">GetHintSizeRestrictedMin()</h4>
  <div class="markdown level1 summary"><p>Get the &quot;intrinsic&quot; minimum size of this object.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Size2D GetHintSizeRestrictedMin()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>Minimum size (hint) in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetHintWeight_" data-uid="Efl.Canvas.Object.GetHintWeight*"></a>
  <h4 id="Efl_Canvas_Object_GetHintWeight_System_Double__System_Double__" data-uid="Efl.Canvas.Object.GetHintWeight(System.Double@,System.Double@)">GetHintWeight(out Double, out Double)</h4>
  <div class="markdown level1 summary"><p>Hints for an object's weight.
This is a hint on how a container object should resize a given child within its area. Containers may adhere to the simpler logic of just expanding the child object's dimensions to fit its own (see the <a class="xref" href="Efl.Gfx.Constants.html#Efl_Gfx_Constants_HintExpand">Efl.Gfx.Constants.HintExpand</a> helper weight macro) or the complete one of taking each child's weight hint as real weights to how much of its size to allocate for them in each axis. A container is supposed to, after normalizing the weights of its children (with weight  hints), distribut the space it has to layout them by those factors -- most weighted children get larger in this process than the least ones.</p>
<p>Accepted values are zero or positive values. Some containers might use this hint as a boolean, but some others might consider it as a proportion, see documentation of each container.</p>
<p>Note: Default weight hint values are 0.0, for both axis.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetHintWeight(out double x, out double y)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">x</span></td>
        <td><p>Non-negative double value to use as horizontal weight hint.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">y</span></td>
        <td><p>Non-negative double value to use as vertical weight hint.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetKeyFocus_" data-uid="Efl.Canvas.Object.GetKeyFocus*"></a>
  <h4 id="Efl_Canvas_Object_GetKeyFocus" data-uid="Efl.Canvas.Object.GetKeyFocus">GetKeyFocus()</h4>
  <div class="markdown level1 summary"><p>Indicates that this object is the keyboard event receiver on its canvas.
Changing focus only affects where (key) input events go. There can be only one object focused at any time. If <code>focus</code> is <code>true</code>, <code>obj</code> will be set as the currently focused object and it will receive all keyboard events that are not exclusive key grabs on other objects. See also <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_CheckSeatFocus_Efl_Input_Device_">Efl.Canvas.Object.CheckSeatFocus(Efl.Input.Device)</a>, <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_AddSeatFocus_Efl_Input_Device_">Efl.Canvas.Object.AddSeatFocus(Efl.Input.Device)</a>, <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_DelSeatFocus_Efl_Input_Device_">Efl.Canvas.Object.DelSeatFocus(Efl.Input.Device)</a>.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetKeyFocus()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> when set as focused or <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetLanguage_" data-uid="Efl.Canvas.Object.GetLanguage*"></a>
  <h4 id="Efl_Canvas_Object_GetLanguage" data-uid="Efl.Canvas.Object.GetLanguage">GetLanguage()</h4>
  <div class="markdown level1 summary"><p>Gets the language for this object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual string GetLanguage()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><p>The current language.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetLayer_" data-uid="Efl.Canvas.Object.GetLayer*"></a>
  <h4 id="Efl_Canvas_Object_GetLayer" data-uid="Efl.Canvas.Object.GetLayer">GetLayer()</h4>
  <div class="markdown level1 summary"><p>Retrieves the layer of its canvas that the given object is part of.
See also <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_SetLayer_System_Int16_">Efl.Gfx.IStack.SetLayer(System.Int16)</a>
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual short GetLayer()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int16</span></td>
        <td><p>The number of the layer to place the object on. Must be between <a class="xref" href="Efl.Gfx.Constants.html#Efl_Gfx_Constants_StackLayerMin">Efl.Gfx.Constants.StackLayerMin</a> and <a class="xref" href="Efl.Gfx.Constants.html#Efl_Gfx_Constants_StackLayerMax">Efl.Gfx.Constants.StackLayerMax</a>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetMappingAlpha_" data-uid="Efl.Canvas.Object.GetMappingAlpha*"></a>
  <h4 id="Efl_Canvas_Object_GetMappingAlpha" data-uid="Efl.Canvas.Object.GetMappingAlpha">GetMappingAlpha()</h4>
  <div class="markdown level1 summary"><p>Alpha flag for map rendering.
This sets alpha flag for map rendering. If the object is a type that has its own alpha settings, then this will take precedence. Only image objects support this currently (<a class="xref" href="Efl.Canvas.Image.html">Efl.Canvas.Image</a> and its friends). Setting this to off stops alpha blending of the map area, and is useful if you know the object and/or all sub-objects is 100% solid.</p>
<p>Note that this may conflict with <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_MappingSmooth">Efl.Gfx.IMapping.MappingSmooth</a> depending on which algorithm is used for anti-aliasing.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetMappingAlpha()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> by default.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetMappingClockwise_" data-uid="Efl.Canvas.Object.GetMappingClockwise*"></a>
  <h4 id="Efl_Canvas_Object_GetMappingClockwise" data-uid="Efl.Canvas.Object.GetMappingClockwise">GetMappingClockwise()</h4>
  <div class="markdown level1 summary"><p>Clockwise state of a map (read-only).
This determines if the output points (X and Y. Z is not used) are clockwise or counter-clockwise. This can be used for &quot;back-face culling&quot;. This is where you hide objects that &quot;face away&quot; from you. In this case objects that are not clockwise.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetMappingClockwise()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if clockwise, <code>false</code> if counter clockwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetMappingColor_" data-uid="Efl.Canvas.Object.GetMappingColor*"></a>
  <h4 id="Efl_Canvas_Object_GetMappingColor_System_Int32_System_Int32__System_Int32__System_Int32__System_Int32__" data-uid="Efl.Canvas.Object.GetMappingColor(System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">GetMappingColor(Int32, out Int32, out Int32, out Int32, out Int32)</h4>
  <div class="markdown level1 summary"><p>Color of a vertex in the map.
This sets the color of the vertex in the map. Colors will be linearly interpolated between vertex points through the map. Color will multiply the &quot;texture&quot; pixels (like GL_MODULATE in OpenGL). The default color of a vertex in a map is white solid (255, 255, 255, 255) which means it will have no affect on modifying the texture pixels.</p>
<p>The color values must be premultiplied (ie. <code>a</code> &gt;= {<code>r</code>, <code>g</code>, <code>b</code>}).
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetMappingColor(int idx, out int r, out int g, out int b, out int a)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">idx</span></td>
        <td><p>ID of the point, from 0 to 3 (included). -1 can be used to set the color for all points, but it is invalid for get().</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">r</span></td>
        <td><p>Red (0 - 255)</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">g</span></td>
        <td><p>Green (0 - 255)</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">b</span></td>
        <td><p>Blue (0 - 255)</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">a</span></td>
        <td><p>Alpha (0 - 255)</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetMappingCoordAbsolute_" data-uid="Efl.Canvas.Object.GetMappingCoordAbsolute*"></a>
  <h4 id="Efl_Canvas_Object_GetMappingCoordAbsolute_System_Int32_System_Double__System_Double__System_Double__" data-uid="Efl.Canvas.Object.GetMappingCoordAbsolute(System.Int32,System.Double@,System.Double@,System.Double@)">GetMappingCoordAbsolute(Int32, out Double, out Double, out Double)</h4>
  <div class="markdown level1 summary"><p>A point's absolute coordinate on the canvas.
This sets/gets the fixed point's coordinate in the map. Note that points describe the outline of a quadrangle and are ordered either clockwise or counter-clockwise. Try to keep your quadrangles concave and non-complex. Though these polygon modes may work, they may not render a desired set of output. The quadrangle will use points 0 and 1 , 1 and 2, 2 and 3, and 3 and 0 to describe the edges of the quadrangle.</p>
<p>The X and Y and Z coordinates are in canvas units. Z is optional and may or may not be honored in drawing. Z is a hint and does not affect the X and Y rendered coordinates. It may be used for calculating fills with perspective correct rendering.</p>
<p>Remember all coordinates are canvas global ones as with move and resize in the canvas.</p>
<p>This property can be read to get the 4 points positions on the canvas, or set to manually place them.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetMappingCoordAbsolute(int idx, out double x, out double y, out double z)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">idx</span></td>
        <td><p>ID of the point, from 0 to 3 (included).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">x</span></td>
        <td><p>Point X coordinate in absolute pixel coordinates.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">y</span></td>
        <td><p>Point Y coordinate in absolute pixel coordinates.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">z</span></td>
        <td><p>Point Z coordinate hint (pre-perspective transform).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetMappingPointCount_" data-uid="Efl.Canvas.Object.GetMappingPointCount*"></a>
  <h4 id="Efl_Canvas_Object_GetMappingPointCount" data-uid="Efl.Canvas.Object.GetMappingPointCount">GetMappingPointCount()</h4>
  <div class="markdown level1 summary"><p>Number of points of a map.
This sets the number of points of map. Currently, the number of points must be multiples of 4.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual int GetMappingPointCount()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of points of map</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetMappingSmooth_" data-uid="Efl.Canvas.Object.GetMappingSmooth*"></a>
  <h4 id="Efl_Canvas_Object_GetMappingSmooth" data-uid="Efl.Canvas.Object.GetMappingSmooth">GetMappingSmooth()</h4>
  <div class="markdown level1 summary"><p>Smoothing state for map rendering.
This sets smoothing for map rendering. If the object is a type that has its own smoothing settings, then both the smooth settings for this object and the map must be turned off. By default smooth maps are enabled.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetMappingSmooth()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> by default.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetMappingUv_" data-uid="Efl.Canvas.Object.GetMappingUv*"></a>
  <h4 id="Efl_Canvas_Object_GetMappingUv_System_Int32_System_Double__System_Double__" data-uid="Efl.Canvas.Object.GetMappingUv(System.Int32,System.Double@,System.Double@)">GetMappingUv(Int32, out Double, out Double)</h4>
  <div class="markdown level1 summary"><p>Map point's U and V texture source point.
This sets/gets the U and V coordinates for the point. This determines which coordinate in the source image is mapped to the given point, much like OpenGL and textures. Valid values range from 0.0 to 1.0.</p>
<p>By default the points are set in a clockwise order, as such: - 0: top-left, i.e. (0.0, 0.0), - 1: top-right, i.e. (1.0, 0.0), - 2: bottom-right, i.e. (1.0, 1.0), - 3: bottom-left, i.e. (0.0, 1.0).
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetMappingUv(int idx, out double u, out double v)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">idx</span></td>
        <td><p>ID of the point, from 0 to 3 (included).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">u</span></td>
        <td><p>Relative X coordinate within the image, from 0 to 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">v</span></td>
        <td><p>Relative Y coordinate within the image, from 0 to 1.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetMirrored_" data-uid="Efl.Canvas.Object.GetMirrored*"></a>
  <h4 id="Efl_Canvas_Object_GetMirrored" data-uid="Efl.Canvas.Object.GetMirrored">GetMirrored()</h4>
  <div class="markdown level1 summary"><p>Whether this object should be mirrored.
If mirrored, an object is in RTL (right to left) mode instead of LTR (left to right).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetMirrored()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> for RTL, <code>false</code> for LTR (default).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetMirroredAutomatic_" data-uid="Efl.Canvas.Object.GetMirroredAutomatic*"></a>
  <h4 id="Efl_Canvas_Object_GetMirroredAutomatic" data-uid="Efl.Canvas.Object.GetMirroredAutomatic">GetMirroredAutomatic()</h4>
  <div class="markdown level1 summary"><p>Whether the property <a class="xref" href="Efl.Ui.II18n.html#Efl_Ui_II18n_Mirrored">Efl.Ui.II18n.Mirrored</a> should be set automatically.
If enabled, the system or application configuration will be used to set the value of <a class="xref" href="Efl.Ui.II18n.html#Efl_Ui_II18n_Mirrored">Efl.Ui.II18n.Mirrored</a>.</p>
<p>This property may be implemented by high-level widgets (in Efl.Ui) but not by low-level widgets (in <a class="xref" href="Efl.Canvas.IScene.html">Efl.Canvas.IScene</a>) as the configuration should affect only high-level widgets.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetMirroredAutomatic()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether the widget uses automatic mirroring</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetNoRender_" data-uid="Efl.Canvas.Object.GetNoRender*"></a>
  <h4 id="Efl_Canvas_Object_GetNoRender" data-uid="Efl.Canvas.Object.GetNoRender">GetNoRender()</h4>
  <div class="markdown level1 summary"><p>Returns the state of the &quot;no-render&quot; flag, which means, when true, that an object should never be rendered on the canvas.
This flag can be used to avoid rendering visible clippers on the canvas, even if they currently don't clip any object.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetNoRender()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Enable &quot;no-render&quot; mode.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetParagraphDirection_" data-uid="Efl.Canvas.Object.GetParagraphDirection*"></a>
  <h4 id="Efl_Canvas_Object_GetParagraphDirection" data-uid="Efl.Canvas.Object.GetParagraphDirection">GetParagraphDirection()</h4>
  <div class="markdown level1 summary"><p>This handles text paragraph direction of the given object. Even if the given object is not textblock or text, its smart child objects can inherit the paragraph direction from the given object. The default paragraph direction is <code>inherit</code>.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual TextBidirectionalType GetParagraphDirection()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.TextBidirectionalType.html">Efl.TextBidirectionalType</a></td>
        <td><p>Paragraph direction for the given object.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetPassEvents_" data-uid="Efl.Canvas.Object.GetPassEvents*"></a>
  <h4 id="Efl_Canvas_Object_GetPassEvents" data-uid="Efl.Canvas.Object.GetPassEvents">GetPassEvents()</h4>
  <div class="markdown level1 summary"><p>Determine whether an object is set to pass (ignore) events.
See also <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetRepeatEvents">Efl.Canvas.Object.GetRepeatEvents()</a>, <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetPropagateEvents">Efl.Canvas.Object.GetPropagateEvents()</a>.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetPassEvents()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether <code>obj</code> is to pass events (<code>true</code>) or not (<code>false</code>).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetPointerInside_" data-uid="Efl.Canvas.Object.GetPointerInside*"></a>
  <h4 id="Efl_Canvas_Object_GetPointerInside_Efl_Input_Device_" data-uid="Efl.Canvas.Object.GetPointerInside(Efl.Input.Device)">GetPointerInside(Device)</h4>
  <div class="markdown level1 summary"><p>Returns whether the mouse pointer is logically inside the canvas.
When this function is called it will return a value of either <code>false</code> or <code>true</code>, depending on whether a pointer,in or pointer,out event has been called previously.</p>
<p>A return value of <code>true</code> indicates the mouse is logically inside the canvas, and <code>false</code> implies it is logically outside the canvas.</p>
<p>A canvas begins with the mouse being assumed outside (<code>false</code>).
(Since EFL 1.22)</p>
<p><strong>This is a BETA method</strong>. It can be modified or removed in the future. Do not use it for product development.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetPointerInside(Device seat)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.Device.html">Efl.Input.Device</a></td>
        <td><span class="parametername">seat</span></td>
        <td><p>The seat to consider, if <code>null</code> then the default seat will be used.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if the mouse pointer is inside the canvas, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetPointerMode_" data-uid="Efl.Canvas.Object.GetPointerMode*"></a>
  <h4 id="Efl_Canvas_Object_GetPointerMode" data-uid="Efl.Canvas.Object.GetPointerMode">GetPointerMode()</h4>
  <div class="markdown level1 summary"><p>Low-level pointer behaviour.
This function has a direct effect on event callbacks related to pointers (mouse, ...).</p>
<p>If the value is <a class="xref" href="Efl.Input.ObjectPointerMode.html#Efl_Input_ObjectPointerMode_AutoGrab">Efl.Input.ObjectPointerMode.AutoGrab</a> (default), then when mouse is pressed down over this object, events will be restricted to it as source, mouse moves, for example, will be emitted even when the pointer goes outside this objects geometry.</p>
<p>If the value is <a class="xref" href="Efl.Input.ObjectPointerMode.html#Efl_Input_ObjectPointerMode_NoGrab">Efl.Input.ObjectPointerMode.NoGrab</a>, then events will be emitted just when inside this object area.</p>
<p>The default value is <a class="xref" href="Efl.Input.ObjectPointerMode.html#Efl_Input_ObjectPointerMode_AutoGrab">Efl.Input.ObjectPointerMode.AutoGrab</a>. See also: <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetPointerModeByDevice_Efl_Input_Device_">Efl.Canvas.Object.GetPointerModeByDevice(Efl.Input.Device)</a> and <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetPointerModeByDevice_Efl_Input_Device_">Efl.Canvas.Object.GetPointerModeByDevice(Efl.Input.Device)</a> Note: This function will only set/get the mode for the default pointer.
(Since EFL 1.22)</p>
<p><strong>This is a BETA method</strong>. It can be modified or removed in the future. Do not use it for product development.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual ObjectPointerMode GetPointerMode()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.ObjectPointerMode.html">Efl.Input.ObjectPointerMode</a></td>
        <td><p>Input pointer mode</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetPointerModeByDevice_" data-uid="Efl.Canvas.Object.GetPointerModeByDevice*"></a>
  <h4 id="Efl_Canvas_Object_GetPointerModeByDevice_Efl_Input_Device_" data-uid="Efl.Canvas.Object.GetPointerModeByDevice(Efl.Input.Device)">GetPointerModeByDevice(Device)</h4>
  <div class="markdown level1 summary"><p>Low-level pointer behaviour by device. See <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetPointerMode">Efl.Canvas.Object.GetPointerMode()</a> and <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_SetPointerMode_Efl_Input_ObjectPointerMode_">Efl.Canvas.Object.SetPointerMode(Efl.Input.ObjectPointerMode)</a> for more explanation.
(Since EFL 1.22)</p>
<p><strong>This is a BETA method</strong>. It can be modified or removed in the future. Do not use it for product development.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual ObjectPointerMode GetPointerModeByDevice(Device dev)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.Device.html">Efl.Input.Device</a></td>
        <td><span class="parametername">dev</span></td>
        <td><p>The pointer device to set/get the mode. Use <code>null</code> for the default pointer.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.ObjectPointerMode.html">Efl.Input.ObjectPointerMode</a></td>
        <td><p>The pointer mode</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetPosition_" data-uid="Efl.Canvas.Object.GetPosition*"></a>
  <h4 id="Efl_Canvas_Object_GetPosition" data-uid="Efl.Canvas.Object.GetPosition">GetPosition()</h4>
  <div class="markdown level1 summary"><p>Retrieves the position of the given canvas object.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Position2D GetPosition()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Position2D.html">Eina.Position2D</a></td>
        <td><p>A 2D coordinate in pixel units.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetPreciseIsInside_" data-uid="Efl.Canvas.Object.GetPreciseIsInside*"></a>
  <h4 id="Efl_Canvas_Object_GetPreciseIsInside" data-uid="Efl.Canvas.Object.GetPreciseIsInside">GetPreciseIsInside()</h4>
  <div class="markdown level1 summary"><p>Determine whether an object is set to use precise point collision detection.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetPreciseIsInside()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether to use precise point collision detection or not. The default value is false.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetPropagateEvents_" data-uid="Efl.Canvas.Object.GetPropagateEvents*"></a>
  <h4 id="Efl_Canvas_Object_GetPropagateEvents" data-uid="Efl.Canvas.Object.GetPropagateEvents">GetPropagateEvents()</h4>
  <div class="markdown level1 summary"><p>Retrieve whether an Evas object is set to propagate events.
See also <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetRepeatEvents">Efl.Canvas.Object.GetRepeatEvents()</a>, <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetPassEvents">Efl.Canvas.Object.GetPassEvents()</a>.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetPropagateEvents()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether to propagate events (<code>true</code>) or not (<code>false</code>).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetRenderOp_" data-uid="Efl.Canvas.Object.GetRenderOp*"></a>
  <h4 id="Efl_Canvas_Object_GetRenderOp" data-uid="Efl.Canvas.Object.GetRenderOp">GetRenderOp()</h4>
  <div class="markdown level1 summary"><p>Render mode to be used for compositing the Evas object.
Only two modes are supported: - <a class="xref" href="Efl.Gfx.RenderOp.html#Efl_Gfx_RenderOp_Blend">Efl.Gfx.RenderOp.Blend</a> means the object will be merged on top of objects below it using simple alpha compositing. - <a class="xref" href="Efl.Gfx.RenderOp.html#Efl_Gfx_RenderOp_Copy">Efl.Gfx.RenderOp.Copy</a> means this object's pixels will replace everything that is below, making this object opaque.</p>
<p>Please do not assume that <a class="xref" href="Efl.Gfx.RenderOp.html#Efl_Gfx_RenderOp_Copy">Efl.Gfx.RenderOp.Copy</a> mode can be used to &quot;poke&quot; holes in a window (to see through it), as only the compositor can ensure that. Copy mode should only be used with otherwise opaque widgets or inside non-window surfaces (eg. a transparent background inside a buffer canvas).
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual RenderOp GetRenderOp()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.RenderOp.html">Efl.Gfx.RenderOp</a></td>
        <td><p>Blend or copy.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetRenderParent_" data-uid="Efl.Canvas.Object.GetRenderParent*"></a>
  <h4 id="Efl_Canvas_Object_GetRenderParent" data-uid="Efl.Canvas.Object.GetRenderParent">GetRenderParent()</h4>
  <div class="markdown level1 summary"><p>Gets the parent smart object of a given Evas object, if it has one.
This can be different from <a class="xref" href="Efl.Object.html#Efl_Object_Parent">Efl.Object.Parent</a> because this one is used internally for rendering and the normal parent is what the user expects to be the parent.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected virtual Object GetRenderParent()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Canvas.Object.html">Efl.Canvas.Object</a></td>
        <td><p>The parent smart object of <code>obj</code> or <code>null</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetRepeatEvents_" data-uid="Efl.Canvas.Object.GetRepeatEvents*"></a>
  <h4 id="Efl_Canvas_Object_GetRepeatEvents" data-uid="Efl.Canvas.Object.GetRepeatEvents">GetRepeatEvents()</h4>
  <div class="markdown level1 summary"><p>Determine whether an object is set to repeat events.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetRepeatEvents()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether <code>obj</code> is to repeat events (<code>true</code>) or not (<code>false</code>).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetScale_" data-uid="Efl.Canvas.Object.GetScale*"></a>
  <h4 id="Efl_Canvas_Object_GetScale" data-uid="Efl.Canvas.Object.GetScale">GetScale()</h4>
  <div class="markdown level1 summary"><p>Gets an object's scaling factor.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual double GetScale()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><p>The scaling factor (the default value is 0.0, meaning individual scaling is not set)</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetSeatEventFilter_" data-uid="Efl.Canvas.Object.GetSeatEventFilter*"></a>
  <h4 id="Efl_Canvas_Object_GetSeatEventFilter_Efl_Input_Device_" data-uid="Efl.Canvas.Object.GetSeatEventFilter(Efl.Input.Device)">GetSeatEventFilter(Device)</h4>
  <div class="markdown level1 summary"><p>Check if input events from a given seat is enabled.</p>
<p><strong>This is a BETA method</strong>. It can be modified or removed in the future. Do not use it for product development.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetSeatEventFilter(Device seat)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.Device.html">Efl.Input.Device</a></td>
        <td><span class="parametername">seat</span></td>
        <td><p>The seat to act on.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> to enable events for a seat or <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetSeatFocus_" data-uid="Efl.Canvas.Object.GetSeatFocus*"></a>
  <h4 id="Efl_Canvas_Object_GetSeatFocus" data-uid="Efl.Canvas.Object.GetSeatFocus">GetSeatFocus()</h4>
  <div class="markdown level1 summary"><p>Check if this object is focused.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetSeatFocus()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if focused by at least one seat or <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetSize_" data-uid="Efl.Canvas.Object.GetSize*"></a>
  <h4 id="Efl_Canvas_Object_GetSize" data-uid="Efl.Canvas.Object.GetSize">GetSize()</h4>
  <div class="markdown level1 summary"><p>Retrieves the (rectangular) size of the given Evas object.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Size2D GetSize()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>A 2D size in pixel units.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GetVisible_" data-uid="Efl.Canvas.Object.GetVisible*"></a>
  <h4 id="Efl_Canvas_Object_GetVisible" data-uid="Efl.Canvas.Object.GetVisible">GetVisible()</h4>
  <div class="markdown level1 summary"><p>Retrieves whether or not the given canvas object is visible.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetVisible()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if to make the object visible, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_GrabKey_" data-uid="Efl.Canvas.Object.GrabKey*"></a>
  <h4 id="Efl_Canvas_Object_GrabKey_System_String_Efl_Input_Modifier_Efl_Input_Modifier_System_Boolean_" data-uid="Efl.Canvas.Object.GrabKey(System.String,Efl.Input.Modifier,Efl.Input.Modifier,System.Boolean)">GrabKey(String, Modifier, Modifier, Boolean)</h4>
  <div class="markdown level1 summary"><p>Requests <code>keyname</code> key events be directed to <code>obj</code>.
Key grabs allow one or more objects to receive key events for specific key strokes even if other objects have focus. Whenever a key is grabbed, only the objects grabbing it will get the events for the given keys.</p>
<p><code>keyname</code> is a platform dependent symbolic name for the key pressed.</p>
<p><code>modifiers</code> and <code>not_modifiers</code> are bit masks of all the modifiers that must and mustn't, respectively, be pressed along with <code>keyname</code> key in order to trigger this new key grab. Modifiers can be things such as Shift and Ctrl as well as user defined types via ref evas_key_modifier_add. <code>exclusive</code> will make the given object the only one permitted to grab the given key. If given <code>true</code>, subsequent calls on this function with different <code>obj</code> arguments will fail, unless the key is ungrabbed again.</p>
<p>Warning: Providing impossible modifier sets creates undefined behavior.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GrabKey(string keyname, Modifier modifiers, Modifier not_modifiers, bool exclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">keyname</span></td>
        <td><p>The key to request events for.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Input.Modifier.html">Efl.Input.Modifier</a></td>
        <td><span class="parametername">modifiers</span></td>
        <td><p>A combination of modifier keys that must be present to trigger the event.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Input.Modifier.html">Efl.Input.Modifier</a></td>
        <td><span class="parametername">not_modifiers</span></td>
        <td><p>A combination of modifier keys that must not be present to trigger the event.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">exclusive</span></td>
        <td><p>Request that the <code>obj</code> is the only object receiving the <code>keyname</code> events.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if the call succeeded, <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_HasMapping_" data-uid="Efl.Canvas.Object.HasMapping*"></a>
  <h4 id="Efl_Canvas_Object_HasMapping" data-uid="Efl.Canvas.Object.HasMapping">HasMapping()</h4>
  <div class="markdown level1 summary"><p>Read-only property indicating whether an object is mapped.
This will be <code>true</code> if any transformation is applied to this object.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool HasMapping()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if the object is mapped.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Lighting3d_" data-uid="Efl.Canvas.Object.Lighting3d*"></a>
  <h4 id="Efl_Canvas_Object_Lighting3d_Efl_Gfx_IEntity_System_Double_System_Double_System_Double_System_Int32_System_Int32_System_Int32_System_Int32_System_Int32_System_Int32_" data-uid="Efl.Canvas.Object.Lighting3d(Efl.Gfx.IEntity,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">Lighting3d(IEntity, Double, Double, Double, Int32, Int32, Int32, Int32, Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Apply a lighting effect on the object.
This is used to apply lighting calculations (from a single light source) to a given mapped object. The R, G and B values of each vertex will be modified to reflect the lighting based on the light point coordinates, the light color and the ambient color, and at what angle the map is facing the light source. A surface should have its points be declared in a clockwise fashion if the face is &quot;facing&quot; towards you (as opposed to away from you) as faces have a &quot;logical&quot; side for lighting.</p>
<p>The coordinates are set relative to the given <code>pivot</code> object. If its geometry changes, then the absolute position of the rotation center will change accordingly. The Z position is absolute. If the <code>pivot</code> is <code>null</code> then this object will be its own pivot.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void Lighting3d(IEntity pivot, double lx, double ly, double lz, int lr, int lg, int lb, int ar, int ag, int ab)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IEntity.html">Efl.Gfx.IEntity</a></td>
        <td><span class="parametername">pivot</span></td>
        <td><p>A pivot object for the light point, can be <code>null</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">lx</span></td>
        <td><p>X relative coordinate in space of light point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">ly</span></td>
        <td><p>Y relative coordinate in space of light point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">lz</span></td>
        <td><p>Z absolute coordinate in space of light point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Light red value (0 - 255).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">lg</span></td>
        <td><p>Light green value (0 - 255).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">lb</span></td>
        <td><p>Light blue value (0 - 255).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">ar</span></td>
        <td><p>Ambient color red value (0 - 255).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">ag</span></td>
        <td><p>Ambient color green value (0 - 255).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">ab</span></td>
        <td><p>Ambient color blue value (0 - 255).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Lighting3dAbsolute_" data-uid="Efl.Canvas.Object.Lighting3dAbsolute*"></a>
  <h4 id="Efl_Canvas_Object_Lighting3dAbsolute_System_Double_System_Double_System_Double_System_Int32_System_Int32_System_Int32_System_Int32_System_Int32_System_Int32_" data-uid="Efl.Canvas.Object.Lighting3dAbsolute(System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">Lighting3dAbsolute(Double, Double, Double, Int32, Int32, Int32, Int32, Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Apply a lighting effect to the object.
This is used to apply lighting calculations (from a single light source) to a given mapped object. The RGB values of each vertex will be modified to reflect the lighting based on the light point coordinates, the light color, the ambient color and at what angle the map is facing the light source. A surface should have its points be declared in a clockwise fashion if the face is &quot;facing&quot; towards you (as opposed to away from you) as faces have a &quot;logical&quot; side for lighting.</p>
<p>The coordinates of the center point are given in absolute canvas coordinates. See also <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_Lighting3d_Efl_Gfx_IEntity_System_Double_System_Double_System_Double_System_Int32_System_Int32_System_Int32_System_Int32_System_Int32_System_Int32_">Efl.Gfx.IMapping.Lighting3d(Efl.Gfx.IEntity, System.Double, System.Double, System.Double, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)</a> for a pivot-based lighting effect.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void Lighting3dAbsolute(double lx, double ly, double lz, int lr, int lg, int lb, int ar, int ag, int ab)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">lx</span></td>
        <td><p>X absolute coordinate in pixels of the light point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">ly</span></td>
        <td><p>y absolute coordinate in pixels of the light point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">lz</span></td>
        <td><p>Z absolute coordinate in space of light point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Light red value (0 - 255).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">lg</span></td>
        <td><p>Light green value (0 - 255).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">lb</span></td>
        <td><p>Light blue value (0 - 255).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">ar</span></td>
        <td><p>Ambient color red value (0 - 255).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">ag</span></td>
        <td><p>Ambient color green value (0 - 255).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">ab</span></td>
        <td><p>Ambient color blue value (0 - 255).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_LowerToBottom_" data-uid="Efl.Canvas.Object.LowerToBottom*"></a>
  <h4 id="Efl_Canvas_Object_LowerToBottom" data-uid="Efl.Canvas.Object.LowerToBottom">LowerToBottom()</h4>
  <div class="markdown level1 summary"><p>Lower <code>obj</code> to the bottom of its layer.
<code>obj</code> will, then, be the lowest one in the layer it belongs to. Objects on other layers won't get touched.</p>
<p>See also <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_StackAbove_Efl_Gfx_IStack_">Efl.Gfx.IStack.StackAbove(Efl.Gfx.IStack)</a>, <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_StackBelow_Efl_Gfx_IStack_">Efl.Gfx.IStack.StackBelow(Efl.Gfx.IStack)</a> and <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_RaiseToTop">Efl.Gfx.IStack.RaiseToTop()</a>
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void LowerToBottom()</code></pre>
  </div>
  
  
  <a id="Efl_Canvas_Object_OnAnimatorTickEvt_" data-uid="Efl.Canvas.Object.OnAnimatorTickEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnAnimatorTickEvt_Efl_Canvas_ObjectAnimatorTickEvt_Args_" data-uid="Efl.Canvas.Object.OnAnimatorTickEvt(Efl.Canvas.ObjectAnimatorTickEvt_Args)">OnAnimatorTickEvt(ObjectAnimatorTickEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event AnimatorTickEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnAnimatorTickEvt(ObjectAnimatorTickEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Canvas.ObjectAnimatorTickEvt_Args.html">Efl.Canvas.ObjectAnimatorTickEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnFingerDownEvt_" data-uid="Efl.Canvas.Object.OnFingerDownEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnFingerDownEvt_Efl_Input_IInterfaceFingerDownEvt_Args_" data-uid="Efl.Canvas.Object.OnFingerDownEvt(Efl.Input.IInterfaceFingerDownEvt_Args)">OnFingerDownEvt(IInterfaceFingerDownEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event FingerDownEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnFingerDownEvt(IInterfaceFingerDownEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfaceFingerDownEvt_Args.html">Efl.Input.IInterfaceFingerDownEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnFingerMoveEvt_" data-uid="Efl.Canvas.Object.OnFingerMoveEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnFingerMoveEvt_Efl_Input_IInterfaceFingerMoveEvt_Args_" data-uid="Efl.Canvas.Object.OnFingerMoveEvt(Efl.Input.IInterfaceFingerMoveEvt_Args)">OnFingerMoveEvt(IInterfaceFingerMoveEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event FingerMoveEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnFingerMoveEvt(IInterfaceFingerMoveEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfaceFingerMoveEvt_Args.html">Efl.Input.IInterfaceFingerMoveEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnFingerUpEvt_" data-uid="Efl.Canvas.Object.OnFingerUpEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnFingerUpEvt_Efl_Input_IInterfaceFingerUpEvt_Args_" data-uid="Efl.Canvas.Object.OnFingerUpEvt(Efl.Input.IInterfaceFingerUpEvt_Args)">OnFingerUpEvt(IInterfaceFingerUpEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event FingerUpEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnFingerUpEvt(IInterfaceFingerUpEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfaceFingerUpEvt_Args.html">Efl.Input.IInterfaceFingerUpEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnFocusInEvt_" data-uid="Efl.Canvas.Object.OnFocusInEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnFocusInEvt_Efl_Input_IInterfaceFocusInEvt_Args_" data-uid="Efl.Canvas.Object.OnFocusInEvt(Efl.Input.IInterfaceFocusInEvt_Args)">OnFocusInEvt(IInterfaceFocusInEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event FocusInEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnFocusInEvt(IInterfaceFocusInEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfaceFocusInEvt_Args.html">Efl.Input.IInterfaceFocusInEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnFocusOutEvt_" data-uid="Efl.Canvas.Object.OnFocusOutEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnFocusOutEvt_Efl_Input_IInterfaceFocusOutEvt_Args_" data-uid="Efl.Canvas.Object.OnFocusOutEvt(Efl.Input.IInterfaceFocusOutEvt_Args)">OnFocusOutEvt(IInterfaceFocusOutEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event FocusOutEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnFocusOutEvt(IInterfaceFocusOutEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfaceFocusOutEvt_Args.html">Efl.Input.IInterfaceFocusOutEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnGestureDoubleTapEvt_" data-uid="Efl.Canvas.Object.OnGestureDoubleTapEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnGestureDoubleTapEvt_Efl_Gesture_IEventsGestureDoubleTapEvt_Args_" data-uid="Efl.Canvas.Object.OnGestureDoubleTapEvt(Efl.Gesture.IEventsGestureDoubleTapEvt_Args)">OnGestureDoubleTapEvt(IEventsGestureDoubleTapEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event GestureDoubleTapEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnGestureDoubleTapEvt(IEventsGestureDoubleTapEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gesture.IEventsGestureDoubleTapEvt_Args.html">Efl.Gesture.IEventsGestureDoubleTapEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnGestureFlickEvt_" data-uid="Efl.Canvas.Object.OnGestureFlickEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnGestureFlickEvt_Efl_Gesture_IEventsGestureFlickEvt_Args_" data-uid="Efl.Canvas.Object.OnGestureFlickEvt(Efl.Gesture.IEventsGestureFlickEvt_Args)">OnGestureFlickEvt(IEventsGestureFlickEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event GestureFlickEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnGestureFlickEvt(IEventsGestureFlickEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gesture.IEventsGestureFlickEvt_Args.html">Efl.Gesture.IEventsGestureFlickEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnGestureLongTapEvt_" data-uid="Efl.Canvas.Object.OnGestureLongTapEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnGestureLongTapEvt_Efl_Gesture_IEventsGestureLongTapEvt_Args_" data-uid="Efl.Canvas.Object.OnGestureLongTapEvt(Efl.Gesture.IEventsGestureLongTapEvt_Args)">OnGestureLongTapEvt(IEventsGestureLongTapEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event GestureLongTapEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnGestureLongTapEvt(IEventsGestureLongTapEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gesture.IEventsGestureLongTapEvt_Args.html">Efl.Gesture.IEventsGestureLongTapEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnGestureMomentumEvt_" data-uid="Efl.Canvas.Object.OnGestureMomentumEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnGestureMomentumEvt_Efl_Gesture_IEventsGestureMomentumEvt_Args_" data-uid="Efl.Canvas.Object.OnGestureMomentumEvt(Efl.Gesture.IEventsGestureMomentumEvt_Args)">OnGestureMomentumEvt(IEventsGestureMomentumEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event GestureMomentumEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnGestureMomentumEvt(IEventsGestureMomentumEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gesture.IEventsGestureMomentumEvt_Args.html">Efl.Gesture.IEventsGestureMomentumEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnGestureTapEvt_" data-uid="Efl.Canvas.Object.OnGestureTapEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnGestureTapEvt_Efl_Gesture_IEventsGestureTapEvt_Args_" data-uid="Efl.Canvas.Object.OnGestureTapEvt(Efl.Gesture.IEventsGestureTapEvt_Args)">OnGestureTapEvt(IEventsGestureTapEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event GestureTapEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnGestureTapEvt(IEventsGestureTapEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gesture.IEventsGestureTapEvt_Args.html">Efl.Gesture.IEventsGestureTapEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnGestureTripleTapEvt_" data-uid="Efl.Canvas.Object.OnGestureTripleTapEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnGestureTripleTapEvt_Efl_Gesture_IEventsGestureTripleTapEvt_Args_" data-uid="Efl.Canvas.Object.OnGestureTripleTapEvt(Efl.Gesture.IEventsGestureTripleTapEvt_Args)">OnGestureTripleTapEvt(IEventsGestureTripleTapEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event GestureTripleTapEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnGestureTripleTapEvt(IEventsGestureTripleTapEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gesture.IEventsGestureTripleTapEvt_Args.html">Efl.Gesture.IEventsGestureTripleTapEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnGestureZoomEvt_" data-uid="Efl.Canvas.Object.OnGestureZoomEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnGestureZoomEvt_Efl_Gesture_IEventsGestureZoomEvt_Args_" data-uid="Efl.Canvas.Object.OnGestureZoomEvt(Efl.Gesture.IEventsGestureZoomEvt_Args)">OnGestureZoomEvt(IEventsGestureZoomEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event GestureZoomEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnGestureZoomEvt(IEventsGestureZoomEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gesture.IEventsGestureZoomEvt_Args.html">Efl.Gesture.IEventsGestureZoomEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnHintsChangedEvt_" data-uid="Efl.Canvas.Object.OnHintsChangedEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnHintsChangedEvt_EventArgs_" data-uid="Efl.Canvas.Object.OnHintsChangedEvt(EventArgs)">OnHintsChangedEvt(EventArgs)</h4>
  <div class="markdown level1 summary"><p>Method to raise event HintsChangedEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnHintsChangedEvt(EventArgs e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventArgs</span></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnHoldEvt_" data-uid="Efl.Canvas.Object.OnHoldEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnHoldEvt_Efl_Input_IInterfaceHoldEvt_Args_" data-uid="Efl.Canvas.Object.OnHoldEvt(Efl.Input.IInterfaceHoldEvt_Args)">OnHoldEvt(IInterfaceHoldEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event HoldEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnHoldEvt(IInterfaceHoldEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfaceHoldEvt_Args.html">Efl.Input.IInterfaceHoldEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnKeyDownEvt_" data-uid="Efl.Canvas.Object.OnKeyDownEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnKeyDownEvt_Efl_Input_IInterfaceKeyDownEvt_Args_" data-uid="Efl.Canvas.Object.OnKeyDownEvt(Efl.Input.IInterfaceKeyDownEvt_Args)">OnKeyDownEvt(IInterfaceKeyDownEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event KeyDownEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnKeyDownEvt(IInterfaceKeyDownEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfaceKeyDownEvt_Args.html">Efl.Input.IInterfaceKeyDownEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnKeyUpEvt_" data-uid="Efl.Canvas.Object.OnKeyUpEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnKeyUpEvt_Efl_Input_IInterfaceKeyUpEvt_Args_" data-uid="Efl.Canvas.Object.OnKeyUpEvt(Efl.Input.IInterfaceKeyUpEvt_Args)">OnKeyUpEvt(IInterfaceKeyUpEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event KeyUpEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnKeyUpEvt(IInterfaceKeyUpEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfaceKeyUpEvt_Args.html">Efl.Input.IInterfaceKeyUpEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnPointerAxisEvt_" data-uid="Efl.Canvas.Object.OnPointerAxisEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnPointerAxisEvt_Efl_Input_IInterfacePointerAxisEvt_Args_" data-uid="Efl.Canvas.Object.OnPointerAxisEvt(Efl.Input.IInterfacePointerAxisEvt_Args)">OnPointerAxisEvt(IInterfacePointerAxisEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event PointerAxisEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnPointerAxisEvt(IInterfacePointerAxisEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfacePointerAxisEvt_Args.html">Efl.Input.IInterfacePointerAxisEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnPointerCancelEvt_" data-uid="Efl.Canvas.Object.OnPointerCancelEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnPointerCancelEvt_Efl_Input_IInterfacePointerCancelEvt_Args_" data-uid="Efl.Canvas.Object.OnPointerCancelEvt(Efl.Input.IInterfacePointerCancelEvt_Args)">OnPointerCancelEvt(IInterfacePointerCancelEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event PointerCancelEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnPointerCancelEvt(IInterfacePointerCancelEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfacePointerCancelEvt_Args.html">Efl.Input.IInterfacePointerCancelEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnPointerDownEvt_" data-uid="Efl.Canvas.Object.OnPointerDownEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnPointerDownEvt_Efl_Input_IInterfacePointerDownEvt_Args_" data-uid="Efl.Canvas.Object.OnPointerDownEvt(Efl.Input.IInterfacePointerDownEvt_Args)">OnPointerDownEvt(IInterfacePointerDownEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event PointerDownEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnPointerDownEvt(IInterfacePointerDownEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfacePointerDownEvt_Args.html">Efl.Input.IInterfacePointerDownEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnPointerInEvt_" data-uid="Efl.Canvas.Object.OnPointerInEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnPointerInEvt_Efl_Input_IInterfacePointerInEvt_Args_" data-uid="Efl.Canvas.Object.OnPointerInEvt(Efl.Input.IInterfacePointerInEvt_Args)">OnPointerInEvt(IInterfacePointerInEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event PointerInEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnPointerInEvt(IInterfacePointerInEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfacePointerInEvt_Args.html">Efl.Input.IInterfacePointerInEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnPointerMoveEvt_" data-uid="Efl.Canvas.Object.OnPointerMoveEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnPointerMoveEvt_Efl_Input_IInterfacePointerMoveEvt_Args_" data-uid="Efl.Canvas.Object.OnPointerMoveEvt(Efl.Input.IInterfacePointerMoveEvt_Args)">OnPointerMoveEvt(IInterfacePointerMoveEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event PointerMoveEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnPointerMoveEvt(IInterfacePointerMoveEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfacePointerMoveEvt_Args.html">Efl.Input.IInterfacePointerMoveEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnPointerOutEvt_" data-uid="Efl.Canvas.Object.OnPointerOutEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnPointerOutEvt_Efl_Input_IInterfacePointerOutEvt_Args_" data-uid="Efl.Canvas.Object.OnPointerOutEvt(Efl.Input.IInterfacePointerOutEvt_Args)">OnPointerOutEvt(IInterfacePointerOutEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event PointerOutEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnPointerOutEvt(IInterfacePointerOutEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfacePointerOutEvt_Args.html">Efl.Input.IInterfacePointerOutEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnPointerUpEvt_" data-uid="Efl.Canvas.Object.OnPointerUpEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnPointerUpEvt_Efl_Input_IInterfacePointerUpEvt_Args_" data-uid="Efl.Canvas.Object.OnPointerUpEvt(Efl.Input.IInterfacePointerUpEvt_Args)">OnPointerUpEvt(IInterfacePointerUpEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event PointerUpEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnPointerUpEvt(IInterfacePointerUpEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfacePointerUpEvt_Args.html">Efl.Input.IInterfacePointerUpEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnPointerWheelEvt_" data-uid="Efl.Canvas.Object.OnPointerWheelEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnPointerWheelEvt_Efl_Input_IInterfacePointerWheelEvt_Args_" data-uid="Efl.Canvas.Object.OnPointerWheelEvt(Efl.Input.IInterfacePointerWheelEvt_Args)">OnPointerWheelEvt(IInterfacePointerWheelEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event PointerWheelEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnPointerWheelEvt(IInterfacePointerWheelEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.IInterfacePointerWheelEvt_Args.html">Efl.Input.IInterfacePointerWheelEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnPositionChangedEvt_" data-uid="Efl.Canvas.Object.OnPositionChangedEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnPositionChangedEvt_Efl_Gfx_IEntityPositionChangedEvt_Args_" data-uid="Efl.Canvas.Object.OnPositionChangedEvt(Efl.Gfx.IEntityPositionChangedEvt_Args)">OnPositionChangedEvt(IEntityPositionChangedEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event PositionChangedEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnPositionChangedEvt(IEntityPositionChangedEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IEntityPositionChangedEvt_Args.html">Efl.Gfx.IEntityPositionChangedEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnSizeChangedEvt_" data-uid="Efl.Canvas.Object.OnSizeChangedEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnSizeChangedEvt_Efl_Gfx_IEntitySizeChangedEvt_Args_" data-uid="Efl.Canvas.Object.OnSizeChangedEvt(Efl.Gfx.IEntitySizeChangedEvt_Args)">OnSizeChangedEvt(IEntitySizeChangedEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event SizeChangedEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnSizeChangedEvt(IEntitySizeChangedEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IEntitySizeChangedEvt_Args.html">Efl.Gfx.IEntitySizeChangedEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnStackingChangedEvt_" data-uid="Efl.Canvas.Object.OnStackingChangedEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnStackingChangedEvt_EventArgs_" data-uid="Efl.Canvas.Object.OnStackingChangedEvt(EventArgs)">OnStackingChangedEvt(EventArgs)</h4>
  <div class="markdown level1 summary"><p>Method to raise event StackingChangedEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnStackingChangedEvt(EventArgs e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventArgs</span></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_OnVisibilityChangedEvt_" data-uid="Efl.Canvas.Object.OnVisibilityChangedEvt*"></a>
  <h4 id="Efl_Canvas_Object_OnVisibilityChangedEvt_Efl_Gfx_IEntityVisibilityChangedEvt_Args_" data-uid="Efl.Canvas.Object.OnVisibilityChangedEvt(Efl.Gfx.IEntityVisibilityChangedEvt_Args)">OnVisibilityChangedEvt(IEntityVisibilityChangedEvt_Args)</h4>
  <div class="markdown level1 summary"><p>Method to raise event VisibilityChangedEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnVisibilityChangedEvt(IEntityVisibilityChangedEvt_Args e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IEntityVisibilityChangedEvt_Args.html">Efl.Gfx.IEntityVisibilityChangedEvt_Args</a></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Perspective3d_" data-uid="Efl.Canvas.Object.Perspective3d*"></a>
  <h4 id="Efl_Canvas_Object_Perspective3d_Efl_Gfx_IEntity_System_Double_System_Double_System_Double_System_Double_" data-uid="Efl.Canvas.Object.Perspective3d(Efl.Gfx.IEntity,System.Double,System.Double,System.Double,System.Double)">Perspective3d(IEntity, Double, Double, Double, Double)</h4>
  <div class="markdown level1 summary"><p>Apply a perspective transform to the map
This applies a given perspective (3D) to the map coordinates. X, Y and Z values are used. The px and py points specify the &quot;infinite distance&quot; point in the 3D conversion (where all lines converge to like when artists draw 3D by hand). The <code>z0</code> value specifies the z value at which there is a 1:1 mapping between spatial coordinates and screen coordinates. Any points on this z value will not have their X and Y values modified in the transform. Those further away (Z value higher) will shrink into the distance, and those under this value will expand and become bigger. The <code>foc</code> value determines the &quot;focal length&quot; of the camera. This is in reality the distance between the camera lens plane itself (at or closer than this rendering results are undefined) and the &quot;z0&quot; z value. This allows for some &quot;depth&quot; control and <code>foc</code> must be greater than 0.</p>
<p>The coordinates are set relative to the given <code>pivot</code> object. If its geometry changes, then the absolute position of the rotation center will change accordingly. The Z position is absolute. If the <code>pivot</code> is <code>null</code> then this object will be its own pivot.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void Perspective3d(IEntity pivot, double px, double py, double z0, double foc)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IEntity.html">Efl.Gfx.IEntity</a></td>
        <td><span class="parametername">pivot</span></td>
        <td><p>A pivot object for the infinite point, can be <code>null</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">px</span></td>
        <td><p>The perspective distance X relative coordinate.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">py</span></td>
        <td><p>The perspective distance Y relative coordinate.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">z0</span></td>
        <td><p>The &quot;0&quot; Z plane value.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">foc</span></td>
        <td><p>The focal distance, must be greater than 0.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Perspective3dAbsolute_" data-uid="Efl.Canvas.Object.Perspective3dAbsolute*"></a>
  <h4 id="Efl_Canvas_Object_Perspective3dAbsolute_System_Double_System_Double_System_Double_System_Double_" data-uid="Efl.Canvas.Object.Perspective3dAbsolute(System.Double,System.Double,System.Double,System.Double)">Perspective3dAbsolute(Double, Double, Double, Double)</h4>
  <div class="markdown level1 summary"><p>Apply a perspective transform to the map
This applies a given perspective (3D) to the map coordinates. X, Y and Z values are used. The px and py points specify the &quot;infinite distance&quot; point in the 3D conversion (where all lines converge to like when artists draw 3D by hand). The <code>z0</code> value specifies the z value at which there is a 1:1 mapping between spatial coordinates and screen coordinates. Any points on this z value will not have their X and Y values modified in the transform. Those further away (Z value higher) will shrink into the distance, and those less than this value will expand and become bigger. The <code>foc</code> value determines the &quot;focal length&quot; of the camera. This is in reality the distance between the camera lens plane itself (at or closer than this rendering results are undefined) and the &quot;z0&quot; z value. This allows for some &quot;depth&quot; control and <code>foc</code> must be greater than 0.</p>
<p>The coordinates of the center point are given in absolute canvas coordinates. See also <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_Perspective3d_Efl_Gfx_IEntity_System_Double_System_Double_System_Double_System_Double_">Efl.Gfx.IMapping.Perspective3d(Efl.Gfx.IEntity, System.Double, System.Double, System.Double, System.Double)</a> for a pivot-based perspective effect.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void Perspective3dAbsolute(double px, double py, double z0, double foc)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">px</span></td>
        <td><p>The perspective distance X relative coordinate.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">py</span></td>
        <td><p>The perspective distance Y relative coordinate.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">z0</span></td>
        <td><p>The &quot;0&quot; Z plane value.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">foc</span></td>
        <td><p>The focal distance, must be greater than 0.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_RaiseToTop_" data-uid="Efl.Canvas.Object.RaiseToTop*"></a>
  <h4 id="Efl_Canvas_Object_RaiseToTop" data-uid="Efl.Canvas.Object.RaiseToTop">RaiseToTop()</h4>
  <div class="markdown level1 summary"><p>Raise <code>obj</code> to the top of its layer.
<code>obj</code> will, then, be the highest one in the layer it belongs to. Object on other layers won't get touched.</p>
<p>See also <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_StackAbove_Efl_Gfx_IStack_">Efl.Gfx.IStack.StackAbove(Efl.Gfx.IStack)</a>, <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_StackBelow_Efl_Gfx_IStack_">Efl.Gfx.IStack.StackBelow(Efl.Gfx.IStack)</a> and <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_LowerToBottom">Efl.Gfx.IStack.LowerToBottom()</a>
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void RaiseToTop()</code></pre>
  </div>
  
  
  <a id="Efl_Canvas_Object_ResetMapping_" data-uid="Efl.Canvas.Object.ResetMapping*"></a>
  <h4 id="Efl_Canvas_Object_ResetMapping" data-uid="Efl.Canvas.Object.ResetMapping">ResetMapping()</h4>
  <div class="markdown level1 summary"><p>Resets the map transformation to its default state.
This will reset all transformations to identity, meaning the points' colors, positions and UV coordinates will be reset to their default values. <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_HasMapping">Efl.Gfx.IMapping.HasMapping()</a> will then return <code>false</code>. This function will not modify the values of <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_MappingSmooth">Efl.Gfx.IMapping.MappingSmooth</a> or <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_MappingAlpha">Efl.Gfx.IMapping.MappingAlpha</a>.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void ResetMapping()</code></pre>
  </div>
  
  
  <a id="Efl_Canvas_Object_Rotate_" data-uid="Efl.Canvas.Object.Rotate*"></a>
  <h4 id="Efl_Canvas_Object_Rotate_System_Double_Efl_Gfx_IEntity_System_Double_System_Double_" data-uid="Efl.Canvas.Object.Rotate(System.Double,Efl.Gfx.IEntity,System.Double,System.Double)">Rotate(Double, IEntity, Double, Double)</h4>
  <div class="markdown level1 summary"><p>Apply a rotation to the object.
This rotates the object clockwise by <code>degrees</code> degrees, around the center specified by the relative position (<code>cx</code>, <code>cy</code>) in the <code>pivot</code> object. If <code>pivot</code> is <code>null</code> then this object is used as its own pivot center. 360 degrees is a full rotation, equivalent to no rotation. Negative values for <code>degrees</code> will rotate clockwise by that amount.</p>
<p>The coordinates are set relative to the given <code>pivot</code> object. If its geometry changes, then the absolute position of the rotation center will change accordingly.</p>
<p>By default, the center is at (0.5, 0.5). 0.0 means left or top while 1.0 means right or bottom of the <code>pivot</code> object.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void Rotate(double degrees, IEntity pivot, double cx, double cy)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">degrees</span></td>
        <td><p>CCW rotation in degrees.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IEntity.html">Efl.Gfx.IEntity</a></td>
        <td><span class="parametername">pivot</span></td>
        <td><p>A pivot object for the center point, can be <code>null</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cx</span></td>
        <td><p>X relative coordinate of the center point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cy</span></td>
        <td><p>y relative coordinate of the center point.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Rotate3d_" data-uid="Efl.Canvas.Object.Rotate3d*"></a>
  <h4 id="Efl_Canvas_Object_Rotate3d_System_Double_System_Double_System_Double_Efl_Gfx_IEntity_System_Double_System_Double_System_Double_" data-uid="Efl.Canvas.Object.Rotate3d(System.Double,System.Double,System.Double,Efl.Gfx.IEntity,System.Double,System.Double,System.Double)">Rotate3d(Double, Double, Double, IEntity, Double, Double, Double)</h4>
  <div class="markdown level1 summary"><p>Rotate the object around 3 axes in 3D.
This will rotate in 3D, not just around the &quot;Z&quot; axis as is the case with <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_Rotate_System_Double_Efl_Gfx_IEntity_System_Double_System_Double_">Efl.Gfx.IMapping.Rotate(System.Double, Efl.Gfx.IEntity, System.Double, System.Double)</a>. You can rotate around the X, Y and Z axes. The Z axis points &quot;into&quot; the screen with low values at the screen and higher values further away. The X axis runs from left to right on the screen and the Y axis from top to bottom.</p>
<p>As with <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_Rotate_System_Double_Efl_Gfx_IEntity_System_Double_System_Double_">Efl.Gfx.IMapping.Rotate(System.Double, Efl.Gfx.IEntity, System.Double, System.Double)</a>, you provide a pivot and center point to rotate around (in 3D). The Z coordinate of this center point is an absolute value, and not a relative one like X and Y, as objects are flat in a 2D space.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void Rotate3d(double dx, double dy, double dz, IEntity pivot, double cx, double cy, double cz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">dx</span></td>
        <td><p>Rotation in degrees around X axis (0 to 360).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">dy</span></td>
        <td><p>Rotation in degrees around Y axis (0 to 360).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">dz</span></td>
        <td><p>Rotation in degrees around Z axis (0 to 360).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IEntity.html">Efl.Gfx.IEntity</a></td>
        <td><span class="parametername">pivot</span></td>
        <td><p>A pivot object for the center point, can be <code>null</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cx</span></td>
        <td><p>X relative coordinate of the center point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cy</span></td>
        <td><p>y relative coordinate of the center point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cz</span></td>
        <td><p>Z absolute coordinate of the center point.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Rotate3dAbsolute_" data-uid="Efl.Canvas.Object.Rotate3dAbsolute*"></a>
  <h4 id="Efl_Canvas_Object_Rotate3dAbsolute_System_Double_System_Double_System_Double_System_Double_System_Double_System_Double_" data-uid="Efl.Canvas.Object.Rotate3dAbsolute(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">Rotate3dAbsolute(Double, Double, Double, Double, Double, Double)</h4>
  <div class="markdown level1 summary"><p>Rotate the object around 3 axes in 3D, using absolute coordinates.
This will rotate in 3D and not just around the &quot;Z&quot; axis as the case with <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_Rotate_System_Double_Efl_Gfx_IEntity_System_Double_System_Double_">Efl.Gfx.IMapping.Rotate(System.Double, Efl.Gfx.IEntity, System.Double, System.Double)</a>. This will rotate around the X, Y and Z axes. The Z axis points &quot;into&quot; the screen with low values at the screen and higher values further away. The X axis runs from left to right on the screen and the Y axis from top to bottom.</p>
<p>The coordinates of the center point are given in absolute canvas coordinates. See also <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_Rotate3d_System_Double_System_Double_System_Double_Efl_Gfx_IEntity_System_Double_System_Double_System_Double_">Efl.Gfx.IMapping.Rotate3d(System.Double, System.Double, System.Double, Efl.Gfx.IEntity, System.Double, System.Double, System.Double)</a> for a pivot-based 3D rotation.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void Rotate3dAbsolute(double dx, double dy, double dz, double cx, double cy, double cz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">dx</span></td>
        <td><p>Rotation in degrees around X axis (0 to 360).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">dy</span></td>
        <td><p>Rotation in degrees around Y axis (0 to 360).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">dz</span></td>
        <td><p>Rotation in degrees around Z axis (0 to 360).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cx</span></td>
        <td><p>X absolute coordinate in pixels of the center point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cy</span></td>
        <td><p>y absolute coordinate in pixels of the center point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cz</span></td>
        <td><p>Z absolute coordinate of the center point.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_RotateAbsolute_" data-uid="Efl.Canvas.Object.RotateAbsolute*"></a>
  <h4 id="Efl_Canvas_Object_RotateAbsolute_System_Double_System_Double_System_Double_" data-uid="Efl.Canvas.Object.RotateAbsolute(System.Double,System.Double,System.Double)">RotateAbsolute(Double, Double, Double)</h4>
  <div class="markdown level1 summary"><p>Apply a rotation to the object, using absolute coordinates.
This rotates the object clockwise by <code>degrees</code> degrees, around the center specified by the relative position (<code>cx</code>, <code>cy</code>) in the <code>pivot</code> object. If <code>pivot</code> is <code>null</code> then this object is used as its own pivot center. 360 degrees is a full rotation, equivalent to no rotation. Negative values for <code>degrees</code> will rotate clockwise by that amount.</p>
<p>The given coordinates are absolute values in pixels. See also <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_Rotate_System_Double_Efl_Gfx_IEntity_System_Double_System_Double_">Efl.Gfx.IMapping.Rotate(System.Double, Efl.Gfx.IEntity, System.Double, System.Double)</a> for a relative coordinate version.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void RotateAbsolute(double degrees, double cx, double cy)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">degrees</span></td>
        <td><p>CCW rotation in degrees.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cx</span></td>
        <td><p>X absolute coordinate in pixels of the center point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cy</span></td>
        <td><p>y absolute coordinate in pixels of the center point.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_RotateQuat_" data-uid="Efl.Canvas.Object.RotateQuat*"></a>
  <h4 id="Efl_Canvas_Object_RotateQuat_System_Double_System_Double_System_Double_System_Double_Efl_Gfx_IEntity_System_Double_System_Double_System_Double_" data-uid="Efl.Canvas.Object.RotateQuat(System.Double,System.Double,System.Double,System.Double,Efl.Gfx.IEntity,System.Double,System.Double,System.Double)">RotateQuat(Double, Double, Double, Double, IEntity, Double, Double, Double)</h4>
  <div class="markdown level1 summary"><p>Rotate the object in 3D using a unit quaternion.
This is similar to <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_Rotate3d_System_Double_System_Double_System_Double_Efl_Gfx_IEntity_System_Double_System_Double_System_Double_">Efl.Gfx.IMapping.Rotate3d(System.Double, System.Double, System.Double, Efl.Gfx.IEntity, System.Double, System.Double, System.Double)</a> but uses a unit quaternion (also known as versor) rather than a direct angle-based rotation around a center point. Use this to avoid gimbal locks.</p>
<p>As with <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_Rotate_System_Double_Efl_Gfx_IEntity_System_Double_System_Double_">Efl.Gfx.IMapping.Rotate(System.Double, Efl.Gfx.IEntity, System.Double, System.Double)</a>, you provide a pivot and center point to rotate around (in 3D). The Z coordinate of this center point is an absolute value, and not a relative one like X and Y, as objects are flat in a 2D space.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void RotateQuat(double qx, double qy, double qz, double qw, IEntity pivot, double cx, double cy, double cz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">qx</span></td>
        <td><p>The x component of the imaginary part of the quaternion.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">qy</span></td>
        <td><p>The y component of the imaginary part of the quaternion.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">qz</span></td>
        <td><p>The z component of the imaginary part of the quaternion.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">qw</span></td>
        <td><p>The w component of the real part of the quaternion.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IEntity.html">Efl.Gfx.IEntity</a></td>
        <td><span class="parametername">pivot</span></td>
        <td><p>A pivot object for the center point, can be <code>null</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cx</span></td>
        <td><p>X relative coordinate of the center point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cy</span></td>
        <td><p>y relative coordinate of the center point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cz</span></td>
        <td><p>Z absolute coordinate of the center point.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_RotateQuatAbsolute_" data-uid="Efl.Canvas.Object.RotateQuatAbsolute*"></a>
  <h4 id="Efl_Canvas_Object_RotateQuatAbsolute_System_Double_System_Double_System_Double_System_Double_System_Double_System_Double_System_Double_" data-uid="Efl.Canvas.Object.RotateQuatAbsolute(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">RotateQuatAbsolute(Double, Double, Double, Double, Double, Double, Double)</h4>
  <div class="markdown level1 summary"><p>Rotate the object in 3D using a unit quaternion, using absolute coordinates.
This is similar to <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_Rotate3d_System_Double_System_Double_System_Double_Efl_Gfx_IEntity_System_Double_System_Double_System_Double_">Efl.Gfx.IMapping.Rotate3d(System.Double, System.Double, System.Double, Efl.Gfx.IEntity, System.Double, System.Double, System.Double)</a> but uses a unit quaternion (also known as versor) rather than a direct angle-based rotation around a center point. Use this to avoid gimbal locks.</p>
<p>The coordinates of the center point are given in absolute canvas coordinates. See also <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_RotateQuat_System_Double_System_Double_System_Double_System_Double_Efl_Gfx_IEntity_System_Double_System_Double_System_Double_">Efl.Gfx.IMapping.RotateQuat(System.Double, System.Double, System.Double, System.Double, Efl.Gfx.IEntity, System.Double, System.Double, System.Double)</a> for a pivot-based 3D rotation.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void RotateQuatAbsolute(double qx, double qy, double qz, double qw, double cx, double cy, double cz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">qx</span></td>
        <td><p>The x component of the imaginary part of the quaternion.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">qy</span></td>
        <td><p>The y component of the imaginary part of the quaternion.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">qz</span></td>
        <td><p>The z component of the imaginary part of the quaternion.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">qw</span></td>
        <td><p>The w component of the real part of the quaternion.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cx</span></td>
        <td><p>X absolute coordinate in pixels of the center point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cy</span></td>
        <td><p>y absolute coordinate in pixels of the center point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cz</span></td>
        <td><p>Z absolute coordinate of the center point.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetAntiAlias_" data-uid="Efl.Canvas.Object.SetAntiAlias*"></a>
  <h4 id="Efl_Canvas_Object_SetAntiAlias_System_Boolean_" data-uid="Efl.Canvas.Object.SetAntiAlias(System.Boolean)">SetAntiAlias(Boolean)</h4>
  <div class="markdown level1 summary"><p>Sets whether or not the given Evas object is to be drawn anti-aliased.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetAntiAlias(bool anti_alias)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">anti_alias</span></td>
        <td><p><code>true</code> if the object is to be anti_aliased, <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetClipper_" data-uid="Efl.Canvas.Object.SetClipper*"></a>
  <h4 id="Efl_Canvas_Object_SetClipper_Efl_Canvas_Object_" data-uid="Efl.Canvas.Object.SetClipper(Efl.Canvas.Object)">SetClipper(Object)</h4>
  <div class="markdown level1 summary"><p>Clip one object to another.
This function will clip the object <code>obj</code> to the area occupied by the object <code>clip</code>. This means the object <code>obj</code> will only be visible within the area occupied by the clipping object (<code>clip</code>).</p>
<p>The color of the object being clipped will be multiplied by the color of the clipping one, so the resulting color for the former will be &quot;RESULT = (OBJ * CLIP) / (255 * 255)&quot;, per color element (red, green, blue and alpha).</p>
<p>Clipping is recursive, so clipping objects may be clipped by others, and their color will in term be multiplied. You may not set up circular clipping lists (i.e. object 1 clips object 2, which clips object 1): the behavior of Evas is undefined in this case.</p>
<p>Objects which do not clip others are visible in the canvas as normal; those that clip one or more objects become invisible themselves, only affecting what they clip. If an object ceases to have other objects being clipped by it, it will become visible again.</p>
<p>The visibility of an object affects the objects that are clipped by it, so if the object clipping others is not shown (as in <a class="xref" href="Efl.Gfx.IEntity.html#Efl_Gfx_IEntity_Visible">Efl.Gfx.IEntity.Visible</a>), the objects clipped by it will not be shown  either.</p>
<p>If <code>obj</code> was being clipped by another object when this function is  called, it gets implicitly removed from the old clipper's domain and is made now to be clipped by its new clipper.</p>
<p>If <code>clip</code> is <code>null</code>, this call will disable clipping for the object i.e. its visibility and color get detached from the previous clipper. If it wasn't, this has no effect.</p>
<p>Note: Only rectangle and image (masks) objects can be used as clippers. Anything else will result in undefined behaviour.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetClipper(Object clipper)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Canvas.Object.html">Efl.Canvas.Object</a></td>
        <td><span class="parametername">clipper</span></td>
        <td><p>The object to clip <code>obj</code> by.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetColor_" data-uid="Efl.Canvas.Object.SetColor*"></a>
  <h4 id="Efl_Canvas_Object_SetColor_System_Int32_System_Int32_System_Int32_System_Int32_" data-uid="Efl.Canvas.Object.SetColor(System.Int32,System.Int32,System.Int32,System.Int32)">SetColor(Int32, Int32, Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Sets the general/main color of the given Evas object to the given one.
See also <a class="xref" href="Efl.Gfx.IColor.html#Efl_Gfx_IColor_GetColor_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IColor.GetColor(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a> (for an example)</p>
<p>These color values are expected to be premultiplied by alpha.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetColor(int r, int g, int b, int a)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">r</span></td>
        <td></td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">g</span></td>
        <td></td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">b</span></td>
        <td></td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">a</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetColorCode_" data-uid="Efl.Canvas.Object.SetColorCode*"></a>
  <h4 id="Efl_Canvas_Object_SetColorCode_System_String_" data-uid="Efl.Canvas.Object.SetColorCode(System.String)">SetColorCode(String)</h4>
  <div class="markdown level1 summary"><p>Set the color of given Evas object to the given hex color code(#RRGGBBAA). e.g. efl_gfx_color_code_set(obj, &quot;#FFCCAACC&quot;);
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetColorCode(string colorcode)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">colorcode</span></td>
        <td><p>the hex color code.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetGeometry_" data-uid="Efl.Canvas.Object.SetGeometry*"></a>
  <h4 id="Efl_Canvas_Object_SetGeometry_Eina_Rect_" data-uid="Efl.Canvas.Object.SetGeometry(Eina.Rect)">SetGeometry(Rect)</h4>
  <div class="markdown level1 summary"><p>Rectangular geometry that combines both position and size.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetGeometry(Rect rect)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><span class="parametername">rect</span></td>
        <td><p>The X,Y position and W,H size, in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetHintAlign_" data-uid="Efl.Canvas.Object.SetHintAlign*"></a>
  <h4 id="Efl_Canvas_Object_SetHintAlign_System_Double_System_Double_" data-uid="Efl.Canvas.Object.SetHintAlign(System.Double,System.Double)">SetHintAlign(Double, Double)</h4>
  <div class="markdown level1 summary"><p>Hints for an object's alignment.
These are hints on how to align an object inside the boundaries of a container/manager. Accepted values are in the 0.0 to 1.0 range.</p>
<p>For the horizontal component, 0.0 means to the left, 1.0 means to the right. Analogously, for the vertical component, 0.0 to the top, 1.0 means to the bottom.</p>
<p>This is not a size enforcement in any way, it's just a hint that should be used whenever appropriate.</p>
<p>Note: Default alignment hint values are 0.5, for both axes.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetHintAlign(double x, double y)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">x</span></td>
        <td><p>Double, ranging from 0.0 to 1.0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">y</span></td>
        <td><p>Double, ranging from 0.0 to 1.0.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetHintAspect_" data-uid="Efl.Canvas.Object.SetHintAspect*"></a>
  <h4 id="Efl_Canvas_Object_SetHintAspect_Efl_Gfx_HintAspect_Eina_Size2D_" data-uid="Efl.Canvas.Object.SetHintAspect(Efl.Gfx.HintAspect,Eina.Size2D)">SetHintAspect(HintAspect, Size2D)</h4>
  <div class="markdown level1 summary"><p>Defines the aspect ratio to respect when scaling this object.
The aspect ratio is defined as the width / height ratio of the object. Depending on the object and its container, this hint may or may not be fully respected.</p>
<p>If any of the given aspect ratio terms are 0, the object's container will ignore the aspect and scale this object to occupy the whole available area, for any given policy.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetHintAspect(HintAspect mode, Size2D sz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.HintAspect.html">Efl.Gfx.HintAspect</a></td>
        <td><span class="parametername">mode</span></td>
        <td><p>Mode of interpretation.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><span class="parametername">sz</span></td>
        <td><p>Base size to use for aspecting.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetHintFill_" data-uid="Efl.Canvas.Object.SetHintFill*"></a>
  <h4 id="Efl_Canvas_Object_SetHintFill_System_Boolean_System_Boolean_" data-uid="Efl.Canvas.Object.SetHintFill(System.Boolean,System.Boolean)">SetHintFill(Boolean, Boolean)</h4>
  <div class="markdown level1 summary"><p>Hints for an object's fill property that used to specify &quot;justify&quot; or &quot;fill&quot; by some users. <a class="xref" href="Efl.Gfx.IHint.html#Efl_Gfx_IHint_GetHintFill_System_Boolean__System_Boolean__">Efl.Gfx.IHint.GetHintFill(out System.Boolean, out System.Boolean)</a> specify whether to fill the space inside the boundaries of a container/manager.
Maximum hints should be enforced with higher priority, if they are set. Also, any <a class="xref" href="Efl.Gfx.IHint.html#Efl_Gfx_IHint_GetHintMargin_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IHint.GetHintMargin(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a> set on objects should add up to the object space on the final scene composition.</p>
<p>See documentation of possible users: in Evas, they are the <a class="xref" href="Efl.Ui.Box.html">Efl.Ui.Box</a> &quot;box&quot; and <a class="xref" href="Efl.Ui.Table.html">Efl.Ui.Table</a> &quot;table&quot; smart objects.</p>
<p>This is not a size enforcement in any way, it's just a hint that should be used whenever appropriate.</p>
<p>Note: Default fill hint values are true, for both axes.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetHintFill(bool x, bool y)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">x</span></td>
        <td><p><code>true</code> if to fill the object space, <code>false</code> otherwise, to use as horizontal fill hint.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">y</span></td>
        <td><p><code>true</code> if to fill the object space, <code>false</code> otherwise, to use as vertical fill hint.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetHintMargin_" data-uid="Efl.Canvas.Object.SetHintMargin*"></a>
  <h4 id="Efl_Canvas_Object_SetHintMargin_System_Int32_System_Int32_System_Int32_System_Int32_" data-uid="Efl.Canvas.Object.SetHintMargin(System.Int32,System.Int32,System.Int32,System.Int32)">SetHintMargin(Int32, Int32, Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Hints for an object's margin or padding space.
This is not a size enforcement in any way, it's just a hint that should be used whenever appropriate.</p>
<p>The object container is in charge of fetching this property and placing the object accordingly.</p>
<p>Note: Smart objects (such as elementary) can have their own hint policy. So calling this API may or may not affect the size of smart objects.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetHintMargin(int l, int r, int t, int b)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">l</span></td>
        <td><p>Integer to specify left padding.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">r</span></td>
        <td><p>Integer to specify right padding.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">t</span></td>
        <td><p>Integer to specify top padding.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">b</span></td>
        <td><p>Integer to specify bottom padding.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetHintSizeMax_" data-uid="Efl.Canvas.Object.SetHintSizeMax*"></a>
  <h4 id="Efl_Canvas_Object_SetHintSizeMax_Eina_Size2D_" data-uid="Efl.Canvas.Object.SetHintSizeMax(Eina.Size2D)">SetHintSizeMax(Size2D)</h4>
  <div class="markdown level1 summary"><p>Hints on the object's maximum size.
This is not a size enforcement in any way, it's just a hint that should be used whenever appropriate.</p>
<p>The object container is in charge of fetching this property and placing the object accordingly.</p>
<p>Values -1 will be treated as unset hint components, when queried by managers.</p>
<p>Note: Smart objects (such as elementary) can have their own hint policy. So calling this API may or may not affect the size of smart objects.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetHintSizeMax(Size2D sz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><span class="parametername">sz</span></td>
        <td><p>Maximum size (hint) in pixels, (-1, -1) by default for canvas objects).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetHintSizeMin_" data-uid="Efl.Canvas.Object.SetHintSizeMin*"></a>
  <h4 id="Efl_Canvas_Object_SetHintSizeMin_Eina_Size2D_" data-uid="Efl.Canvas.Object.SetHintSizeMin(Eina.Size2D)">SetHintSizeMin(Size2D)</h4>
  <div class="markdown level1 summary"><p>Hints on the object's minimum size.
This is not a size enforcement in any way, it's just a hint that should be used whenever appropriate. The object container is in charge of fetching this property and placing the object accordingly.</p>
<p>Value 0 will be treated as unset hint components, when queried by managers.</p>
<p>Note: This property is meant to be set by applications and not by EFL itself. Use this to request a specific size (treated as minimum size).
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetHintSizeMin(Size2D sz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><span class="parametername">sz</span></td>
        <td><p>Minimum size (hint) in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetHintSizeRestrictedMin_" data-uid="Efl.Canvas.Object.SetHintSizeRestrictedMin*"></a>
  <h4 id="Efl_Canvas_Object_SetHintSizeRestrictedMin_Eina_Size2D_" data-uid="Efl.Canvas.Object.SetHintSizeRestrictedMin(Eina.Size2D)">SetHintSizeRestrictedMin(Size2D)</h4>
  <div class="markdown level1 summary"><p>This function is protected as it is meant for widgets to indicate their &quot;intrinsic&quot; minimum size.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetHintSizeRestrictedMin(Size2D sz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><span class="parametername">sz</span></td>
        <td><p>Minimum size (hint) in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetHintWeight_" data-uid="Efl.Canvas.Object.SetHintWeight*"></a>
  <h4 id="Efl_Canvas_Object_SetHintWeight_System_Double_System_Double_" data-uid="Efl.Canvas.Object.SetHintWeight(System.Double,System.Double)">SetHintWeight(Double, Double)</h4>
  <div class="markdown level1 summary"><p>Hints for an object's weight.
This is a hint on how a container object should resize a given child within its area. Containers may adhere to the simpler logic of just expanding the child object's dimensions to fit its own (see the <a class="xref" href="Efl.Gfx.Constants.html#Efl_Gfx_Constants_HintExpand">Efl.Gfx.Constants.HintExpand</a> helper weight macro) or the complete one of taking each child's weight hint as real weights to how much of its size to allocate for them in each axis. A container is supposed to, after normalizing the weights of its children (with weight  hints), distribut the space it has to layout them by those factors -- most weighted children get larger in this process than the least ones.</p>
<p>Accepted values are zero or positive values. Some containers might use this hint as a boolean, but some others might consider it as a proportion, see documentation of each container.</p>
<p>Note: Default weight hint values are 0.0, for both axis.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetHintWeight(double x, double y)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">x</span></td>
        <td><p>Non-negative double value to use as horizontal weight hint.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">y</span></td>
        <td><p>Non-negative double value to use as vertical weight hint.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetKeyFocus_" data-uid="Efl.Canvas.Object.SetKeyFocus*"></a>
  <h4 id="Efl_Canvas_Object_SetKeyFocus_System_Boolean_" data-uid="Efl.Canvas.Object.SetKeyFocus(System.Boolean)">SetKeyFocus(Boolean)</h4>
  <div class="markdown level1 summary"><p>Indicates that this object is the keyboard event receiver on its canvas.
Changing focus only affects where (key) input events go. There can be only one object focused at any time. If <code>focus</code> is <code>true</code>, <code>obj</code> will be set as the currently focused object and it will receive all keyboard events that are not exclusive key grabs on other objects. See also <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_CheckSeatFocus_Efl_Input_Device_">Efl.Canvas.Object.CheckSeatFocus(Efl.Input.Device)</a>, <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_AddSeatFocus_Efl_Input_Device_">Efl.Canvas.Object.AddSeatFocus(Efl.Input.Device)</a>, <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_DelSeatFocus_Efl_Input_Device_">Efl.Canvas.Object.DelSeatFocus(Efl.Input.Device)</a>.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetKeyFocus(bool focus)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">focus</span></td>
        <td><p><code>true</code> when set as focused or <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetLanguage_" data-uid="Efl.Canvas.Object.SetLanguage*"></a>
  <h4 id="Efl_Canvas_Object_SetLanguage_System_String_" data-uid="Efl.Canvas.Object.SetLanguage(System.String)">SetLanguage(String)</h4>
  <div class="markdown level1 summary"><p>Sets the language for this object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetLanguage(string language)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">language</span></td>
        <td><p>The current language.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetLayer_" data-uid="Efl.Canvas.Object.SetLayer*"></a>
  <h4 id="Efl_Canvas_Object_SetLayer_System_Int16_" data-uid="Efl.Canvas.Object.SetLayer(System.Int16)">SetLayer(Int16)</h4>
  <div class="markdown level1 summary"><p>Sets the layer of its canvas that the given object will be part of.
If you don't use this function, you'll be dealing with an unique layer of objects (the default one). Additional layers are handy when you don't want a set of objects to interfere with another set with regard to stacking. Two layers are completely disjoint in that matter.</p>
<p>This is a low-level function, which you'd be using when something should be always on top, for example.</p>
<p>Warning: Don't change the layer of smart objects' children. Smart objects have a layer of their own, which should contain all their child objects.</p>
<p>See also <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_GetLayer">Efl.Gfx.IStack.GetLayer()</a>
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetLayer(short l)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int16</span></td>
        <td><span class="parametername">l</span></td>
        <td><p>The number of the layer to place the object on. Must be between <a class="xref" href="Efl.Gfx.Constants.html#Efl_Gfx_Constants_StackLayerMin">Efl.Gfx.Constants.StackLayerMin</a> and <a class="xref" href="Efl.Gfx.Constants.html#Efl_Gfx_Constants_StackLayerMax">Efl.Gfx.Constants.StackLayerMax</a>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetMappingAlpha_" data-uid="Efl.Canvas.Object.SetMappingAlpha*"></a>
  <h4 id="Efl_Canvas_Object_SetMappingAlpha_System_Boolean_" data-uid="Efl.Canvas.Object.SetMappingAlpha(System.Boolean)">SetMappingAlpha(Boolean)</h4>
  <div class="markdown level1 summary"><p>Alpha flag for map rendering.
This sets alpha flag for map rendering. If the object is a type that has its own alpha settings, then this will take precedence. Only image objects support this currently (<a class="xref" href="Efl.Canvas.Image.html">Efl.Canvas.Image</a> and its friends). Setting this to off stops alpha blending of the map area, and is useful if you know the object and/or all sub-objects is 100% solid.</p>
<p>Note that this may conflict with <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_MappingSmooth">Efl.Gfx.IMapping.MappingSmooth</a> depending on which algorithm is used for anti-aliasing.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetMappingAlpha(bool alpha)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">alpha</span></td>
        <td><p><code>true</code> by default.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetMappingColor_" data-uid="Efl.Canvas.Object.SetMappingColor*"></a>
  <h4 id="Efl_Canvas_Object_SetMappingColor_System_Int32_System_Int32_System_Int32_System_Int32_System_Int32_" data-uid="Efl.Canvas.Object.SetMappingColor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">SetMappingColor(Int32, Int32, Int32, Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Color of a vertex in the map.
This sets the color of the vertex in the map. Colors will be linearly interpolated between vertex points through the map. Color will multiply the &quot;texture&quot; pixels (like GL_MODULATE in OpenGL). The default color of a vertex in a map is white solid (255, 255, 255, 255) which means it will have no affect on modifying the texture pixels.</p>
<p>The color values must be premultiplied (ie. <code>a</code> &gt;= {<code>r</code>, <code>g</code>, <code>b</code>}).
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetMappingColor(int idx, int r, int g, int b, int a)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">idx</span></td>
        <td><p>ID of the point, from 0 to 3 (included). -1 can be used to set the color for all points, but it is invalid for get().</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">r</span></td>
        <td><p>Red (0 - 255)</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">g</span></td>
        <td><p>Green (0 - 255)</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">b</span></td>
        <td><p>Blue (0 - 255)</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">a</span></td>
        <td><p>Alpha (0 - 255)</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetMappingCoordAbsolute_" data-uid="Efl.Canvas.Object.SetMappingCoordAbsolute*"></a>
  <h4 id="Efl_Canvas_Object_SetMappingCoordAbsolute_System_Int32_System_Double_System_Double_System_Double_" data-uid="Efl.Canvas.Object.SetMappingCoordAbsolute(System.Int32,System.Double,System.Double,System.Double)">SetMappingCoordAbsolute(Int32, Double, Double, Double)</h4>
  <div class="markdown level1 summary"><p>A point's absolute coordinate on the canvas.
This sets/gets the fixed point's coordinate in the map. Note that points describe the outline of a quadrangle and are ordered either clockwise or counter-clockwise. Try to keep your quadrangles concave and non-complex. Though these polygon modes may work, they may not render a desired set of output. The quadrangle will use points 0 and 1 , 1 and 2, 2 and 3, and 3 and 0 to describe the edges of the quadrangle.</p>
<p>The X and Y and Z coordinates are in canvas units. Z is optional and may or may not be honored in drawing. Z is a hint and does not affect the X and Y rendered coordinates. It may be used for calculating fills with perspective correct rendering.</p>
<p>Remember all coordinates are canvas global ones as with move and resize in the canvas.</p>
<p>This property can be read to get the 4 points positions on the canvas, or set to manually place them.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetMappingCoordAbsolute(int idx, double x, double y, double z)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">idx</span></td>
        <td><p>ID of the point, from 0 to 3 (included).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">x</span></td>
        <td><p>Point X coordinate in absolute pixel coordinates.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">y</span></td>
        <td><p>Point Y coordinate in absolute pixel coordinates.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">z</span></td>
        <td><p>Point Z coordinate hint (pre-perspective transform).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetMappingPointCount_" data-uid="Efl.Canvas.Object.SetMappingPointCount*"></a>
  <h4 id="Efl_Canvas_Object_SetMappingPointCount_System_Int32_" data-uid="Efl.Canvas.Object.SetMappingPointCount(System.Int32)">SetMappingPointCount(Int32)</h4>
  <div class="markdown level1 summary"><p>Number of points of a map.
This sets the number of points of map. Currently, the number of points must be multiples of 4.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetMappingPointCount(int count)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>The number of points of map</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetMappingSmooth_" data-uid="Efl.Canvas.Object.SetMappingSmooth*"></a>
  <h4 id="Efl_Canvas_Object_SetMappingSmooth_System_Boolean_" data-uid="Efl.Canvas.Object.SetMappingSmooth(System.Boolean)">SetMappingSmooth(Boolean)</h4>
  <div class="markdown level1 summary"><p>Smoothing state for map rendering.
This sets smoothing for map rendering. If the object is a type that has its own smoothing settings, then both the smooth settings for this object and the map must be turned off. By default smooth maps are enabled.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetMappingSmooth(bool smooth)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">smooth</span></td>
        <td><p><code>true</code> by default.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetMappingUv_" data-uid="Efl.Canvas.Object.SetMappingUv*"></a>
  <h4 id="Efl_Canvas_Object_SetMappingUv_System_Int32_System_Double_System_Double_" data-uid="Efl.Canvas.Object.SetMappingUv(System.Int32,System.Double,System.Double)">SetMappingUv(Int32, Double, Double)</h4>
  <div class="markdown level1 summary"><p>Map point's U and V texture source point.
This sets/gets the U and V coordinates for the point. This determines which coordinate in the source image is mapped to the given point, much like OpenGL and textures. Valid values range from 0.0 to 1.0.</p>
<p>By default the points are set in a clockwise order, as such: - 0: top-left, i.e. (0.0, 0.0), - 1: top-right, i.e. (1.0, 0.0), - 2: bottom-right, i.e. (1.0, 1.0), - 3: bottom-left, i.e. (0.0, 1.0).
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetMappingUv(int idx, double u, double v)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">idx</span></td>
        <td><p>ID of the point, from 0 to 3 (included).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">u</span></td>
        <td><p>Relative X coordinate within the image, from 0 to 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">v</span></td>
        <td><p>Relative Y coordinate within the image, from 0 to 1.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetMirrored_" data-uid="Efl.Canvas.Object.SetMirrored*"></a>
  <h4 id="Efl_Canvas_Object_SetMirrored_System_Boolean_" data-uid="Efl.Canvas.Object.SetMirrored(System.Boolean)">SetMirrored(Boolean)</h4>
  <div class="markdown level1 summary"><p>Whether this object should be mirrored.
If mirrored, an object is in RTL (right to left) mode instead of LTR (left to right).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetMirrored(bool rtl)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">rtl</span></td>
        <td><p><code>true</code> for RTL, <code>false</code> for LTR (default).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetMirroredAutomatic_" data-uid="Efl.Canvas.Object.SetMirroredAutomatic*"></a>
  <h4 id="Efl_Canvas_Object_SetMirroredAutomatic_System_Boolean_" data-uid="Efl.Canvas.Object.SetMirroredAutomatic(System.Boolean)">SetMirroredAutomatic(Boolean)</h4>
  <div class="markdown level1 summary"><p>Whether the property <a class="xref" href="Efl.Ui.II18n.html#Efl_Ui_II18n_Mirrored">Efl.Ui.II18n.Mirrored</a> should be set automatically.
If enabled, the system or application configuration will be used to set the value of <a class="xref" href="Efl.Ui.II18n.html#Efl_Ui_II18n_Mirrored">Efl.Ui.II18n.Mirrored</a>.</p>
<p>This property may be implemented by high-level widgets (in Efl.Ui) but not by low-level widgets (in <a class="xref" href="Efl.Canvas.IScene.html">Efl.Canvas.IScene</a>) as the configuration should affect only high-level widgets.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetMirroredAutomatic(bool automatic)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">automatic</span></td>
        <td><p>Whether the widget uses automatic mirroring</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetNoRender_" data-uid="Efl.Canvas.Object.SetNoRender*"></a>
  <h4 id="Efl_Canvas_Object_SetNoRender_System_Boolean_" data-uid="Efl.Canvas.Object.SetNoRender(System.Boolean)">SetNoRender(Boolean)</h4>
  <div class="markdown level1 summary"><p>Disable all rendering on the canvas.
This flag will be used to indicate to Evas that this object should never be rendered on the canvas under any circumstances. In particular, this is useful to avoid drawing clipper objects (or masks) even when they don't clip any object. This can also be used to replace the old source_visible flag with proxy objects.</p>
<p>This is different to the visible property, as even visible objects marked as &quot;no-render&quot; will never appear on screen. But those objects can still be used as proxy sources or clippers. When hidden, all &quot;no-render&quot; objects will completely disappear from the canvas, and hide their clippees or be invisible when used as proxy sources.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetNoRender(bool enable)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">enable</span></td>
        <td><p>Enable &quot;no-render&quot; mode.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetParagraphDirection_" data-uid="Efl.Canvas.Object.SetParagraphDirection*"></a>
  <h4 id="Efl_Canvas_Object_SetParagraphDirection_Efl_TextBidirectionalType_" data-uid="Efl.Canvas.Object.SetParagraphDirection(Efl.TextBidirectionalType)">SetParagraphDirection(TextBidirectionalType)</h4>
  <div class="markdown level1 summary"><p>This handles text paragraph direction of the given object. Even if the given object is not textblock or text, its smart child objects can inherit the paragraph direction from the given object. The default paragraph direction is <code>inherit</code>.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetParagraphDirection(TextBidirectionalType dir)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.TextBidirectionalType.html">Efl.TextBidirectionalType</a></td>
        <td><span class="parametername">dir</span></td>
        <td><p>Paragraph direction for the given object.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetPassEvents_" data-uid="Efl.Canvas.Object.SetPassEvents*"></a>
  <h4 id="Efl_Canvas_Object_SetPassEvents_System_Boolean_" data-uid="Efl.Canvas.Object.SetPassEvents(System.Boolean)">SetPassEvents(Boolean)</h4>
  <div class="markdown level1 summary"><p>Set whether an Evas object is to pass (ignore) events.
If <code>pass</code> is <code>true</code>, it will make events on <code>obj</code> to be ignored. They will be triggered on the next lower object (that is not set to pass events), instead (see <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_GetBelow">Efl.Gfx.IStack.GetBelow()</a>).</p>
<p>If <code>pass</code> is <code>false</code> events will be processed on that object as normal.</p>
<p>See also <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_SetRepeatEvents_System_Boolean_">Efl.Canvas.Object.SetRepeatEvents(System.Boolean)</a>, <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_SetPropagateEvents_System_Boolean_">Efl.Canvas.Object.SetPropagateEvents(System.Boolean)</a>
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetPassEvents(bool pass)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">pass</span></td>
        <td><p>Whether <code>obj</code> is to pass events (<code>true</code>) or not (<code>false</code>).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetPointerMode_" data-uid="Efl.Canvas.Object.SetPointerMode*"></a>
  <h4 id="Efl_Canvas_Object_SetPointerMode_Efl_Input_ObjectPointerMode_" data-uid="Efl.Canvas.Object.SetPointerMode(Efl.Input.ObjectPointerMode)">SetPointerMode(ObjectPointerMode)</h4>
  <div class="markdown level1 summary"><p>Low-level pointer behaviour.
This function has a direct effect on event callbacks related to pointers (mouse, ...).</p>
<p>If the value is <a class="xref" href="Efl.Input.ObjectPointerMode.html#Efl_Input_ObjectPointerMode_AutoGrab">Efl.Input.ObjectPointerMode.AutoGrab</a> (default), then when mouse is pressed down over this object, events will be restricted to it as source, mouse moves, for example, will be emitted even when the pointer goes outside this objects geometry.</p>
<p>If the value is <a class="xref" href="Efl.Input.ObjectPointerMode.html#Efl_Input_ObjectPointerMode_NoGrab">Efl.Input.ObjectPointerMode.NoGrab</a>, then events will be emitted just when inside this object area.</p>
<p>The default value is <a class="xref" href="Efl.Input.ObjectPointerMode.html#Efl_Input_ObjectPointerMode_AutoGrab">Efl.Input.ObjectPointerMode.AutoGrab</a>. See also: <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetPointerModeByDevice_Efl_Input_Device_">Efl.Canvas.Object.GetPointerModeByDevice(Efl.Input.Device)</a> and <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetPointerModeByDevice_Efl_Input_Device_">Efl.Canvas.Object.GetPointerModeByDevice(Efl.Input.Device)</a> Note: This function will only set/get the mode for the default pointer.
(Since EFL 1.22)</p>
<p><strong>This is a BETA method</strong>. It can be modified or removed in the future. Do not use it for product development.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool SetPointerMode(ObjectPointerMode pointer_mode)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.ObjectPointerMode.html">Efl.Input.ObjectPointerMode</a></td>
        <td><span class="parametername">pointer_mode</span></td>
        <td><p>Input pointer mode</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if pointer behaviour was set, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetPointerModeByDevice_" data-uid="Efl.Canvas.Object.SetPointerModeByDevice*"></a>
  <h4 id="Efl_Canvas_Object_SetPointerModeByDevice_Efl_Input_Device_Efl_Input_ObjectPointerMode_" data-uid="Efl.Canvas.Object.SetPointerModeByDevice(Efl.Input.Device,Efl.Input.ObjectPointerMode)">SetPointerModeByDevice(Device, ObjectPointerMode)</h4>
  <div class="markdown level1 summary"><p>Low-level pointer behaviour by device. See <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetPointerMode">Efl.Canvas.Object.GetPointerMode()</a> and <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_SetPointerMode_Efl_Input_ObjectPointerMode_">Efl.Canvas.Object.SetPointerMode(Efl.Input.ObjectPointerMode)</a> for more explanation.
(Since EFL 1.22)</p>
<p><strong>This is a BETA method</strong>. It can be modified or removed in the future. Do not use it for product development.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool SetPointerModeByDevice(Device dev, ObjectPointerMode pointer_mode)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.Device.html">Efl.Input.Device</a></td>
        <td><span class="parametername">dev</span></td>
        <td><p>The pointer device to set/get the mode. Use <code>null</code> for the default pointer.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Input.ObjectPointerMode.html">Efl.Input.ObjectPointerMode</a></td>
        <td><span class="parametername">pointer_mode</span></td>
        <td><p>The pointer mode</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if pointer mode was set, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetPosition_" data-uid="Efl.Canvas.Object.SetPosition*"></a>
  <h4 id="Efl_Canvas_Object_SetPosition_Eina_Position2D_" data-uid="Efl.Canvas.Object.SetPosition(Eina.Position2D)">SetPosition(Position2D)</h4>
  <div class="markdown level1 summary"><p>Moves the given canvas object to the given location inside its canvas' viewport. If unchanged this call may be entirely skipped, but if changed this will trigger move events, as well as potential pointer,in or pointer,out events.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetPosition(Position2D pos)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Position2D.html">Eina.Position2D</a></td>
        <td><span class="parametername">pos</span></td>
        <td><p>A 2D coordinate in pixel units.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetPreciseIsInside_" data-uid="Efl.Canvas.Object.SetPreciseIsInside*"></a>
  <h4 id="Efl_Canvas_Object_SetPreciseIsInside_System_Boolean_" data-uid="Efl.Canvas.Object.SetPreciseIsInside(System.Boolean)">SetPreciseIsInside(Boolean)</h4>
  <div class="markdown level1 summary"><p>Set whether to use precise (usually expensive) point collision detection for a given Evas object.
Use this function to make Evas treat objects' transparent areas as not belonging to it with regard to mouse pointer events. By default, all of the object's boundary rectangle will be taken in account for them.</p>
<p>Warning: By using precise point collision detection you'll be making Evas more resource intensive.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetPreciseIsInside(bool precise)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">precise</span></td>
        <td><p>Whether to use precise point collision detection or not. The default value is false.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetPropagateEvents_" data-uid="Efl.Canvas.Object.SetPropagateEvents*"></a>
  <h4 id="Efl_Canvas_Object_SetPropagateEvents_System_Boolean_" data-uid="Efl.Canvas.Object.SetPropagateEvents(System.Boolean)">SetPropagateEvents(Boolean)</h4>
  <div class="markdown level1 summary"><p>Set whether events on a smart object's member should be propagated up to its parent.
This function has no effect if <code>obj</code> is not a member of a smart object.</p>
<p>If <code>prop</code> is <code>true</code>, events occurring on this object will be propagated on to the smart object of which <code>obj</code> is a member. If <code>prop</code> is <code>false</code>, events occurring on this object will not be propagated on to the smart object of which <code>obj</code> is a member. The default value is <code>true</code>.</p>
<p>See also <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_SetRepeatEvents_System_Boolean_">Efl.Canvas.Object.SetRepeatEvents(System.Boolean)</a>, <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_SetPassEvents_System_Boolean_">Efl.Canvas.Object.SetPassEvents(System.Boolean)</a>.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetPropagateEvents(bool propagate)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">propagate</span></td>
        <td><p>Whether to propagate events (<code>true</code>) or not (<code>false</code>).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetRenderOp_" data-uid="Efl.Canvas.Object.SetRenderOp*"></a>
  <h4 id="Efl_Canvas_Object_SetRenderOp_Efl_Gfx_RenderOp_" data-uid="Efl.Canvas.Object.SetRenderOp(Efl.Gfx.RenderOp)">SetRenderOp(RenderOp)</h4>
  <div class="markdown level1 summary"><p>Render mode to be used for compositing the Evas object.
Only two modes are supported: - <a class="xref" href="Efl.Gfx.RenderOp.html#Efl_Gfx_RenderOp_Blend">Efl.Gfx.RenderOp.Blend</a> means the object will be merged on top of objects below it using simple alpha compositing. - <a class="xref" href="Efl.Gfx.RenderOp.html#Efl_Gfx_RenderOp_Copy">Efl.Gfx.RenderOp.Copy</a> means this object's pixels will replace everything that is below, making this object opaque.</p>
<p>Please do not assume that <a class="xref" href="Efl.Gfx.RenderOp.html#Efl_Gfx_RenderOp_Copy">Efl.Gfx.RenderOp.Copy</a> mode can be used to &quot;poke&quot; holes in a window (to see through it), as only the compositor can ensure that. Copy mode should only be used with otherwise opaque widgets or inside non-window surfaces (eg. a transparent background inside a buffer canvas).
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetRenderOp(RenderOp render_op)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.RenderOp.html">Efl.Gfx.RenderOp</a></td>
        <td><span class="parametername">render_op</span></td>
        <td><p>Blend or copy.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetRepeatEvents_" data-uid="Efl.Canvas.Object.SetRepeatEvents*"></a>
  <h4 id="Efl_Canvas_Object_SetRepeatEvents_System_Boolean_" data-uid="Efl.Canvas.Object.SetRepeatEvents(System.Boolean)">SetRepeatEvents(Boolean)</h4>
  <div class="markdown level1 summary"><p>Set whether an Evas object is to repeat events.
If <code>repeat</code> is <code>true</code>, it will make events on <code>obj</code> to also be repeated for the next lower object in the objects' stack (see see <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_GetBelow">Efl.Gfx.IStack.GetBelow()</a>).</p>
<p>If <code>repeat</code> is <code>false</code>, events occurring on <code>obj</code> will be processed only on it.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetRepeatEvents(bool repeat)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">repeat</span></td>
        <td><p>Whether <code>obj</code> is to repeat events (<code>true</code>) or not (<code>false</code>).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetScale_" data-uid="Efl.Canvas.Object.SetScale*"></a>
  <h4 id="Efl_Canvas_Object_SetScale_System_Double_" data-uid="Efl.Canvas.Object.SetScale(System.Double)">SetScale(Double)</h4>
  <div class="markdown level1 summary"><p>Sets the scaling factor of an object.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetScale(double scale)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">scale</span></td>
        <td><p>The scaling factor (the default value is 0.0, meaning individual scaling is not set)</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetSeatEventFilter_" data-uid="Efl.Canvas.Object.SetSeatEventFilter*"></a>
  <h4 id="Efl_Canvas_Object_SetSeatEventFilter_Efl_Input_Device_System_Boolean_" data-uid="Efl.Canvas.Object.SetSeatEventFilter(Efl.Input.Device,System.Boolean)">SetSeatEventFilter(Device, Boolean)</h4>
  <div class="markdown level1 summary"><p>Add or remove a given seat to the filter list. If the filter list is empty this object will report mouse, keyboard and focus events from any seat, otherwise those events will only be reported if the event comes from a seat that is in the list.</p>
<p><strong>This is a BETA method</strong>. It can be modified or removed in the future. Do not use it for product development.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetSeatEventFilter(Device seat, bool enable)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Input.Device.html">Efl.Input.Device</a></td>
        <td><span class="parametername">seat</span></td>
        <td><p>The seat to act on.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">enable</span></td>
        <td><p><code>true</code> to enable events for a seat or <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetSize_" data-uid="Efl.Canvas.Object.SetSize*"></a>
  <h4 id="Efl_Canvas_Object_SetSize_Eina_Size2D_" data-uid="Efl.Canvas.Object.SetSize(Eina.Size2D)">SetSize(Size2D)</h4>
  <div class="markdown level1 summary"><p>Changes the size of the given object.
Note that setting the actual size of an object might be the job of its container, so this function might have no effect. Look at <a class="xref" href="Efl.Gfx.IHint.html">Efl.Gfx.IHint</a> instead, when manipulating widgets.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetSize(Size2D size)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>A 2D size in pixel units.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_SetVisible_" data-uid="Efl.Canvas.Object.SetVisible*"></a>
  <h4 id="Efl_Canvas_Object_SetVisible_System_Boolean_" data-uid="Efl.Canvas.Object.SetVisible(System.Boolean)">SetVisible(Boolean)</h4>
  <div class="markdown level1 summary"><p>Shows or hides this object.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetVisible(bool v)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">v</span></td>
        <td><p><code>true</code> if to make the object visible, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_StackAbove_" data-uid="Efl.Canvas.Object.StackAbove*"></a>
  <h4 id="Efl_Canvas_Object_StackAbove_Efl_Gfx_IStack_" data-uid="Efl.Canvas.Object.StackAbove(Efl.Gfx.IStack)">StackAbove(IStack)</h4>
  <div class="markdown level1 summary"><p>Stack <code>obj</code> immediately <code>above</code>
Objects, in a given canvas, are stacked in the order they're added. This means that, if they overlap, the highest ones will cover the lowest ones, in that order. This function is a way to change the stacking order for the objects.</p>
<p>Its intended to be used with objects belonging to the same layer in a given canvas, otherwise it will fail (and accomplish nothing).</p>
<p>If you have smart objects on your canvas and <code>obj</code> is a member of one of them, then <code>above</code> must also be a member of the same smart object.</p>
<p>Similarly, if <code>obj</code> is not a member of a smart object, <code>above</code> must not be either.</p>
<p>See also <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_GetLayer">Efl.Gfx.IStack.GetLayer()</a>, <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_SetLayer_System_Int16_">Efl.Gfx.IStack.SetLayer(System.Int16)</a> and <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_StackBelow_Efl_Gfx_IStack_">Efl.Gfx.IStack.StackBelow(Efl.Gfx.IStack)</a>
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void StackAbove(IStack above)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IStack.html">Efl.Gfx.IStack</a></td>
        <td><span class="parametername">above</span></td>
        <td><p>The object above which to stack</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_StackBelow_" data-uid="Efl.Canvas.Object.StackBelow*"></a>
  <h4 id="Efl_Canvas_Object_StackBelow_Efl_Gfx_IStack_" data-uid="Efl.Canvas.Object.StackBelow(Efl.Gfx.IStack)">StackBelow(IStack)</h4>
  <div class="markdown level1 summary"><p>Stack <code>obj</code> immediately <code>below</code>
Objects, in a given canvas, are stacked in the order they're added. This means that, if they overlap, the highest ones will cover the lowest ones, in that order. This function is a way to change the stacking order for the objects.</p>
<p>Its intended to be used with objects belonging to the same layer in a given canvas, otherwise it will fail (and accomplish nothing).</p>
<p>If you have smart objects on your canvas and <code>obj</code> is a member of one of them, then <code>below</code> must also be a member of the same smart object.</p>
<p>Similarly, if <code>obj</code> is not a member of a smart object, <code>below</code> must not be either.</p>
<p>See also <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_GetLayer">Efl.Gfx.IStack.GetLayer()</a>, <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_SetLayer_System_Int16_">Efl.Gfx.IStack.SetLayer(System.Int16)</a> and <a class="xref" href="Efl.Gfx.IStack.html#Efl_Gfx_IStack_StackBelow_Efl_Gfx_IStack_">Efl.Gfx.IStack.StackBelow(Efl.Gfx.IStack)</a>
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void StackBelow(IStack below)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IStack.html">Efl.Gfx.IStack</a></td>
        <td><span class="parametername">below</span></td>
        <td><p>The object below which to stack</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Translate_" data-uid="Efl.Canvas.Object.Translate*"></a>
  <h4 id="Efl_Canvas_Object_Translate_System_Double_System_Double_System_Double_" data-uid="Efl.Canvas.Object.Translate(System.Double,System.Double,System.Double)">Translate(Double, Double, Double)</h4>
  <div class="markdown level1 summary"><p>Apply a translation to the object using map.
This does not change the real geometry of the object but will affect its visible position.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void Translate(double dx, double dy, double dz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">dx</span></td>
        <td><p>Distance in pixels along the X axis.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">dy</span></td>
        <td><p>Distance in pixels along the Y axis.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">dz</span></td>
        <td><p>Distance in pixels along the Z axis.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_UngrabKey_" data-uid="Efl.Canvas.Object.UngrabKey*"></a>
  <h4 id="Efl_Canvas_Object_UngrabKey_System_String_Efl_Input_Modifier_Efl_Input_Modifier_" data-uid="Efl.Canvas.Object.UngrabKey(System.String,Efl.Input.Modifier,Efl.Input.Modifier)">UngrabKey(String, Modifier, Modifier)</h4>
  <div class="markdown level1 summary"><p>Removes the grab on <code>keyname</code> key events by <code>obj</code>.
Removes a key grab on <code>obj</code> if <code>keyname</code>, <code>modifiers</code>, and <code>not_modifiers</code> match.</p>
<p>See also <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GrabKey_System_String_Efl_Input_Modifier_Efl_Input_Modifier_System_Boolean_">Efl.Canvas.Object.GrabKey(System.String, Efl.Input.Modifier, Efl.Input.Modifier, System.Boolean)</a>, <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_GetKeyFocus">Efl.Canvas.Object.GetKeyFocus()</a>, <a class="xref" href="Efl.Canvas.Object.html#Efl_Canvas_Object_SetKeyFocus_System_Boolean_">Efl.Canvas.Object.SetKeyFocus(System.Boolean)</a>, and the legacy API evas_focus_get.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void UngrabKey(string keyname, Modifier modifiers, Modifier not_modifiers)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">keyname</span></td>
        <td><p>The key the grab is set for.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Input.Modifier.html">Efl.Input.Modifier</a></td>
        <td><span class="parametername">modifiers</span></td>
        <td><p>A mask of modifiers that must be present to trigger the event.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Input.Modifier.html">Efl.Input.Modifier</a></td>
        <td><span class="parametername">not_modifiers</span></td>
        <td><p>A mask of modifiers that must not not be present to trigger the event.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_Zoom_" data-uid="Efl.Canvas.Object.Zoom*"></a>
  <h4 id="Efl_Canvas_Object_Zoom_System_Double_System_Double_Efl_Gfx_IEntity_System_Double_System_Double_" data-uid="Efl.Canvas.Object.Zoom(System.Double,System.Double,Efl.Gfx.IEntity,System.Double,System.Double)">Zoom(Double, Double, IEntity, Double, Double)</h4>
  <div class="markdown level1 summary"><p>Apply a zoom to the object.
This zooms the points of the map from a center point. That center is defined by <code>cx</code> and <code>cy</code>. The <code>zoomx</code> and <code>zoomy</code> parameters specify how much to zoom in the X and Y direction respectively. A value of 1.0 means &quot;don't zoom&quot;. 2.0 means &quot;double the size&quot;. 0.5 is &quot;half the size&quot; etc.</p>
<p>By default, the center is at (0.5, 0.5). 0.0 means left or top while 1.0 means right or bottom.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void Zoom(double zoomx, double zoomy, IEntity pivot, double cx, double cy)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">zoomx</span></td>
        <td><p>Zoom in X direction</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">zoomy</span></td>
        <td><p>Zoom in Y direction</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IEntity.html">Efl.Gfx.IEntity</a></td>
        <td><span class="parametername">pivot</span></td>
        <td><p>A pivot object for the center point, can be <code>null</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cx</span></td>
        <td><p>X relative coordinate of the center point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cy</span></td>
        <td><p>y relative coordinate of the center point.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_Object_ZoomAbsolute_" data-uid="Efl.Canvas.Object.ZoomAbsolute*"></a>
  <h4 id="Efl_Canvas_Object_ZoomAbsolute_System_Double_System_Double_System_Double_System_Double_" data-uid="Efl.Canvas.Object.ZoomAbsolute(System.Double,System.Double,System.Double,System.Double)">ZoomAbsolute(Double, Double, Double, Double)</h4>
  <div class="markdown level1 summary"><p>Apply a zoom to the object, using absolute coordinates.
This zooms the points of the map from a center point. That center is defined by <code>cx</code> and <code>cy</code>. The <code>zoomx</code> and <code>zoomy</code> parameters specify how much to zoom in the X and Y direction respectively. A value of 1.0 means &quot;don't zoom&quot;. 2.0 means &quot;double the size&quot;. 0.5 is &quot;half the size&quot; etc.</p>
<p>The coordinates of the center point are given in absolute canvas coordinates. See also <a class="xref" href="Efl.Gfx.IMapping.html#Efl_Gfx_IMapping_Zoom_System_Double_System_Double_Efl_Gfx_IEntity_System_Double_System_Double_">Efl.Gfx.IMapping.Zoom(System.Double, System.Double, Efl.Gfx.IEntity, System.Double, System.Double)</a> for a pivot-based zoom.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void ZoomAbsolute(double zoomx, double zoomy, double cx, double cy)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">zoomx</span></td>
        <td><p>Zoom in X direction</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">zoomy</span></td>
        <td><p>Zoom in Y direction</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cx</span></td>
        <td><p>X absolute coordinate in pixels of the center point.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cy</span></td>
        <td><p>y absolute coordinate in pixels of the center point.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="events">Events
  </h3>
  
  
  <h4 id="Efl_Canvas_Object_AnimatorTickEvt" data-uid="Efl.Canvas.Object.AnimatorTickEvt">AnimatorTickEvt</h4>
  <div class="markdown level1 summary"><p>Animator tick synchronized with screen vsync if possible.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;ObjectAnimatorTickEvt_Args&gt; AnimatorTickEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Canvas.ObjectAnimatorTickEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_FingerDownEvt" data-uid="Efl.Canvas.Object.FingerDownEvt">FingerDownEvt</h4>
  <div class="markdown level1 summary"><p>Finger pressed (finger id is known).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfaceFingerDownEvt_Args&gt; FingerDownEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfaceFingerDownEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_FingerMoveEvt" data-uid="Efl.Canvas.Object.FingerMoveEvt">FingerMoveEvt</h4>
  <div class="markdown level1 summary"><p>Finger moved (current and previous positions are known).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfaceFingerMoveEvt_Args&gt; FingerMoveEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfaceFingerMoveEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_FingerUpEvt" data-uid="Efl.Canvas.Object.FingerUpEvt">FingerUpEvt</h4>
  <div class="markdown level1 summary"><p>Finger released (finger id is known).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfaceFingerUpEvt_Args&gt; FingerUpEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfaceFingerUpEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_FocusInEvt" data-uid="Efl.Canvas.Object.FocusInEvt">FocusInEvt</h4>
  <div class="markdown level1 summary"><p>A focus in event.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfaceFocusInEvt_Args&gt; FocusInEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfaceFocusInEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_FocusOutEvt" data-uid="Efl.Canvas.Object.FocusOutEvt">FocusOutEvt</h4>
  <div class="markdown level1 summary"><p>A focus out event.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfaceFocusOutEvt_Args&gt; FocusOutEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfaceFocusOutEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_GestureDoubleTapEvt" data-uid="Efl.Canvas.Object.GestureDoubleTapEvt">GestureDoubleTapEvt</h4>
  <div class="markdown level1 summary"><p>Event for double tap gesture</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IEventsGestureDoubleTapEvt_Args&gt; GestureDoubleTapEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Gesture.IEventsGestureDoubleTapEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_GestureFlickEvt" data-uid="Efl.Canvas.Object.GestureFlickEvt">GestureFlickEvt</h4>
  <div class="markdown level1 summary"><p>Event for flick gesture</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IEventsGestureFlickEvt_Args&gt; GestureFlickEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Gesture.IEventsGestureFlickEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_GestureLongTapEvt" data-uid="Efl.Canvas.Object.GestureLongTapEvt">GestureLongTapEvt</h4>
  <div class="markdown level1 summary"><p>Event for long tap gesture</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IEventsGestureLongTapEvt_Args&gt; GestureLongTapEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Gesture.IEventsGestureLongTapEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_GestureMomentumEvt" data-uid="Efl.Canvas.Object.GestureMomentumEvt">GestureMomentumEvt</h4>
  <div class="markdown level1 summary"><p>Event for momentum gesture</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IEventsGestureMomentumEvt_Args&gt; GestureMomentumEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Gesture.IEventsGestureMomentumEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_GestureTapEvt" data-uid="Efl.Canvas.Object.GestureTapEvt">GestureTapEvt</h4>
  <div class="markdown level1 summary"><p>Event for tap gesture</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IEventsGestureTapEvt_Args&gt; GestureTapEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Gesture.IEventsGestureTapEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_GestureTripleTapEvt" data-uid="Efl.Canvas.Object.GestureTripleTapEvt">GestureTripleTapEvt</h4>
  <div class="markdown level1 summary"><p>Event for triple tap gesture</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IEventsGestureTripleTapEvt_Args&gt; GestureTripleTapEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Gesture.IEventsGestureTripleTapEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_GestureZoomEvt" data-uid="Efl.Canvas.Object.GestureZoomEvt">GestureZoomEvt</h4>
  <div class="markdown level1 summary"><p>Event for zoom gesture</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IEventsGestureZoomEvt_Args&gt; GestureZoomEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Gesture.IEventsGestureZoomEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_HintsChangedEvt" data-uid="Efl.Canvas.Object.HintsChangedEvt">HintsChangedEvt</h4>
  <div class="markdown level1 summary"><p>Object hints changed.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler HintsChangedEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_HoldEvt" data-uid="Efl.Canvas.Object.HoldEvt">HoldEvt</h4>
  <div class="markdown level1 summary"><p>All input events are on hold or resumed.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfaceHoldEvt_Args&gt; HoldEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfaceHoldEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_KeyDownEvt" data-uid="Efl.Canvas.Object.KeyDownEvt">KeyDownEvt</h4>
  <div class="markdown level1 summary"><p>Keyboard key press.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfaceKeyDownEvt_Args&gt; KeyDownEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfaceKeyDownEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_KeyUpEvt" data-uid="Efl.Canvas.Object.KeyUpEvt">KeyUpEvt</h4>
  <div class="markdown level1 summary"><p>Keyboard key release.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfaceKeyUpEvt_Args&gt; KeyUpEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfaceKeyUpEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_PointerAxisEvt" data-uid="Efl.Canvas.Object.PointerAxisEvt">PointerAxisEvt</h4>
  <div class="markdown level1 summary"><p>Pen or other axis event update.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfacePointerAxisEvt_Args&gt; PointerAxisEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfacePointerAxisEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_PointerCancelEvt" data-uid="Efl.Canvas.Object.PointerCancelEvt">PointerCancelEvt</h4>
  <div class="markdown level1 summary"><p>Main pointer button press was cancelled (button id is known). This can happen in rare cases when the window manager passes the focus to a more urgent window, for instance. You probably don't need to listen to this event, as it will be accompanied by an up event.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfacePointerCancelEvt_Args&gt; PointerCancelEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfacePointerCancelEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_PointerDownEvt" data-uid="Efl.Canvas.Object.PointerDownEvt">PointerDownEvt</h4>
  <div class="markdown level1 summary"><p>Main pointer button pressed (button id is known).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfacePointerDownEvt_Args&gt; PointerDownEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfacePointerDownEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_PointerInEvt" data-uid="Efl.Canvas.Object.PointerInEvt">PointerInEvt</h4>
  <div class="markdown level1 summary"><p>Pointer entered a window or a widget.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfacePointerInEvt_Args&gt; PointerInEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfacePointerInEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_PointerMoveEvt" data-uid="Efl.Canvas.Object.PointerMoveEvt">PointerMoveEvt</h4>
  <div class="markdown level1 summary"><p>Main pointer move (current and previous positions are known).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfacePointerMoveEvt_Args&gt; PointerMoveEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfacePointerMoveEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_PointerOutEvt" data-uid="Efl.Canvas.Object.PointerOutEvt">PointerOutEvt</h4>
  <div class="markdown level1 summary"><p>Pointer left a window or a widget.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfacePointerOutEvt_Args&gt; PointerOutEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfacePointerOutEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_PointerUpEvt" data-uid="Efl.Canvas.Object.PointerUpEvt">PointerUpEvt</h4>
  <div class="markdown level1 summary"><p>Main pointer button released (button id is known).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfacePointerUpEvt_Args&gt; PointerUpEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfacePointerUpEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_PointerWheelEvt" data-uid="Efl.Canvas.Object.PointerWheelEvt">PointerWheelEvt</h4>
  <div class="markdown level1 summary"><p>Mouse wheel event.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IInterfacePointerWheelEvt_Args&gt; PointerWheelEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Input.IInterfacePointerWheelEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_PositionChangedEvt" data-uid="Efl.Canvas.Object.PositionChangedEvt">PositionChangedEvt</h4>
  <div class="markdown level1 summary"><p>Object was moved, its position during the event is the new one.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IEntityPositionChangedEvt_Args&gt; PositionChangedEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Gfx.IEntityPositionChangedEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_SizeChangedEvt" data-uid="Efl.Canvas.Object.SizeChangedEvt">SizeChangedEvt</h4>
  <div class="markdown level1 summary"><p>Object was resized, its size during the event is the new one.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IEntitySizeChangedEvt_Args&gt; SizeChangedEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Gfx.IEntitySizeChangedEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_StackingChangedEvt" data-uid="Efl.Canvas.Object.StackingChangedEvt">StackingChangedEvt</h4>
  <div class="markdown level1 summary"><p>Object stacking was changed.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler StackingChangedEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_Object_VisibilityChangedEvt" data-uid="Efl.Canvas.Object.VisibilityChangedEvt">VisibilityChangedEvt</h4>
  <div class="markdown level1 summary"><p>Object's visibility state changed, the event value is the new state.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;IEntityVisibilityChangedEvt_Args&gt; VisibilityChangedEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler&lt;Efl.Gfx.IEntityVisibilityChangedEvt_Args&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h3 id="implements">Implements</h3>
  <div>
      <a class="xref" href="Efl.Canvas.IPointer.html">Efl.Canvas.IPointer</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gesture.IEvents.html">Efl.Gesture.IEvents</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IColor.html">Efl.Gfx.IColor</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IEntity.html">Efl.Gfx.IEntity</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IHint.html">Efl.Gfx.IHint</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IMapping.html">Efl.Gfx.IMapping</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IStack.html">Efl.Gfx.IStack</a>
  </div>
  <div>
      <a class="xref" href="Efl.Input.IInterface.html">Efl.Input.IInterface</a>
  </div>
  <div>
      <a class="xref" href="Efl.Ui.II18n.html">Efl.Ui.II18n</a>
  </div>
  <div>
      <a class="xref" href="Efl.Eo.IWrapper.html">Efl.Eo.IWrapper</a>
  </div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
