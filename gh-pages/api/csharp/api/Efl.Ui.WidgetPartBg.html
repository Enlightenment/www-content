<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class Efl.Ui.WidgetPartBg
   </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class Efl.Ui.WidgetPartBg
   ">
    <meta name="generator" content="docfx 2.45.0.0">
    
    <link rel="shortcut icon" href="../e-logo-title.png">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../e-logo-title.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Efl.Ui.WidgetPartBg">
  
  
  <h1 id="Efl_Ui_WidgetPartBg" data-uid="Efl.Ui.WidgetPartBg" class="text-break">Class Efl.Ui.WidgetPartBg
  </h1>
  <div class="markdown level0 summary"><p>Elementary widget internal part background class
This part will proxy the calls on it to the <a class="xref" href="Efl.Ui.Bg.html">Efl.Ui.Bg</a> internal object of this widget. This internal object is stacked below the <a class="xref" href="Efl.Ui.Widget.html#Efl_Ui_Widget_SetResizeObject_Efl_Canvas_Object_">Efl.Ui.Widget.SetResizeObject(Efl.Canvas.Object)</a> and co-located with the widget.</p>
<p>All <a class="xref" href="Efl.Ui.Widget.html">Efl.Ui.Widget</a> objects have this part, allowing the background of the widget to be customized.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.object">System.Object</a></div>
    <div class="level1"><a class="xref" href="Efl.Eo.EoWrapper.html">Efl.Eo.EoWrapper</a></div>
    <div class="level2"><a class="xref" href="Efl.Object.html">Efl.Object</a></div>
    <div class="level3"><a class="xref" href="Efl.Ui.WidgetPart.html">Efl.Ui.WidgetPart</a></div>
    <div class="level4"><span class="xref"><b>Efl.Ui.WidgetPartBg</b></span></div>
      <div class="level5"><a class="xref" href="Efl.Ui.LayoutPartBg.html">Efl.Ui.LayoutPartBg</a></div>
  </div>
  
  <h5 id="Efl_Ui_WidgetPartBg_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public class WidgetPartBg : WidgetPart, IPropertyBind, IFile, IColor, IImage, IWrapper, IDisposable</code></pre>
  </div>
  <h3 id="constructors">Constructors
  </h3>
  
  
  <a id="Efl_Ui_WidgetPartBg__ctor_" data-uid="Efl.Ui.WidgetPartBg.#ctor*"></a>
  <h4 id="Efl_Ui_WidgetPartBg__ctor_Efl_Eo_EoWrapper_ConstructingHandle_" data-uid="Efl.Ui.WidgetPartBg.#ctor(Efl.Eo.EoWrapper.ConstructingHandle)">WidgetPartBg(EoWrapper.ConstructingHandle)</h4>
  <div class="markdown level1 summary"><p>Subclasses should override this constructor if they are expected to be instantiated from native code.
Do not call this constructor directly.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected WidgetPartBg(EoWrapper.ConstructingHandle ch)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Eo.EoWrapper.ConstructingHandle.html">Efl.Eo.EoWrapper.ConstructingHandle</a></td>
        <td><span class="parametername">ch</span></td>
        <td><p>Tag struct storing the native handle of the object being constructed.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg__ctor_" data-uid="Efl.Ui.WidgetPartBg.#ctor*"></a>
  <h4 id="Efl_Ui_WidgetPartBg__ctor_Efl_Object_" data-uid="Efl.Ui.WidgetPartBg.#ctor(Efl.Object)">WidgetPartBg(Object)</h4>
  <div class="markdown level1 summary"><p>Initializes a new instance of the <a class="xref" href="Efl.Ui.WidgetPartBg.html">Efl.Ui.WidgetPartBg</a> class.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public WidgetPartBg(Object parent = null)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Object.html">Efl.Object</a></td>
        <td><span class="parametername">parent</span></td>
        <td><p>Parent instance.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg__ctor_" data-uid="Efl.Ui.WidgetPartBg.#ctor*"></a>
  <h4 id="Efl_Ui_WidgetPartBg__ctor_System_IntPtr_Efl_Object_" data-uid="Efl.Ui.WidgetPartBg.#ctor(System.IntPtr,Efl.Object)">WidgetPartBg(IntPtr, Object)</h4>
  <div class="markdown level1 summary"><p>Initializes a new instance of the <a class="xref" href="Efl.Ui.WidgetPartBg.html">Efl.Ui.WidgetPartBg</a> class.
Internal usage: Constructor to forward the wrapper initialization to the root class that interfaces with native code. Should not be used directly.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected WidgetPartBg(IntPtr baseKlass, Object parent)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.intptr">System.IntPtr</a></td>
        <td><span class="parametername">baseKlass</span></td>
        <td><p>The pointer to the base native Eo class.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Object.html">Efl.Object</a></td>
        <td><span class="parametername">parent</span></td>
        <td><p>The Efl.Object parent of this instance.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="properties">Properties
  </h3>
  
  
  <a id="Efl_Ui_WidgetPartBg_BorderInsets_" data-uid="Efl.Ui.WidgetPartBg.BorderInsets*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_BorderInsets" data-uid="Efl.Ui.WidgetPartBg.BorderInsets">BorderInsets</h4>
  <div class="markdown level1 summary"><p>Dimensions of this image's border, a region that does not scale with the center area.
When EFL renders an image, its source may be scaled to fit the size of the object. This function sets an area from the borders of the image inwards which is not to be scaled. This function is useful for making frames and for widget theming, where, for example, buttons may be of varying sizes, but their border size must remain constant.</p>
<p>The units used for <code>l</code>, <code>r</code>, <code>t</code> and <code>b</code> are canvas units (pixels).</p>
<p>Note: The border region itself may be scaled by the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_SetBorderInsetsScale_System_Double_">Efl.Gfx.IImage.SetBorderInsetsScale(System.Double)</a> function.</p>
<p>Note: By default, image objects have no borders set, i.e. <code>l</code>, <code>r</code>, <code>t</code> and <code>b</code> start as 0.</p>
<p>Note: Similar to the concepts of 9-patch images or cap insets.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public (int, int, int, int)BorderInsets { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple&lt;System.Int32, System.Int32, System.Int32, System.Int32&gt;</span></td>
        <td><p>The border's left width.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_BorderInsetsScale_" data-uid="Efl.Ui.WidgetPartBg.BorderInsetsScale*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_BorderInsetsScale" data-uid="Efl.Ui.WidgetPartBg.BorderInsetsScale">BorderInsetsScale</h4>
  <div class="markdown level1 summary"><p>Scaling factor applied to the image borders.
This value multiplies the size of the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorderInsets_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorderInsets(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a> when scaling an object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public double BorderInsetsScale { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.double">System.Double</a></td>
        <td><p>The scale factor.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_CanDownscale_" data-uid="Efl.Ui.WidgetPartBg.CanDownscale*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_CanDownscale" data-uid="Efl.Ui.WidgetPartBg.CanDownscale">CanDownscale</h4>
  <div class="markdown level1 summary"><p>If <code>true</code>, the image may be scaled to a smaller size. If <code>false</code>, the image will never be resized smaller than its native size.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool CanDownscale { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">System.Boolean</a></td>
        <td><p>Whether to allow image downscaling.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_CanUpscale_" data-uid="Efl.Ui.WidgetPartBg.CanUpscale*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_CanUpscale" data-uid="Efl.Ui.WidgetPartBg.CanUpscale">CanUpscale</h4>
  <div class="markdown level1 summary"><p>If <code>true</code>, the image may be scaled to a larger size. If <code>false</code>, the image will never be resized larger than its native size.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool CanUpscale { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">System.Boolean</a></td>
        <td><p>Whether to allow image upscaling.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_CenterFillMode_" data-uid="Efl.Ui.WidgetPartBg.CenterFillMode*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_CenterFillMode" data-uid="Efl.Ui.WidgetPartBg.CenterFillMode">CenterFillMode</h4>
  <div class="markdown level1 summary"><p>Specifies how the center part of the object (not the borders) should be drawn when EFL is rendering it.
This function sets how the center part of the image object's source image is to be drawn, which must be one of the values in <a class="xref" href="Efl.Gfx.CenterFillMode.html">Efl.Gfx.CenterFillMode</a>. By center we mean the complementary part of that defined by <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorderInsets_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorderInsets(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>. This is very useful for making frames and decorations. You would most probably also be using a filled image (as in <span class="text-muted">Efl.Gfx.IFill.FillAuto (object still in beta stage)</span>) to use as a frame.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public CenterFillMode CenterFillMode { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.CenterFillMode.html">Efl.Gfx.CenterFillMode</a></td>
        <td><p>Fill mode of the center region. The default behavior is to render and scale the center area, respecting its transparency.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_Color_" data-uid="Efl.Ui.WidgetPartBg.Color*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_Color" data-uid="Efl.Ui.WidgetPartBg.Color">Color</h4>
  <div class="markdown level1 summary"><p>The general/main color of the given Evas object.
Represents the main color's RGB component (and alpha channel) values, which range from 0 to 255. For the alpha channel, which defines the object's transparency level, 0 means totally transparent, while 255 means opaque. These color values are premultiplied by the alpha value.</p>
<p>Usually you'll use this attribute for text and rectangle objects, where the main color is the only color. If set for objects which themselves have colors, like the images one, those colors get modulated by this one.</p>
<p>All newly created Evas rectangles get the default color values of 255 255 255 255 (opaque white).</p>
<p>When reading this property, use <code>NULL</code> pointers on the components you're not interested in and they'll be ignored by the function.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public (int, int, int, int)Color { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple&lt;System.Int32, System.Int32, System.Int32, System.Int32&gt;</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_ColorCode_" data-uid="Efl.Ui.WidgetPartBg.ColorCode*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_ColorCode" data-uid="Efl.Ui.WidgetPartBg.ColorCode">ColorCode</h4>
  <div class="markdown level1 summary"><p>Hexadecimal color code of given Evas object (#RRGGBBAA).
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public string ColorCode { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.string">System.String</a></td>
        <td><p>the hex color code.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_ContentHint_" data-uid="Efl.Ui.WidgetPartBg.ContentHint*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_ContentHint" data-uid="Efl.Ui.WidgetPartBg.ContentHint">ContentHint</h4>
  <div class="markdown level1 summary"><p>Content hint setting for the image. These hints might be used by EFL to enable optimizations.
For example, if you're on the GL engine and your driver implementation supports it, setting this hint to <a class="xref" href="Efl.Gfx.ImageContentHint.html#Efl_Gfx_ImageContentHint_Dynamic">Efl.Gfx.ImageContentHint.Dynamic</a> will make it need zero copies at texture upload time, which is an &quot;expensive&quot; operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ImageContentHint ContentHint { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageContentHint.html">Efl.Gfx.ImageContentHint</a></td>
        <td><p>Dynamic or static content hint.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_ContentRegion_" data-uid="Efl.Ui.WidgetPartBg.ContentRegion*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_ContentRegion" data-uid="Efl.Ui.WidgetPartBg.ContentRegion">ContentRegion</h4>
  <div class="markdown level1 summary"><p>Return the relative area enclosed inside the image where content is expected.
We do expect content to be inside the limit defined by the border or inside the stretch region. If a stretch region is provided, the content region will encompass the non-stretchable area that are surrounded by stretchable area. If no border and no stretch region is set, they are assumed to be zero and the full object geometry is where content can be layout on top. The area size change with the object size.</p>
<p>The geometry of the area is expressed relative to the geometry of the object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Rect ContentRegion { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><p>A rectangle inside the object boundary where content is expected. The default value is the image object's geometry with the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorderInsets_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorderInsets(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a> values subtracted.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_File_" data-uid="Efl.Ui.WidgetPartBg.File*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_File" data-uid="Efl.Ui.WidgetPartBg.File">File</h4>
  <div class="markdown level1 summary"><p>The file path from where an object will fetch the data.
If file is set during object construction, the object will automatically call <a class="xref" href="Efl.IFile.html#Efl_IFile_Load">Efl.IFile.Load()</a> during the finalize phase of construction.</p>
<p>You must not modify the strings on the returned pointers.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public string File { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.string">System.String</a></td>
        <td><p>The file path.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_ImageLoadError_" data-uid="Efl.Ui.WidgetPartBg.ImageLoadError*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_ImageLoadError" data-uid="Efl.Ui.WidgetPartBg.ImageLoadError">ImageLoadError</h4>
  <div class="markdown level1 summary"><p>The (last) file loading error for a given object. This value is set to a nonzero value if an error has occurred.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Error ImageLoadError { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Error.html">Eina.Error</a></td>
        <td><p>The load error code. A value of $0 indicates no error.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_ImageSize_" data-uid="Efl.Ui.WidgetPartBg.ImageSize*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_ImageSize" data-uid="Efl.Ui.WidgetPartBg.ImageSize">ImageSize</h4>
  <div class="markdown level1 summary"><p>This represents the size of the original image in pixels.
This may be different from the actual geometry on screen or even the size of the loaded pixel buffer. This is the size of the image as stored in the original file.</p>
<p>This is a read-only property and may return 0x0.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Size2D ImageSize { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>The size in pixels. The default value is the size of the image's internal buffer.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_Key_" data-uid="Efl.Ui.WidgetPartBg.Key*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_Key" data-uid="Efl.Ui.WidgetPartBg.Key">Key</h4>
  <div class="markdown level1 summary"><p>The key which corresponds to the target data within a file.
Some file types can contain multiple data streams which are indexed by a key. Use this property for such cases (See for example <a class="xref" href="Efl.Ui.Image.html">Efl.Ui.Image</a> or <a class="xref" href="Efl.Ui.Layout.html">Efl.Ui.Layout</a>).</p>
<p>You must not modify the strings on the returned pointers.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public string Key { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.string">System.String</a></td>
        <td><p>The group that the data belongs to. See the class documentation for particular implementations of this interface to see how this property is used.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_Loaded_" data-uid="Efl.Ui.WidgetPartBg.Loaded*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_Loaded" data-uid="Efl.Ui.WidgetPartBg.Loaded">Loaded</h4>
  <div class="markdown level1 summary"><p>The load state of the object.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool Loaded { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">System.Boolean</a></td>
        <td><p><code>true</code> if the object is loaded, <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_Mmap_" data-uid="Efl.Ui.WidgetPartBg.Mmap*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_Mmap" data-uid="Efl.Ui.WidgetPartBg.Mmap">Mmap</h4>
  <div class="markdown level1 summary"><p>The mmaped file from where an object will fetch the real data (it must be an <a class="xref" href="Eina.File.html">Eina.File</a>).
If mmap is set during object construction, the object will automatically call <a class="xref" href="Efl.IFile.html#Efl_IFile_Load">Efl.IFile.Load()</a> during the finalize phase of construction.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public File Mmap { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.File.html">Eina.File</a></td>
        <td><p>The handle to the <a class="xref" href="Eina.File.html">Eina.File</a> that will be used</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_Ratio_" data-uid="Efl.Ui.WidgetPartBg.Ratio*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_Ratio" data-uid="Efl.Ui.WidgetPartBg.Ratio">Ratio</h4>
  <div class="markdown level1 summary"><p>The native width/height ratio of the image.
The ratio will be 1.0 if it cannot be calculated (e.g. height = 0).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public double Ratio { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.double">System.Double</a></td>
        <td><p>The image's ratio.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_ScaleHint_" data-uid="Efl.Ui.WidgetPartBg.ScaleHint*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_ScaleHint" data-uid="Efl.Ui.WidgetPartBg.ScaleHint">ScaleHint</h4>
  <div class="markdown level1 summary"><p>The scale hint of a given image of the canvas.
The scale hint affects how EFL is to cache scaled versions of its original source image.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ImageScaleHint ScaleHint { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleHint.html">Efl.Gfx.ImageScaleHint</a></td>
        <td><p>Scalable or static size hint.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_ScaleMethod_" data-uid="Efl.Ui.WidgetPartBg.ScaleMethod*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_ScaleMethod" data-uid="Efl.Ui.WidgetPartBg.ScaleMethod">ScaleMethod</h4>
  <div class="markdown level1 summary"><p>Determine how the image is scaled at render time.
This allows more granular controls for how an image object should display its internal buffer. The underlying image data will not be modified.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ImageScaleMethod ScaleMethod { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleMethod.html">Efl.Gfx.ImageScaleMethod</a></td>
        <td><p>Image scale type to use.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SmoothScale_" data-uid="Efl.Ui.WidgetPartBg.SmoothScale*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SmoothScale" data-uid="Efl.Ui.WidgetPartBg.SmoothScale">SmoothScale</h4>
  <div class="markdown level1 summary"><p>Whether to use high-quality image scaling algorithm for this image.
When enabled, a higher quality image scaling algorithm is used when scaling images to sizes other than the source image's original one. This gives better results but is more computationally expensive.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool SmoothScale { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">System.Boolean</a></td>
        <td><p>Whether to use smooth scale or not.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_StretchRegion_" data-uid="Efl.Ui.WidgetPartBg.StretchRegion*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_StretchRegion" data-uid="Efl.Ui.WidgetPartBg.StretchRegion">StretchRegion</h4>
  <div class="markdown level1 summary"><p>This property defines the stretchable pixels region of an image.
When the regions are set by the user, the method will walk the iterators once and then destroy them. When the regions are retrieved by the user, it is his responsibility to destroy the iterators.. It will remember the information for the lifetime of the object. It will ignore all value of <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorderInsets_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorderInsets(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>, <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_BorderInsetsScale">Efl.Gfx.IImage.BorderInsetsScale</a> and <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_CenterFillMode">Efl.Gfx.IImage.CenterFillMode</a> . To reset the object you can just pass <code>null</code> to both horizontal and vertical at the same time.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public (Iterator&lt;ImageStretchRegion&gt;, Iterator&lt;ImageStretchRegion&gt;)StretchRegion { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple&lt;Eina.Iterator&lt;Efl.Gfx.ImageStretchRegion&gt;, Eina.Iterator&lt;Efl.Gfx.ImageStretchRegion&gt;&gt;</span></td>
        <td><p>Representation of areas that are stretchable in the image horizontal space.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetBorderInsets_" data-uid="Efl.Ui.WidgetPartBg.GetBorderInsets*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetBorderInsets_System_Int32__System_Int32__System_Int32__System_Int32__" data-uid="Efl.Ui.WidgetPartBg.GetBorderInsets(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">GetBorderInsets(out Int32, out Int32, out Int32, out Int32)</h4>
  <div class="markdown level1 summary"><p>Dimensions of this image's border, a region that does not scale with the center area.
When EFL renders an image, its source may be scaled to fit the size of the object. This function sets an area from the borders of the image inwards which is not to be scaled. This function is useful for making frames and for widget theming, where, for example, buttons may be of varying sizes, but their border size must remain constant.</p>
<p>The units used for <code>l</code>, <code>r</code>, <code>t</code> and <code>b</code> are canvas units (pixels).</p>
<p>Note: The border region itself may be scaled by the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_SetBorderInsetsScale_System_Double_">Efl.Gfx.IImage.SetBorderInsetsScale(System.Double)</a> function.</p>
<p>Note: By default, image objects have no borders set, i.e. <code>l</code>, <code>r</code>, <code>t</code> and <code>b</code> start as 0.</p>
<p>Note: Similar to the concepts of 9-patch images or cap insets.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetBorderInsets(out int l, out int r, out int t, out int b)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">l</span></td>
        <td><p>The border's left width.<br>The default value is <code>0</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">r</span></td>
        <td><p>The border's right width.<br>The default value is <code>0</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">t</span></td>
        <td><p>The border's top height.<br>The default value is <code>0</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">b</span></td>
        <td><p>The border's bottom height.<br>The default value is <code>0</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetBorderInsetsScale_" data-uid="Efl.Ui.WidgetPartBg.GetBorderInsetsScale*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetBorderInsetsScale" data-uid="Efl.Ui.WidgetPartBg.GetBorderInsetsScale">GetBorderInsetsScale()</h4>
  <div class="markdown level1 summary"><p>Scaling factor applied to the image borders.
This value multiplies the size of the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorderInsets_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorderInsets(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a> when scaling an object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual double GetBorderInsetsScale()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.double">System.Double</a></td>
        <td><p>The scale factor.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetCanDownscale_" data-uid="Efl.Ui.WidgetPartBg.GetCanDownscale*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetCanDownscale" data-uid="Efl.Ui.WidgetPartBg.GetCanDownscale">GetCanDownscale()</h4>
  <div class="markdown level1 summary"><p>If <code>true</code>, the image may be scaled to a smaller size. If <code>false</code>, the image will never be resized smaller than its native size.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetCanDownscale()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">System.Boolean</a></td>
        <td><p>Whether to allow image downscaling.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetCanUpscale_" data-uid="Efl.Ui.WidgetPartBg.GetCanUpscale*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetCanUpscale" data-uid="Efl.Ui.WidgetPartBg.GetCanUpscale">GetCanUpscale()</h4>
  <div class="markdown level1 summary"><p>If <code>true</code>, the image may be scaled to a larger size. If <code>false</code>, the image will never be resized larger than its native size.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetCanUpscale()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">System.Boolean</a></td>
        <td><p>Whether to allow image upscaling.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetCenterFillMode_" data-uid="Efl.Ui.WidgetPartBg.GetCenterFillMode*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetCenterFillMode" data-uid="Efl.Ui.WidgetPartBg.GetCenterFillMode">GetCenterFillMode()</h4>
  <div class="markdown level1 summary"><p>Specifies how the center part of the object (not the borders) should be drawn when EFL is rendering it.
This function sets how the center part of the image object's source image is to be drawn, which must be one of the values in <a class="xref" href="Efl.Gfx.CenterFillMode.html">Efl.Gfx.CenterFillMode</a>. By center we mean the complementary part of that defined by <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorderInsets_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorderInsets(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>. This is very useful for making frames and decorations. You would most probably also be using a filled image (as in <span class="text-muted">Efl.Gfx.IFill.FillAuto (object still in beta stage)</span>) to use as a frame.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual CenterFillMode GetCenterFillMode()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.CenterFillMode.html">Efl.Gfx.CenterFillMode</a></td>
        <td><p>Fill mode of the center region. The default behavior is to render and scale the center area, respecting its transparency.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetColor_" data-uid="Efl.Ui.WidgetPartBg.GetColor*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetColor_System_Int32__System_Int32__System_Int32__System_Int32__" data-uid="Efl.Ui.WidgetPartBg.GetColor(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">GetColor(out Int32, out Int32, out Int32, out Int32)</h4>
  <div class="markdown level1 summary"><p>The general/main color of the given Evas object.
Represents the main color's RGB component (and alpha channel) values, which range from 0 to 255. For the alpha channel, which defines the object's transparency level, 0 means totally transparent, while 255 means opaque. These color values are premultiplied by the alpha value.</p>
<p>Usually you'll use this attribute for text and rectangle objects, where the main color is the only color. If set for objects which themselves have colors, like the images one, those colors get modulated by this one.</p>
<p>All newly created Evas rectangles get the default color values of 255 255 255 255 (opaque white).</p>
<p>When reading this property, use <code>NULL</code> pointers on the components you're not interested in and they'll be ignored by the function.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetColor(out int r, out int g, out int b, out int a)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">r</span></td>
        <td></td>
      </tr>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">g</span></td>
        <td></td>
      </tr>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">b</span></td>
        <td></td>
      </tr>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">a</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetColorCode_" data-uid="Efl.Ui.WidgetPartBg.GetColorCode*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetColorCode" data-uid="Efl.Ui.WidgetPartBg.GetColorCode">GetColorCode()</h4>
  <div class="markdown level1 summary"><p>Hexadecimal color code of given Evas object (#RRGGBBAA).
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual string GetColorCode()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.string">System.String</a></td>
        <td><p>the hex color code.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetContentHint_" data-uid="Efl.Ui.WidgetPartBg.GetContentHint*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetContentHint" data-uid="Efl.Ui.WidgetPartBg.GetContentHint">GetContentHint()</h4>
  <div class="markdown level1 summary"><p>Content hint setting for the image. These hints might be used by EFL to enable optimizations.
For example, if you're on the GL engine and your driver implementation supports it, setting this hint to <a class="xref" href="Efl.Gfx.ImageContentHint.html#Efl_Gfx_ImageContentHint_Dynamic">Efl.Gfx.ImageContentHint.Dynamic</a> will make it need zero copies at texture upload time, which is an &quot;expensive&quot; operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual ImageContentHint GetContentHint()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageContentHint.html">Efl.Gfx.ImageContentHint</a></td>
        <td><p>Dynamic or static content hint.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetContentRegion_" data-uid="Efl.Ui.WidgetPartBg.GetContentRegion*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetContentRegion" data-uid="Efl.Ui.WidgetPartBg.GetContentRegion">GetContentRegion()</h4>
  <div class="markdown level1 summary"><p>Return the relative area enclosed inside the image where content is expected.
We do expect content to be inside the limit defined by the border or inside the stretch region. If a stretch region is provided, the content region will encompass the non-stretchable area that are surrounded by stretchable area. If no border and no stretch region is set, they are assumed to be zero and the full object geometry is where content can be layout on top. The area size change with the object size.</p>
<p>The geometry of the area is expressed relative to the geometry of the object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Rect GetContentRegion()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><p>A rectangle inside the object boundary where content is expected. The default value is the image object's geometry with the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorderInsets_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorderInsets(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a> values subtracted.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetFile_" data-uid="Efl.Ui.WidgetPartBg.GetFile*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetFile" data-uid="Efl.Ui.WidgetPartBg.GetFile">GetFile()</h4>
  <div class="markdown level1 summary"><p>The file path from where an object will fetch the data.
If file is set during object construction, the object will automatically call <a class="xref" href="Efl.IFile.html#Efl_IFile_Load">Efl.IFile.Load()</a> during the finalize phase of construction.</p>
<p>You must not modify the strings on the returned pointers.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual string GetFile()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.string">System.String</a></td>
        <td><p>The file path.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetImageLoadError_" data-uid="Efl.Ui.WidgetPartBg.GetImageLoadError*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetImageLoadError" data-uid="Efl.Ui.WidgetPartBg.GetImageLoadError">GetImageLoadError()</h4>
  <div class="markdown level1 summary"><p>The (last) file loading error for a given object. This value is set to a nonzero value if an error has occurred.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Error GetImageLoadError()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Error.html">Eina.Error</a></td>
        <td><p>The load error code. A value of $0 indicates no error.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetImageSize_" data-uid="Efl.Ui.WidgetPartBg.GetImageSize*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetImageSize" data-uid="Efl.Ui.WidgetPartBg.GetImageSize">GetImageSize()</h4>
  <div class="markdown level1 summary"><p>This represents the size of the original image in pixels.
This may be different from the actual geometry on screen or even the size of the loaded pixel buffer. This is the size of the image as stored in the original file.</p>
<p>This is a read-only property and may return 0x0.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Size2D GetImageSize()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>The size in pixels. The default value is the size of the image's internal buffer.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetKey_" data-uid="Efl.Ui.WidgetPartBg.GetKey*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetKey" data-uid="Efl.Ui.WidgetPartBg.GetKey">GetKey()</h4>
  <div class="markdown level1 summary"><p>The key which corresponds to the target data within a file.
Some file types can contain multiple data streams which are indexed by a key. Use this property for such cases (See for example <a class="xref" href="Efl.Ui.Image.html">Efl.Ui.Image</a> or <a class="xref" href="Efl.Ui.Layout.html">Efl.Ui.Layout</a>).</p>
<p>You must not modify the strings on the returned pointers.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual string GetKey()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.string">System.String</a></td>
        <td><p>The group that the data belongs to. See the class documentation for particular implementations of this interface to see how this property is used.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetLoaded_" data-uid="Efl.Ui.WidgetPartBg.GetLoaded*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetLoaded" data-uid="Efl.Ui.WidgetPartBg.GetLoaded">GetLoaded()</h4>
  <div class="markdown level1 summary"><p>The load state of the object.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetLoaded()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">System.Boolean</a></td>
        <td><p><code>true</code> if the object is loaded, <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetMmap_" data-uid="Efl.Ui.WidgetPartBg.GetMmap*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetMmap" data-uid="Efl.Ui.WidgetPartBg.GetMmap">GetMmap()</h4>
  <div class="markdown level1 summary"><p>The mmaped file from where an object will fetch the real data (it must be an <a class="xref" href="Eina.File.html">Eina.File</a>).
If mmap is set during object construction, the object will automatically call <a class="xref" href="Efl.IFile.html#Efl_IFile_Load">Efl.IFile.Load()</a> during the finalize phase of construction.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual File GetMmap()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.File.html">Eina.File</a></td>
        <td><p>The handle to the <a class="xref" href="Eina.File.html">Eina.File</a> that will be used</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetRatio_" data-uid="Efl.Ui.WidgetPartBg.GetRatio*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetRatio" data-uid="Efl.Ui.WidgetPartBg.GetRatio">GetRatio()</h4>
  <div class="markdown level1 summary"><p>The native width/height ratio of the image.
The ratio will be 1.0 if it cannot be calculated (e.g. height = 0).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual double GetRatio()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.double">System.Double</a></td>
        <td><p>The image's ratio.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetScaleHint_" data-uid="Efl.Ui.WidgetPartBg.GetScaleHint*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetScaleHint" data-uid="Efl.Ui.WidgetPartBg.GetScaleHint">GetScaleHint()</h4>
  <div class="markdown level1 summary"><p>The scale hint of a given image of the canvas.
The scale hint affects how EFL is to cache scaled versions of its original source image.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual ImageScaleHint GetScaleHint()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleHint.html">Efl.Gfx.ImageScaleHint</a></td>
        <td><p>Scalable or static size hint.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetScaleMethod_" data-uid="Efl.Ui.WidgetPartBg.GetScaleMethod*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetScaleMethod" data-uid="Efl.Ui.WidgetPartBg.GetScaleMethod">GetScaleMethod()</h4>
  <div class="markdown level1 summary"><p>Determine how the image is scaled at render time.
This allows more granular controls for how an image object should display its internal buffer. The underlying image data will not be modified.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual ImageScaleMethod GetScaleMethod()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleMethod.html">Efl.Gfx.ImageScaleMethod</a></td>
        <td><p>Image scale type to use.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetSmoothScale_" data-uid="Efl.Ui.WidgetPartBg.GetSmoothScale*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetSmoothScale" data-uid="Efl.Ui.WidgetPartBg.GetSmoothScale">GetSmoothScale()</h4>
  <div class="markdown level1 summary"><p>Whether to use high-quality image scaling algorithm for this image.
When enabled, a higher quality image scaling algorithm is used when scaling images to sizes other than the source image's original one. This gives better results but is more computationally expensive.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetSmoothScale()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">System.Boolean</a></td>
        <td><p>Whether to use smooth scale or not.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_GetStretchRegion_" data-uid="Efl.Ui.WidgetPartBg.GetStretchRegion*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_GetStretchRegion_Eina_Iterator_Efl_Gfx_ImageStretchRegion___Eina_Iterator_Efl_Gfx_ImageStretchRegion___" data-uid="Efl.Ui.WidgetPartBg.GetStretchRegion(Eina.Iterator{Efl.Gfx.ImageStretchRegion}@,Eina.Iterator{Efl.Gfx.ImageStretchRegion}@)">GetStretchRegion(out Iterator&lt;ImageStretchRegion&gt;, out Iterator&lt;ImageStretchRegion&gt;)</h4>
  <div class="markdown level1 summary"><p>This property defines the stretchable pixels region of an image.
When the regions are set by the user, the method will walk the iterators once and then destroy them. When the regions are retrieved by the user, it is his responsibility to destroy the iterators.. It will remember the information for the lifetime of the object. It will ignore all value of <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorderInsets_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorderInsets(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>, <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_BorderInsetsScale">Efl.Gfx.IImage.BorderInsetsScale</a> and <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_CenterFillMode">Efl.Gfx.IImage.CenterFillMode</a> . To reset the object you can just pass <code>null</code> to both horizontal and vertical at the same time.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetStretchRegion(out Iterator&lt;ImageStretchRegion&gt; horizontal, out Iterator&lt;ImageStretchRegion&gt; vertical)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">Eina.Iterator&lt;Efl.Gfx.ImageStretchRegion&gt;</span></td>
        <td><span class="parametername">horizontal</span></td>
        <td><p>Representation of areas that are stretchable in the image horizontal space.<br>The default value is <code>null</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">Eina.Iterator&lt;Efl.Gfx.ImageStretchRegion&gt;</span></td>
        <td><span class="parametername">vertical</span></td>
        <td><p>Representation of areas that are stretchable in the image vertical space.<br>The default value is <code>null</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_Load_" data-uid="Efl.Ui.WidgetPartBg.Load*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_Load" data-uid="Efl.Ui.WidgetPartBg.Load">Load()</h4>
  <div class="markdown level1 summary"><p>Perform all necessary operations to open and load file data into the object using the <a class="xref" href="Efl.IFile.html#Efl_IFile_File">Efl.IFile.File</a> (or <a class="xref" href="Efl.IFile.html#Efl_IFile_Mmap">Efl.IFile.Mmap</a>) and <a class="xref" href="Efl.IFile.html#Efl_IFile_Key">Efl.IFile.Key</a> properties.
In the case where <a class="xref" href="Efl.IFile.html#Efl_IFile_SetFile_System_String_">Efl.IFile.SetFile(System.String)</a> has been called on an object, this will internally open the file and call <a class="xref" href="Efl.IFile.html#Efl_IFile_SetMmap_Eina_File_">Efl.IFile.SetMmap(Eina.File)</a> on the object using the opened file handle.</p>
<p>Calling <a class="xref" href="Efl.IFile.html#Efl_IFile_Load">Efl.IFile.Load()</a> on an object which has already performed file operations based on the currently set properties will have no effect.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Error Load()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Error.html">Eina.Error</a></td>
        <td><p>0 on success, error code otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_OnImagePreloadStateChangedEvent_" data-uid="Efl.Ui.WidgetPartBg.OnImagePreloadStateChangedEvent*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_OnImagePreloadStateChangedEvent_Efl_Gfx_ImageImagePreloadStateChangedEventArgs_" data-uid="Efl.Ui.WidgetPartBg.OnImagePreloadStateChangedEvent(Efl.Gfx.ImageImagePreloadStateChangedEventArgs)">OnImagePreloadStateChangedEvent(ImageImagePreloadStateChangedEventArgs)</h4>
  <div class="markdown level1 summary"><p>Method to raise event ImagePreloadStateChangedEvent.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnImagePreloadStateChangedEvent(ImageImagePreloadStateChangedEventArgs e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageImagePreloadStateChangedEventArgs.html">Efl.Gfx.ImageImagePreloadStateChangedEventArgs</a></td>
        <td><span class="parametername">e</span></td>
        <td><p>Event to raise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_OnImageResizedEvent_" data-uid="Efl.Ui.WidgetPartBg.OnImageResizedEvent*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_OnImageResizedEvent_Efl_Gfx_ImageImageResizedEventArgs_" data-uid="Efl.Ui.WidgetPartBg.OnImageResizedEvent(Efl.Gfx.ImageImageResizedEventArgs)">OnImageResizedEvent(ImageImageResizedEventArgs)</h4>
  <div class="markdown level1 summary"><p>Method to raise event ImageResizedEvent.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnImageResizedEvent(ImageImageResizedEventArgs e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageImageResizedEventArgs.html">Efl.Gfx.ImageImageResizedEventArgs</a></td>
        <td><span class="parametername">e</span></td>
        <td><p>Event to raise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SetBorderInsets_" data-uid="Efl.Ui.WidgetPartBg.SetBorderInsets*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SetBorderInsets_System_Int32_System_Int32_System_Int32_System_Int32_" data-uid="Efl.Ui.WidgetPartBg.SetBorderInsets(System.Int32,System.Int32,System.Int32,System.Int32)">SetBorderInsets(Int32, Int32, Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Dimensions of this image's border, a region that does not scale with the center area.
When EFL renders an image, its source may be scaled to fit the size of the object. This function sets an area from the borders of the image inwards which is not to be scaled. This function is useful for making frames and for widget theming, where, for example, buttons may be of varying sizes, but their border size must remain constant.</p>
<p>The units used for <code>l</code>, <code>r</code>, <code>t</code> and <code>b</code> are canvas units (pixels).</p>
<p>Note: The border region itself may be scaled by the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_SetBorderInsetsScale_System_Double_">Efl.Gfx.IImage.SetBorderInsetsScale(System.Double)</a> function.</p>
<p>Note: By default, image objects have no borders set, i.e. <code>l</code>, <code>r</code>, <code>t</code> and <code>b</code> start as 0.</p>
<p>Note: Similar to the concepts of 9-patch images or cap insets.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetBorderInsets(int l, int r, int t, int b)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">l</span></td>
        <td><p>The border's left width.<br>The default value is <code>0</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">r</span></td>
        <td><p>The border's right width.<br>The default value is <code>0</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">t</span></td>
        <td><p>The border's top height.<br>The default value is <code>0</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">b</span></td>
        <td><p>The border's bottom height.<br>The default value is <code>0</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SetBorderInsetsScale_" data-uid="Efl.Ui.WidgetPartBg.SetBorderInsetsScale*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SetBorderInsetsScale_System_Double_" data-uid="Efl.Ui.WidgetPartBg.SetBorderInsetsScale(System.Double)">SetBorderInsetsScale(Double)</h4>
  <div class="markdown level1 summary"><p>Scaling factor applied to the image borders.
This value multiplies the size of the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorderInsets_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorderInsets(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a> when scaling an object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetBorderInsetsScale(double scale)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.double">System.Double</a></td>
        <td><span class="parametername">scale</span></td>
        <td><p>The scale factor.<br>The default value is <code>1.000000</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SetCanDownscale_" data-uid="Efl.Ui.WidgetPartBg.SetCanDownscale*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SetCanDownscale_System_Boolean_" data-uid="Efl.Ui.WidgetPartBg.SetCanDownscale(System.Boolean)">SetCanDownscale(Boolean)</h4>
  <div class="markdown level1 summary"><p>If <code>true</code>, the image may be scaled to a smaller size. If <code>false</code>, the image will never be resized smaller than its native size.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetCanDownscale(bool downscale)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">System.Boolean</a></td>
        <td><span class="parametername">downscale</span></td>
        <td><p>Whether to allow image downscaling.<br>The default value is <code>true</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SetCanUpscale_" data-uid="Efl.Ui.WidgetPartBg.SetCanUpscale*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SetCanUpscale_System_Boolean_" data-uid="Efl.Ui.WidgetPartBg.SetCanUpscale(System.Boolean)">SetCanUpscale(Boolean)</h4>
  <div class="markdown level1 summary"><p>If <code>true</code>, the image may be scaled to a larger size. If <code>false</code>, the image will never be resized larger than its native size.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetCanUpscale(bool upscale)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">System.Boolean</a></td>
        <td><span class="parametername">upscale</span></td>
        <td><p>Whether to allow image upscaling.<br>The default value is <code>true</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SetCenterFillMode_" data-uid="Efl.Ui.WidgetPartBg.SetCenterFillMode*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SetCenterFillMode_Efl_Gfx_CenterFillMode_" data-uid="Efl.Ui.WidgetPartBg.SetCenterFillMode(Efl.Gfx.CenterFillMode)">SetCenterFillMode(CenterFillMode)</h4>
  <div class="markdown level1 summary"><p>Specifies how the center part of the object (not the borders) should be drawn when EFL is rendering it.
This function sets how the center part of the image object's source image is to be drawn, which must be one of the values in <a class="xref" href="Efl.Gfx.CenterFillMode.html">Efl.Gfx.CenterFillMode</a>. By center we mean the complementary part of that defined by <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorderInsets_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorderInsets(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>. This is very useful for making frames and decorations. You would most probably also be using a filled image (as in <span class="text-muted">Efl.Gfx.IFill.FillAuto (object still in beta stage)</span>) to use as a frame.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetCenterFillMode(CenterFillMode fill)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.CenterFillMode.html">Efl.Gfx.CenterFillMode</a></td>
        <td><span class="parametername">fill</span></td>
        <td><p>Fill mode of the center region. The default behavior is to render and scale the center area, respecting its transparency.<br>The default value is <a class="xref" href="Efl.Gfx.CenterFillMode.html#Efl_Gfx_CenterFillMode_Default">Efl.Gfx.CenterFillMode.Default</a>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SetColor_" data-uid="Efl.Ui.WidgetPartBg.SetColor*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SetColor_System_Int32_System_Int32_System_Int32_System_Int32_" data-uid="Efl.Ui.WidgetPartBg.SetColor(System.Int32,System.Int32,System.Int32,System.Int32)">SetColor(Int32, Int32, Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>The general/main color of the given Evas object.
Represents the main color's RGB component (and alpha channel) values, which range from 0 to 255. For the alpha channel, which defines the object's transparency level, 0 means totally transparent, while 255 means opaque. These color values are premultiplied by the alpha value.</p>
<p>Usually you'll use this attribute for text and rectangle objects, where the main color is the only color. If set for objects which themselves have colors, like the images one, those colors get modulated by this one.</p>
<p>All newly created Evas rectangles get the default color values of 255 255 255 255 (opaque white).</p>
<p>When reading this property, use <code>NULL</code> pointers on the components you're not interested in and they'll be ignored by the function.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetColor(int r, int g, int b, int a)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">r</span></td>
        <td></td>
      </tr>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">g</span></td>
        <td></td>
      </tr>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">b</span></td>
        <td></td>
      </tr>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.int32">System.Int32</a></td>
        <td><span class="parametername">a</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SetColorCode_" data-uid="Efl.Ui.WidgetPartBg.SetColorCode*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SetColorCode_System_String_" data-uid="Efl.Ui.WidgetPartBg.SetColorCode(System.String)">SetColorCode(String)</h4>
  <div class="markdown level1 summary"><p>Hexadecimal color code of given Evas object (#RRGGBBAA).
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetColorCode(string colorcode)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.string">System.String</a></td>
        <td><span class="parametername">colorcode</span></td>
        <td><p>the hex color code.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SetContentHint_" data-uid="Efl.Ui.WidgetPartBg.SetContentHint*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SetContentHint_Efl_Gfx_ImageContentHint_" data-uid="Efl.Ui.WidgetPartBg.SetContentHint(Efl.Gfx.ImageContentHint)">SetContentHint(ImageContentHint)</h4>
  <div class="markdown level1 summary"><p>Content hint setting for the image. These hints might be used by EFL to enable optimizations.
For example, if you're on the GL engine and your driver implementation supports it, setting this hint to <a class="xref" href="Efl.Gfx.ImageContentHint.html#Efl_Gfx_ImageContentHint_Dynamic">Efl.Gfx.ImageContentHint.Dynamic</a> will make it need zero copies at texture upload time, which is an &quot;expensive&quot; operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetContentHint(ImageContentHint hint)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageContentHint.html">Efl.Gfx.ImageContentHint</a></td>
        <td><span class="parametername">hint</span></td>
        <td><p>Dynamic or static content hint.<br>The default value is <a class="xref" href="Efl.Gfx.ImageContentHint.html#Efl_Gfx_ImageContentHint_None">Efl.Gfx.ImageContentHint.None</a>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SetFile_" data-uid="Efl.Ui.WidgetPartBg.SetFile*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SetFile_System_String_" data-uid="Efl.Ui.WidgetPartBg.SetFile(System.String)">SetFile(String)</h4>
  <div class="markdown level1 summary"><p>The file path from where an object will fetch the data.
If file is set during object construction, the object will automatically call <a class="xref" href="Efl.IFile.html#Efl_IFile_Load">Efl.IFile.Load()</a> during the finalize phase of construction.</p>
<p>You must not modify the strings on the returned pointers.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Error SetFile(string file)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.string">System.String</a></td>
        <td><span class="parametername">file</span></td>
        <td><p>The file path.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Error.html">Eina.Error</a></td>
        <td><p>0 on success, error code otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SetKey_" data-uid="Efl.Ui.WidgetPartBg.SetKey*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SetKey_System_String_" data-uid="Efl.Ui.WidgetPartBg.SetKey(System.String)">SetKey(String)</h4>
  <div class="markdown level1 summary"><p>The key which corresponds to the target data within a file.
Some file types can contain multiple data streams which are indexed by a key. Use this property for such cases (See for example <a class="xref" href="Efl.Ui.Image.html">Efl.Ui.Image</a> or <a class="xref" href="Efl.Ui.Layout.html">Efl.Ui.Layout</a>).</p>
<p>You must not modify the strings on the returned pointers.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetKey(string key)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.string">System.String</a></td>
        <td><span class="parametername">key</span></td>
        <td><p>The group that the data belongs to. See the class documentation for particular implementations of this interface to see how this property is used.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SetMmap_" data-uid="Efl.Ui.WidgetPartBg.SetMmap*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SetMmap_Eina_File_" data-uid="Efl.Ui.WidgetPartBg.SetMmap(Eina.File)">SetMmap(File)</h4>
  <div class="markdown level1 summary"><p>The mmaped file from where an object will fetch the real data (it must be an <a class="xref" href="Eina.File.html">Eina.File</a>).
If mmap is set during object construction, the object will automatically call <a class="xref" href="Efl.IFile.html#Efl_IFile_Load">Efl.IFile.Load()</a> during the finalize phase of construction.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Error SetMmap(File f)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.File.html">Eina.File</a></td>
        <td><span class="parametername">f</span></td>
        <td><p>The handle to the <a class="xref" href="Eina.File.html">Eina.File</a> that will be used</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Error.html">Eina.Error</a></td>
        <td><p>0 on success, error code otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SetScaleHint_" data-uid="Efl.Ui.WidgetPartBg.SetScaleHint*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SetScaleHint_Efl_Gfx_ImageScaleHint_" data-uid="Efl.Ui.WidgetPartBg.SetScaleHint(Efl.Gfx.ImageScaleHint)">SetScaleHint(ImageScaleHint)</h4>
  <div class="markdown level1 summary"><p>The scale hint of a given image of the canvas.
The scale hint affects how EFL is to cache scaled versions of its original source image.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetScaleHint(ImageScaleHint hint)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleHint.html">Efl.Gfx.ImageScaleHint</a></td>
        <td><span class="parametername">hint</span></td>
        <td><p>Scalable or static size hint.<br>The default value is <a class="xref" href="Efl.Gfx.ImageScaleHint.html#Efl_Gfx_ImageScaleHint_None">Efl.Gfx.ImageScaleHint.None</a>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SetScaleMethod_" data-uid="Efl.Ui.WidgetPartBg.SetScaleMethod*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SetScaleMethod_Efl_Gfx_ImageScaleMethod_" data-uid="Efl.Ui.WidgetPartBg.SetScaleMethod(Efl.Gfx.ImageScaleMethod)">SetScaleMethod(ImageScaleMethod)</h4>
  <div class="markdown level1 summary"><p>Determine how the image is scaled at render time.
This allows more granular controls for how an image object should display its internal buffer. The underlying image data will not be modified.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetScaleMethod(ImageScaleMethod scale_method)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleMethod.html">Efl.Gfx.ImageScaleMethod</a></td>
        <td><span class="parametername">scale_method</span></td>
        <td><p>Image scale type to use.<br>The default value is <a class="xref" href="Efl.Gfx.ImageScaleMethod.html#Efl_Gfx_ImageScaleMethod_None">Efl.Gfx.ImageScaleMethod.None</a>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SetSmoothScale_" data-uid="Efl.Ui.WidgetPartBg.SetSmoothScale*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SetSmoothScale_System_Boolean_" data-uid="Efl.Ui.WidgetPartBg.SetSmoothScale(System.Boolean)">SetSmoothScale(Boolean)</h4>
  <div class="markdown level1 summary"><p>Whether to use high-quality image scaling algorithm for this image.
When enabled, a higher quality image scaling algorithm is used when scaling images to sizes other than the source image's original one. This gives better results but is more computationally expensive.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetSmoothScale(bool smooth_scale)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.boolean">System.Boolean</a></td>
        <td><span class="parametername">smooth_scale</span></td>
        <td><p>Whether to use smooth scale or not.<br>The default value is <code>true</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_SetStretchRegion_" data-uid="Efl.Ui.WidgetPartBg.SetStretchRegion*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_SetStretchRegion_Eina_Iterator_Efl_Gfx_ImageStretchRegion__Eina_Iterator_Efl_Gfx_ImageStretchRegion__" data-uid="Efl.Ui.WidgetPartBg.SetStretchRegion(Eina.Iterator{Efl.Gfx.ImageStretchRegion},Eina.Iterator{Efl.Gfx.ImageStretchRegion})">SetStretchRegion(Iterator&lt;ImageStretchRegion&gt;, Iterator&lt;ImageStretchRegion&gt;)</h4>
  <div class="markdown level1 summary"><p>This property defines the stretchable pixels region of an image.
When the regions are set by the user, the method will walk the iterators once and then destroy them. When the regions are retrieved by the user, it is his responsibility to destroy the iterators.. It will remember the information for the lifetime of the object. It will ignore all value of <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorderInsets_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorderInsets(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>, <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_BorderInsetsScale">Efl.Gfx.IImage.BorderInsetsScale</a> and <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_CenterFillMode">Efl.Gfx.IImage.CenterFillMode</a> . To reset the object you can just pass <code>null</code> to both horizontal and vertical at the same time.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Error SetStretchRegion(Iterator&lt;ImageStretchRegion&gt; horizontal, Iterator&lt;ImageStretchRegion&gt; vertical)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">Eina.Iterator&lt;Efl.Gfx.ImageStretchRegion&gt;</span></td>
        <td><span class="parametername">horizontal</span></td>
        <td><p>Representation of areas that are stretchable in the image horizontal space.<br>The default value is <code>null</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">Eina.Iterator&lt;Efl.Gfx.ImageStretchRegion&gt;</span></td>
        <td><span class="parametername">vertical</span></td>
        <td><p>Representation of areas that are stretchable in the image vertical space.<br>The default value is <code>null</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Error.html">Eina.Error</a></td>
        <td><p>Return an error code if the provided values are incorrect.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_WidgetPartBg_Unload_" data-uid="Efl.Ui.WidgetPartBg.Unload*"></a>
  <h4 id="Efl_Ui_WidgetPartBg_Unload" data-uid="Efl.Ui.WidgetPartBg.Unload">Unload()</h4>
  <div class="markdown level1 summary"><p>Perform all necessary operations to unload file data from the object.
In the case where <a class="xref" href="Efl.IFile.html#Efl_IFile_SetMmap_Eina_File_">Efl.IFile.SetMmap(Eina.File)</a> has been externally called on an object, the file handle stored in the object will be preserved.</p>
<p>Calling <a class="xref" href="Efl.IFile.html#Efl_IFile_Unload">Efl.IFile.Unload()</a> on an object which is not currently loaded will have no effect.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void Unload()</code></pre>
  </div>
  <h3 id="events">Events
  </h3>
  
  
  <h4 id="Efl_Ui_WidgetPartBg_ImagePreloadStateChangedEvent" data-uid="Efl.Ui.WidgetPartBg.ImagePreloadStateChangedEvent">ImagePreloadStateChangedEvent</h4>
  <div class="markdown level1 summary"><p>If <code>true</code>, image data has been preloaded and can be displayed. If <code>false</code>, the image data has been unloaded and can no longer be displayed.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;ImageImagePreloadStateChangedEventArgs&gt; ImagePreloadStateChangedEvent</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.EventHandler&lt;Efl.Gfx.ImageImagePreloadStateChangedEventArgs&gt;</span></td>
        <td><p><a class="xref" href="Efl.Gfx.ImageImagePreloadStateChangedEventArgs.html">Efl.Gfx.ImageImagePreloadStateChangedEventArgs</a></p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Ui_WidgetPartBg_ImageResizedEvent" data-uid="Efl.Ui.WidgetPartBg.ImageResizedEvent">ImageResizedEvent</h4>
  <div class="markdown level1 summary"><p>Image was resized (its pixel data). The event data is the image's new size.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler&lt;ImageImageResizedEventArgs&gt; ImageResizedEvent</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.EventHandler&lt;Efl.Gfx.ImageImageResizedEventArgs&gt;</span></td>
        <td><p><a class="xref" href="Efl.Gfx.ImageImageResizedEventArgs.html">Efl.Gfx.ImageImageResizedEventArgs</a></p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="implements">Implements</h3>
  <div>
      <a class="xref" href="Efl.Ui.IPropertyBind.html">Efl.Ui.IPropertyBind</a>
  </div>
  <div>
      <a class="xref" href="Efl.IFile.html">Efl.IFile</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IColor.html">Efl.Gfx.IColor</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IImage.html">Efl.Gfx.IImage</a>
  </div>
  <div>
      <a class="xref" href="Efl.Eo.IWrapper.html">Efl.Eo.IWrapper</a>
  </div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
