<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class Efl.Canvas.ImageInternal
   </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class Efl.Canvas.ImageInternal
   ">
    <meta name="generator" content="docfx 2.40.4.0">
    
    <link rel="shortcut icon" href="../e-logo-title.png">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../e-logo-title.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Efl.Canvas.ImageInternal">
  
  
  <h1 id="Efl_Canvas_ImageInternal" data-uid="Efl.Canvas.ImageInternal" class="text-break">Class Efl.Canvas.ImageInternal
  </h1>
  <div class="markdown level0 summary"><p>Efl canvas internal image class</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="remarks">
  <h5 id="Efl_Canvas_ImageInternal_remarks"><strong>Remarks</strong></h5>
  <p>This is a <strong>BETA</strong> class. It can be modified or removed in the future. Do not use it for product development.</p>

  </div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><span class="xref">System.Object</span></div>
    <div class="level1"><a class="xref" href="Efl.Eo.EoWrapper.html">Efl.Eo.EoWrapper</a></div>
    <div class="level2"><a class="xref" href="Efl.Object.html">Efl.Object</a></div>
    <div class="level3"><a class="xref" href="Efl.LoopConsumer.html">Efl.LoopConsumer</a></div>
    <div class="level4"><a class="xref" href="Efl.Canvas.Object.html">Efl.Canvas.Object</a></div>
    <div class="level5"><span class="xref"><b>Efl.Canvas.ImageInternal</b></span></div>
      <div class="level6"><a class="xref" href="Efl.Canvas.Image.html">Efl.Canvas.Image</a></div>
      <div class="level6"><a class="xref" href="Efl.Canvas.Proxy.html">Efl.Canvas.Proxy</a></div>
      <div class="level6"><a class="xref" href="Efl.Canvas.Snapshot.html">Efl.Canvas.Snapshot</a></div>
      <div class="level6"><a class="xref" href="Efl.Canvas.Surface.html">Efl.Canvas.Surface</a></div>
  </div>
  
  <h5 id="Efl_Canvas_ImageInternal_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public abstract class ImageInternal : Object, IPointer, IEvents, IColor, IEntity, IHint, IMapping, IStack, IInterface, II18n, IFileSave, IInternal, IBuffer, IFill, IFilter, IImage, IImageOrientable, IView, IWrapper, IDisposable</code></pre>
  </div>
  <h3 id="constructors">Constructors
  </h3>
  
  
  <a id="Efl_Canvas_ImageInternal__ctor_" data-uid="Efl.Canvas.ImageInternal.#ctor*"></a>
  <h4 id="Efl_Canvas_ImageInternal__ctor_Efl_Eo_EoWrapper_ConstructingHandle_" data-uid="Efl.Canvas.ImageInternal.#ctor(Efl.Eo.EoWrapper.ConstructingHandle)">ImageInternal(EoWrapper.ConstructingHandle)</h4>
  <div class="markdown level1 summary"><p>Subclasses should override this constructor if they are expected to be instantiated from native code.
Do not call this constructor directly.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected ImageInternal(EoWrapper.ConstructingHandle ch)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Eo.EoWrapper.ConstructingHandle.html">Efl.Eo.EoWrapper.ConstructingHandle</a></td>
        <td><span class="parametername">ch</span></td>
        <td><p>Tag struct storing the native handle of the object being constructed.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal__ctor_" data-uid="Efl.Canvas.ImageInternal.#ctor*"></a>
  <h4 id="Efl_Canvas_ImageInternal__ctor_Efl_Object_" data-uid="Efl.Canvas.ImageInternal.#ctor(Efl.Object)">ImageInternal(Object)</h4>
  <div class="markdown level1 summary"><p>Initializes a new instance of the <a class="xref" href="Efl.Canvas.ImageInternal.html">Efl.Canvas.ImageInternal</a> class.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ImageInternal(Object parent = null)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Object.html">Efl.Object</a></td>
        <td><span class="parametername">parent</span></td>
        <td><p>Parent instance.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="properties">Properties
  </h3>
  
  
  <a id="Efl_Canvas_ImageInternal_Alpha_" data-uid="Efl.Canvas.ImageInternal.Alpha*"></a>
  <h4 id="Efl_Canvas_ImageInternal_Alpha" data-uid="Efl.Canvas.ImageInternal.Alpha">Alpha</h4>
  <div class="markdown level1 summary"><p>Indicates whether the alpha channel should be used.
This does not indicate whether the image source file contains an alpha channel, only whether to respect it or discard it.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool Alpha { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether to use alpha channel (<code>true</code>) data or not (<code>false</code>).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_BorderCenterFill_" data-uid="Efl.Canvas.ImageInternal.BorderCenterFill*"></a>
  <h4 id="Efl_Canvas_ImageInternal_BorderCenterFill" data-uid="Efl.Canvas.ImageInternal.BorderCenterFill">BorderCenterFill</h4>
  <div class="markdown level1 summary"><p>Specifies how the center part of the object (not the borders) should be drawn when EFL is rendering it.
This function sets how the center part of the image object's source image is to be drawn, which must be one of the values in <a class="xref" href="Efl.Gfx.BorderFillMode.html">Efl.Gfx.BorderFillMode</a>. By center we mean the complementary part of that defined by <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>. This is very useful for making frames and decorations. You would most probably also be using a filled image (as in <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_FillAuto">Efl.Gfx.IFill.FillAuto</a>) to use as a frame.</p>
<p>The default value is <a class="xref" href="Efl.Gfx.BorderFillMode.html#Efl_Gfx_BorderFillMode_Default">Efl.Gfx.BorderFillMode.Default</a>, ie. render and scale the center area, respecting its transparency.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BorderFillMode BorderCenterFill { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.BorderFillMode.html">Efl.Gfx.BorderFillMode</a></td>
        <td><p>Fill mode of the center region.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_BorderScale_" data-uid="Efl.Canvas.ImageInternal.BorderScale*"></a>
  <h4 id="Efl_Canvas_ImageInternal_BorderScale" data-uid="Efl.Canvas.ImageInternal.BorderScale">BorderScale</h4>
  <div class="markdown level1 summary"><p>Scaling factor applied to the image borders.
This value multiplies the size of the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a> when scaling an object.</p>
<p>Default value is 1.0 (no scaling).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public double BorderScale { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><p>The scale factor.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_BufferSize_" data-uid="Efl.Canvas.ImageInternal.BufferSize*"></a>
  <h4 id="Efl_Canvas_ImageInternal_BufferSize" data-uid="Efl.Canvas.ImageInternal.BufferSize">BufferSize</h4>
  <div class="markdown level1 summary"><p>Rectangular size of the pixel buffer as allocated in memory.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Size2D BufferSize { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>Size of the buffer in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_Colorspace_" data-uid="Efl.Canvas.ImageInternal.Colorspace*"></a>
  <h4 id="Efl_Canvas_ImageInternal_Colorspace" data-uid="Efl.Canvas.ImageInternal.Colorspace">Colorspace</h4>
  <div class="markdown level1 summary"><p>The colorspace defines how pixels are encoded in the image in memory.
By default, images are encoded in 32-bit BGRA, ie. each pixel takes 4 bytes in memory, with each channel B,G,R,A encoding the color with values from 0 to 255.</p>
<p>All images used in EFL use alpha-premultipied BGRA values, which means that for each pixel, B &lt;= A, G &lt;= A and R &lt;= A.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Colorspace Colorspace { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.Colorspace.html">Efl.Gfx.Colorspace</a></td>
        <td><p>Colorspace</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_ContentHint_" data-uid="Efl.Canvas.ImageInternal.ContentHint*"></a>
  <h4 id="Efl_Canvas_ImageInternal_ContentHint" data-uid="Efl.Canvas.ImageInternal.ContentHint">ContentHint</h4>
  <div class="markdown level1 summary"><p>Get the content hint setting of a given image object of the canvas.
This returns #EVAS_IMAGE_CONTENT_HINT_NONE on error.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ImageContentHint ContentHint { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageContentHint.html">Efl.Gfx.ImageContentHint</a></td>
        <td><p>Dynamic or static content hint, see <a class="xref" href="Efl.Gfx.ImageContentHint.html">Efl.Gfx.ImageContentHint</a></p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_ContentRegion_" data-uid="Efl.Canvas.ImageInternal.ContentRegion*"></a>
  <h4 id="Efl_Canvas_ImageInternal_ContentRegion" data-uid="Efl.Canvas.ImageInternal.ContentRegion">ContentRegion</h4>
  <div class="markdown level1 summary"><p>Return the relative area enclosed inside the image where content is expected.
We do expect content to be inside the limit defined by the border or inside the stretch region. If a stretch region is provided, the content region will encompass the non strechable area that are surrounded by stretchable area. If no border and no stretch region is set, they are assumed to be zero and the full object geometry is where content can be layout on top. The area size change with the object size.</p>
<p>The geometry of the area is expressed relative to the geometry of the object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Rect ContentRegion { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><p>A rectangle inside the object boundary that where content is expected.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_Fill_" data-uid="Efl.Canvas.ImageInternal.Fill*"></a>
  <h4 id="Efl_Canvas_ImageInternal_Fill" data-uid="Efl.Canvas.ImageInternal.Fill">Fill</h4>
  <div class="markdown level1 summary"><p>Specifies how to tile an image to fill its rectangle geometry.
Note that if <code>w</code> or <code>h</code> are smaller than the dimensions of the object, the displayed image will be tiled around the object's area. To have only one copy of the bound image drawn, <code>x</code> and <code>y</code> must be 0 and <code>w</code> and <code>h</code> need to be the exact width and height of the image object itself, respectively.</p>
<p>Setting this property will reset the <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_FillAuto">Efl.Gfx.IFill.FillAuto</a> to <code>false</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Rect Fill { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><p>The top-left corner to start drawing from as well as the size at which the bound image will be displayed.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_FillAuto_" data-uid="Efl.Canvas.ImageInternal.FillAuto*"></a>
  <h4 id="Efl_Canvas_ImageInternal_FillAuto" data-uid="Efl.Canvas.ImageInternal.FillAuto">FillAuto</h4>
  <div class="markdown level1 summary"><p>Binds the object's <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_Fill">Efl.Gfx.IFill.Fill</a> property to its actual geometry.
If <code>true</code>, then every time the object is resized, it will automatically trigger a call to <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_SetFill_Eina_Rect_">Efl.Gfx.IFill.SetFill(Eina.Rect)</a> with the new size (and 0, 0 as source image's origin), so the image will cover the whole object's area.</p>
<p>This property takes precedence over <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_Fill">Efl.Gfx.IFill.Fill</a>. If set to <code>false</code>, then <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_Fill">Efl.Gfx.IFill.Fill</a> should be set.</p>
<p>This flag is <code>true</code> by default (used to be <code>false</code> with the old APIs, and was known as &quot;filled&quot;).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool FillAuto { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> to make the fill property follow object size or <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_FilterChanged_" data-uid="Efl.Canvas.ImageInternal.FilterChanged*"></a>
  <h4 id="Efl_Canvas_ImageInternal_FilterChanged" data-uid="Efl.Canvas.ImageInternal.FilterChanged">FilterChanged</h4>
  <div class="markdown level1 summary"><p>Marks this filter as changed.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool FilterChanged { set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if filter changed, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_FilterInvalid_" data-uid="Efl.Canvas.ImageInternal.FilterInvalid*"></a>
  <h4 id="Efl_Canvas_ImageInternal_FilterInvalid" data-uid="Efl.Canvas.ImageInternal.FilterInvalid">FilterInvalid</h4>
  <div class="markdown level1 summary"><p>Marks this filter as invalid.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool FilterInvalid { set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> if filter is invalid, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_FilterOutputBuffer_" data-uid="Efl.Canvas.ImageInternal.FilterOutputBuffer*"></a>
  <h4 id="Efl_Canvas_ImageInternal_FilterOutputBuffer" data-uid="Efl.Canvas.ImageInternal.FilterOutputBuffer">FilterOutputBuffer</h4>
  <div class="markdown level1 summary"><p>Retrieve cached output buffer, if any.
Does not increment the reference count.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public IntPtr FilterOutputBuffer { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.IntPtr</span></td>
        <td><p>Output buffer</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_ImageLoadError_" data-uid="Efl.Canvas.ImageInternal.ImageLoadError*"></a>
  <h4 id="Efl_Canvas_ImageInternal_ImageLoadError" data-uid="Efl.Canvas.ImageInternal.ImageLoadError">ImageLoadError</h4>
  <div class="markdown level1 summary"><p>Gets the (last) file loading error for a given object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Error ImageLoadError { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Error.html">Eina.Error</a></td>
        <td><p>The load error code.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_ImageOrientation_" data-uid="Efl.Canvas.ImageInternal.ImageOrientation*"></a>
  <h4 id="Efl_Canvas_ImageInternal_ImageOrientation" data-uid="Efl.Canvas.ImageInternal.ImageOrientation">ImageOrientation</h4>
  <div class="markdown level1 summary"><p>Control the orientation (rotation and flipping) of a visual object.
This can be used to set the rotation on an image or a window, for instance.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ImageOrientation ImageOrientation { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageOrientation.html">Efl.Gfx.ImageOrientation</a></td>
        <td><p>The final orientation of the object.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_ImageSize_" data-uid="Efl.Canvas.ImageInternal.ImageSize*"></a>
  <h4 id="Efl_Canvas_ImageInternal_ImageSize" data-uid="Efl.Canvas.ImageInternal.ImageSize">ImageSize</h4>
  <div class="markdown level1 summary"><p>This represents the size of the original image in pixels.
This may be different from the actual geometry on screen or even the size of the loaded pixel buffer. This is the size of the image as stored in the original file.</p>
<p>This is a read-only property, and may return 0x0.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Size2D ImageSize { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>The size in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_Ratio_" data-uid="Efl.Canvas.ImageInternal.Ratio*"></a>
  <h4 id="Efl_Canvas_ImageInternal_Ratio" data-uid="Efl.Canvas.ImageInternal.Ratio">Ratio</h4>
  <div class="markdown level1 summary"><p>The native width/height ratio of the image.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public double Ratio { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><p>The image's ratio.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_ScaleHint_" data-uid="Efl.Canvas.ImageInternal.ScaleHint*"></a>
  <h4 id="Efl_Canvas_ImageInternal_ScaleHint" data-uid="Efl.Canvas.ImageInternal.ScaleHint">ScaleHint</h4>
  <div class="markdown level1 summary"><p>Get the scale hint of a given image of the canvas.
This function returns the scale hint value of the given image object of the canvas.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ImageScaleHint ScaleHint { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleHint.html">Efl.Gfx.ImageScaleHint</a></td>
        <td><p>Scalable or static size hint, see <a class="xref" href="Efl.Gfx.ImageScaleHint.html">Efl.Gfx.ImageScaleHint</a></p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_ScaleType_" data-uid="Efl.Canvas.ImageInternal.ScaleType*"></a>
  <h4 id="Efl_Canvas_ImageInternal_ScaleType" data-uid="Efl.Canvas.ImageInternal.ScaleType">ScaleType</h4>
  <div class="markdown level1 summary"><p>Control how the image is scaled.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ImageScaleType ScaleType { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleType.html">Efl.Gfx.ImageScaleType</a></td>
        <td><p>Image scale type</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SmoothScale_" data-uid="Efl.Canvas.ImageInternal.SmoothScale*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SmoothScale" data-uid="Efl.Canvas.ImageInternal.SmoothScale">SmoothScale</h4>
  <div class="markdown level1 summary"><p>Whether to use high-quality image scaling algorithm for this image.
When enabled, a higher quality image scaling algorithm is used when scaling images to sizes other than the source image's original one. This gives better results but is more computationally expensive.</p>
<p><code>true</code> by default</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool SmoothScale { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether to use smooth scale or not.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_Stride_" data-uid="Efl.Canvas.ImageInternal.Stride*"></a>
  <h4 id="Efl_Canvas_ImageInternal_Stride" data-uid="Efl.Canvas.ImageInternal.Stride">Stride</h4>
  <div class="markdown level1 summary"><p>Length in bytes of one row of pixels in memory.
Usually this will be equal to width * 4, with a plain BGRA image. This may return 0 if the stride is not applicable.</p>
<p>When applicable, this will include the <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_GetBufferBorders_System_UInt32__System_UInt32__System_UInt32__System_UInt32__">Efl.Gfx.IBuffer.GetBufferBorders(out System.UInt32, out System.UInt32, out System.UInt32, out System.UInt32)</a> as well as potential extra padding.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int Stride { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>Stride</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_ViewSize_" data-uid="Efl.Canvas.ImageInternal.ViewSize*"></a>
  <h4 id="Efl_Canvas_ImageInternal_ViewSize" data-uid="Efl.Canvas.ImageInternal.ViewSize">ViewSize</h4>
  <div class="markdown level1 summary"><p>The dimensions of this object's viewport.
This property represents the size of an image (file on disk, vector graphics, GL or 3D scene, ...) view: this is the logical size of a view, not the number of pixels in the buffer, nor its visible size on the window.</p>
<p>For scalable scenes (vector graphics, 3D or GL), this means scaling the contents of the scene and drawing more pixels as a result; For pixmaps this means zooming and stretching up or down the backing buffer to fit this view.</p>
<p>In most cases the view should have the same dimensions as the object on the canvas, for best quality.</p>
<p><a class="xref" href="Efl.Gfx.IView.html#Efl_Gfx_IView_SetViewSize_Eina_Size2D_">Efl.Gfx.IView.SetViewSize(Eina.Size2D)</a> may not be implemented. If it is, it might trigger a complete recalculation of the scene, or reload of the pixel data.</p>
<p>Refer to each implementing class specific documentation for more details.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Size2D ViewSize { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>Size of the view.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="Efl_Canvas_ImageInternal_AddBufferUpdate_" data-uid="Efl.Canvas.ImageInternal.AddBufferUpdate*"></a>
  <h4 id="Efl_Canvas_ImageInternal_AddBufferUpdate_Eina_Rect__" data-uid="Efl.Canvas.ImageInternal.AddBufferUpdate(Eina.Rect@)">AddBufferUpdate(ref Rect)</h4>
  <div class="markdown level1 summary"><p>Mark a sub-region of the given image object to be redrawn.
This function schedules a particular rectangular region of an image object to be updated (redrawn) at the next rendering cycle.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void AddBufferUpdate(ref Rect region)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><span class="parametername">region</span></td>
        <td><p>The updated region.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_BufferMap_" data-uid="Efl.Canvas.ImageInternal.BufferMap*"></a>
  <h4 id="Efl_Canvas_ImageInternal_BufferMap_Efl_Gfx_BufferAccessMode_Eina_Rect__Efl_Gfx_Colorspace_System_Int32_System_Int32__" data-uid="Efl.Canvas.ImageInternal.BufferMap(Efl.Gfx.BufferAccessMode,Eina.Rect@,Efl.Gfx.Colorspace,System.Int32,System.Int32@)">BufferMap(BufferAccessMode, ref Rect, Colorspace, Int32, out Int32)</h4>
  <div class="markdown level1 summary"><p>Map a region of this buffer for read or write access by the CPU.
Fetches data from the GPU if needed. This operation may be slow if cpu_readable_fast or cpu_writeable_fast are not true, or if the required colorspace is different from the internal one.</p>
<p>Note that if the buffer has <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_GetBufferBorders_System_UInt32__System_UInt32__System_UInt32__System_UInt32__">Efl.Gfx.IBuffer.GetBufferBorders(out System.UInt32, out System.UInt32, out System.UInt32, out System.UInt32)</a>, then <code>x</code> and <code>y</code> may be negative.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual RwSlice BufferMap(BufferAccessMode mode, ref Rect region, Colorspace cspace, int plane, out int stride)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.BufferAccessMode.html">Efl.Gfx.BufferAccessMode</a></td>
        <td><span class="parametername">mode</span></td>
        <td><p>Specifies whether to map for read-only, write-only or read-write access (OR combination of flags).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><span class="parametername">region</span></td>
        <td><p>The region to map.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Gfx.Colorspace.html">Efl.Gfx.Colorspace</a></td>
        <td><span class="parametername">cspace</span></td>
        <td><p>Requested colorspace. If different from the internal cspace, map should try to convert the data into a new buffer. argb8888 by default.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">plane</span></td>
        <td><p>Plane ID. 0 by default. Useful for planar formats only.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">stride</span></td>
        <td><p>Returns the length in bytes of a mapped line</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.RwSlice.html">Eina.RwSlice</a></td>
        <td><p>The data slice. In case of failure, the memory pointer will be <code>null</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_BufferUnmap_" data-uid="Efl.Canvas.ImageInternal.BufferUnmap*"></a>
  <h4 id="Efl_Canvas_ImageInternal_BufferUnmap_Eina_RwSlice_" data-uid="Efl.Canvas.ImageInternal.BufferUnmap(Eina.RwSlice)">BufferUnmap(RwSlice)</h4>
  <div class="markdown level1 summary"><p>Unmap a region of this buffer, and update the internal data if needed.
EFL will update the internal image if the map had write access.</p>
<p>Note: The <code>slice</code> struct does not need to be the one returned by <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_BufferMap_Efl_Gfx_BufferAccessMode_Eina_Rect__Efl_Gfx_Colorspace_System_Int32_System_Int32__">Efl.Gfx.IBuffer.BufferMap(Efl.Gfx.BufferAccessMode, ref Eina.Rect, Efl.Gfx.Colorspace, System.Int32, out System.Int32)</a>, only its contents (<code>mem</code> and <code>len</code>) must match. But after a call to <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_BufferUnmap_Eina_RwSlice_">Efl.Gfx.IBuffer.BufferUnmap(Eina.RwSlice)</a> the original <code>slice</code> structure is not valid anymore.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool BufferUnmap(RwSlice slice)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.RwSlice.html">Eina.RwSlice</a></td>
        <td><span class="parametername">slice</span></td>
        <td><p>Data slice returned by a previous call to map.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> on success, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_FilterDirty_" data-uid="Efl.Canvas.ImageInternal.FilterDirty*"></a>
  <h4 id="Efl_Canvas_ImageInternal_FilterDirty" data-uid="Efl.Canvas.ImageInternal.FilterDirty">FilterDirty()</h4>
  <div class="markdown level1 summary"><p>Called when filter changes must trigger a redraw of the object.
Virtual, to be implemented in the parent class.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void FilterDirty()</code></pre>
  </div>
  
  
  <a id="Efl_Canvas_ImageInternal_FilterInputAlpha_" data-uid="Efl.Canvas.ImageInternal.FilterInputAlpha*"></a>
  <h4 id="Efl_Canvas_ImageInternal_FilterInputAlpha" data-uid="Efl.Canvas.ImageInternal.FilterInputAlpha">FilterInputAlpha()</h4>
  <div class="markdown level1 summary"><p>Called by Efl.Canvas.Filter.Internal to determine whether the input is alpha or rgba.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool FilterInputAlpha()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> on success, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_FilterInputRender_" data-uid="Efl.Canvas.ImageInternal.FilterInputRender*"></a>
  <h4 id="Efl_Canvas_ImageInternal_FilterInputRender_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_System_Int32_System_Int32_System_Int32_System_Int32_System_Int32_System_Int32_System_Boolean_" data-uid="Efl.Canvas.ImageInternal.FilterInputRender(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">FilterInputRender(IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, Int32, Int32, Int32, Int32, Int32, Int32, Boolean)</h4>
  <div class="markdown level1 summary"><p>Called by Efl.Canvas.Filter.Internal when the parent class must render the input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool FilterInputRender(IntPtr filter, IntPtr engine, IntPtr output, IntPtr drawctx, IntPtr data, int l, int r, int t, int b, int x, int y, bool do_async)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.IntPtr</span></td>
        <td><span class="parametername">filter</span></td>
        <td><p>Current filter context</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.IntPtr</span></td>
        <td><span class="parametername">engine</span></td>
        <td><p>Engine context</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.IntPtr</span></td>
        <td><span class="parametername">output</span></td>
        <td><p>Output context</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.IntPtr</span></td>
        <td><span class="parametername">drawctx</span></td>
        <td><p>Draw context (for evas engine)</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.IntPtr</span></td>
        <td><span class="parametername">data</span></td>
        <td><p>Private data used by textblock</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">l</span></td>
        <td><p>Left</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">r</span></td>
        <td><p>Right</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">t</span></td>
        <td><p>Top</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">b</span></td>
        <td><p>Bottom</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">x</span></td>
        <td><p>X offset</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">y</span></td>
        <td><p>Y offset</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">do_async</span></td>
        <td><p><code>true</code> when the operation should be done asynchronously, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Indicates success from the object render function.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_FilterStatePrepare_" data-uid="Efl.Canvas.ImageInternal.FilterStatePrepare*"></a>
  <h4 id="Efl_Canvas_ImageInternal_FilterStatePrepare_Efl_Canvas_Filter_State__System_IntPtr_" data-uid="Efl.Canvas.ImageInternal.FilterStatePrepare(Efl.Canvas.Filter.State@,System.IntPtr)">FilterStatePrepare(out State, IntPtr)</h4>
  <div class="markdown level1 summary"><p>Called by Efl.Canvas.Filter.Internal to request the parent class for state information (color, etc...).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void FilterStatePrepare(out State state, IntPtr data)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Canvas.Filter.State.html">Efl.Canvas.Filter.State</a></td>
        <td><span class="parametername">state</span></td>
        <td><p>State info to fill in</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.IntPtr</span></td>
        <td><span class="parametername">data</span></td>
        <td><p>Private data for the class</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetAlpha_" data-uid="Efl.Canvas.ImageInternal.GetAlpha*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetAlpha" data-uid="Efl.Canvas.ImageInternal.GetAlpha">GetAlpha()</h4>
  <div class="markdown level1 summary"><p>Retrieve whether alpha channel data is used on this object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetAlpha()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether to use alpha channel (<code>true</code>) data or not (<code>false</code>).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetBorder_" data-uid="Efl.Canvas.ImageInternal.GetBorder*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__" data-uid="Efl.Canvas.ImageInternal.GetBorder(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">GetBorder(out Int32, out Int32, out Int32, out Int32)</h4>
  <div class="markdown level1 summary"><p>Dimensions of this image's border, a region that does not scale with the center area.
When EFL renders an image, its source may be scaled to fit the size of the object. This function sets an area from the borders of the image inwards which is not to be scaled. This function is useful for making frames and for widget theming, where, for example, buttons may be of varying sizes, but their border size must remain constant.</p>
<p>The units used for <code>l</code>, <code>r</code>, <code>t</code> and <code>b</code> are canvas units (pixels).</p>
<p>Note: The border region itself may be scaled by the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_SetBorderScale_System_Double_">Efl.Gfx.IImage.SetBorderScale(System.Double)</a> function.</p>
<p>Note: By default, image objects have no borders set, i.e. <code>l</code>, <code>r</code>, <code>t</code> and <code>b</code> start as 0.</p>
<p>Note: Similar to the concepts of 9-patch images or cap insets.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetBorder(out int l, out int r, out int t, out int b)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">l</span></td>
        <td><p>The border's left width.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">r</span></td>
        <td><p>The border's right width.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">t</span></td>
        <td><p>The border's top height.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">b</span></td>
        <td><p>The border's bottom height.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetBorderCenterFill_" data-uid="Efl.Canvas.ImageInternal.GetBorderCenterFill*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetBorderCenterFill" data-uid="Efl.Canvas.ImageInternal.GetBorderCenterFill">GetBorderCenterFill()</h4>
  <div class="markdown level1 summary"><p>Specifies how the center part of the object (not the borders) should be drawn when EFL is rendering it.
This function sets how the center part of the image object's source image is to be drawn, which must be one of the values in <a class="xref" href="Efl.Gfx.BorderFillMode.html">Efl.Gfx.BorderFillMode</a>. By center we mean the complementary part of that defined by <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>. This is very useful for making frames and decorations. You would most probably also be using a filled image (as in <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_FillAuto">Efl.Gfx.IFill.FillAuto</a>) to use as a frame.</p>
<p>The default value is <a class="xref" href="Efl.Gfx.BorderFillMode.html#Efl_Gfx_BorderFillMode_Default">Efl.Gfx.BorderFillMode.Default</a>, ie. render and scale the center area, respecting its transparency.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual BorderFillMode GetBorderCenterFill()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.BorderFillMode.html">Efl.Gfx.BorderFillMode</a></td>
        <td><p>Fill mode of the center region.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetBorderScale_" data-uid="Efl.Canvas.ImageInternal.GetBorderScale*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetBorderScale" data-uid="Efl.Canvas.ImageInternal.GetBorderScale">GetBorderScale()</h4>
  <div class="markdown level1 summary"><p>Scaling factor applied to the image borders.
This value multiplies the size of the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a> when scaling an object.</p>
<p>Default value is 1.0 (no scaling).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual double GetBorderScale()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><p>The scale factor.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetBufferBorders_" data-uid="Efl.Canvas.ImageInternal.GetBufferBorders*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetBufferBorders_System_UInt32__System_UInt32__System_UInt32__System_UInt32__" data-uid="Efl.Canvas.ImageInternal.GetBufferBorders(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">GetBufferBorders(out UInt32, out UInt32, out UInt32, out UInt32)</h4>
  <div class="markdown level1 summary"><p>Duplicated pixel borders inside this buffer.
Internally, EFL may require an image to have its border pixels duplicated, in particular for GL textures. This property exposes the internal duplicated borders to allow calling <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_BufferMap_Efl_Gfx_BufferAccessMode_Eina_Rect__Efl_Gfx_Colorspace_System_Int32_System_Int32__">Efl.Gfx.IBuffer.BufferMap(Efl.Gfx.BufferAccessMode, ref Eina.Rect, Efl.Gfx.Colorspace, System.Int32, out System.Int32)</a> with the entire pixel data, including those edge pixels.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetBufferBorders(out uint l, out uint r, out uint t, out uint b)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">l</span></td>
        <td><p>Left border pixels, usually 0 or 1</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">r</span></td>
        <td><p>Right border pixels, usually 0 or 1</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">t</span></td>
        <td><p>Top border pixels, usually 0 or 1</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">b</span></td>
        <td><p>Bottom border pixels, usually 0 or 1</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetBufferManaged_" data-uid="Efl.Canvas.ImageInternal.GetBufferManaged*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetBufferManaged_System_Int32_" data-uid="Efl.Canvas.ImageInternal.GetBufferManaged(System.Int32)">GetBufferManaged(Int32)</h4>
  <div class="markdown level1 summary"><p>Get a direct pointer to the internal pixel data, if available.
This will return <code>null</code> unless <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_SetBufferManaged_Eina_Slice_Eina_Size2D_System_Int32_Efl_Gfx_Colorspace_System_Int32_">Efl.Gfx.IBuffer.SetBufferManaged(Eina.Slice, Eina.Size2D, System.Int32, Efl.Gfx.Colorspace, System.Int32)</a> was used to pass in an external data pointer.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Slice GetBufferManaged(int plane)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">plane</span></td>
        <td><p>Plane ID. 0 by default. Useful for planar formats only.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Slice.html">Eina.Slice</a></td>
        <td><p>The data slice. The memory pointer will be <code>null</code> in case of failure.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetBufferSize_" data-uid="Efl.Canvas.ImageInternal.GetBufferSize*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetBufferSize" data-uid="Efl.Canvas.ImageInternal.GetBufferSize">GetBufferSize()</h4>
  <div class="markdown level1 summary"><p>Rectangular size of the pixel buffer as allocated in memory.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Size2D GetBufferSize()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>Size of the buffer in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetColorspace_" data-uid="Efl.Canvas.ImageInternal.GetColorspace*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetColorspace" data-uid="Efl.Canvas.ImageInternal.GetColorspace">GetColorspace()</h4>
  <div class="markdown level1 summary"><p>Returns the current encoding of this buffer's pixels.
See <a class="xref" href="Efl.Gfx.Colorspace.html">Efl.Gfx.Colorspace</a> for more information on the supported formats.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Colorspace GetColorspace()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.Colorspace.html">Efl.Gfx.Colorspace</a></td>
        <td><p>Colorspace</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetContentHint_" data-uid="Efl.Canvas.ImageInternal.GetContentHint*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetContentHint" data-uid="Efl.Canvas.ImageInternal.GetContentHint">GetContentHint()</h4>
  <div class="markdown level1 summary"><p>Get the content hint setting of a given image object of the canvas.
This returns #EVAS_IMAGE_CONTENT_HINT_NONE on error.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual ImageContentHint GetContentHint()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageContentHint.html">Efl.Gfx.ImageContentHint</a></td>
        <td><p>Dynamic or static content hint, see <a class="xref" href="Efl.Gfx.ImageContentHint.html">Efl.Gfx.ImageContentHint</a></p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetContentRegion_" data-uid="Efl.Canvas.ImageInternal.GetContentRegion*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetContentRegion" data-uid="Efl.Canvas.ImageInternal.GetContentRegion">GetContentRegion()</h4>
  <div class="markdown level1 summary"><p>Return the relative area enclosed inside the image where content is expected.
We do expect content to be inside the limit defined by the border or inside the stretch region. If a stretch region is provided, the content region will encompass the non strechable area that are surrounded by stretchable area. If no border and no stretch region is set, they are assumed to be zero and the full object geometry is where content can be layout on top. The area size change with the object size.</p>
<p>The geometry of the area is expressed relative to the geometry of the object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Rect GetContentRegion()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><p>A rectangle inside the object boundary that where content is expected.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetFill_" data-uid="Efl.Canvas.ImageInternal.GetFill*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetFill" data-uid="Efl.Canvas.ImageInternal.GetFill">GetFill()</h4>
  <div class="markdown level1 summary"><p>Specifies how to tile an image to fill its rectangle geometry.
Note that if <code>w</code> or <code>h</code> are smaller than the dimensions of the object, the displayed image will be tiled around the object's area. To have only one copy of the bound image drawn, <code>x</code> and <code>y</code> must be 0 and <code>w</code> and <code>h</code> need to be the exact width and height of the image object itself, respectively.</p>
<p>Setting this property will reset the <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_FillAuto">Efl.Gfx.IFill.FillAuto</a> to <code>false</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Rect GetFill()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><p>The top-left corner to start drawing from as well as the size at which the bound image will be displayed.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetFillAuto_" data-uid="Efl.Canvas.ImageInternal.GetFillAuto*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetFillAuto" data-uid="Efl.Canvas.ImageInternal.GetFillAuto">GetFillAuto()</h4>
  <div class="markdown level1 summary"><p>Binds the object's <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_Fill">Efl.Gfx.IFill.Fill</a> property to its actual geometry.
If <code>true</code>, then every time the object is resized, it will automatically trigger a call to <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_SetFill_Eina_Rect_">Efl.Gfx.IFill.SetFill(Eina.Rect)</a> with the new size (and 0, 0 as source image's origin), so the image will cover the whole object's area.</p>
<p>This property takes precedence over <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_Fill">Efl.Gfx.IFill.Fill</a>. If set to <code>false</code>, then <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_Fill">Efl.Gfx.IFill.Fill</a> should be set.</p>
<p>This flag is <code>true</code> by default (used to be <code>false</code> with the old APIs, and was known as &quot;filled&quot;).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetFillAuto()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> to make the fill property follow object size or <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetFilterData_" data-uid="Efl.Canvas.ImageInternal.GetFilterData*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetFilterData_System_String_System_String__System_Boolean__" data-uid="Efl.Canvas.ImageInternal.GetFilterData(System.String,System.String@,System.Boolean@)">GetFilterData(String, out String, out Boolean)</h4>
  <div class="markdown level1 summary"><p>Extra data used by the filter program.
Each data element is a string (<code>value</code>) stored as a global variable <code>name</code>. The program is then responsible for conversion to numbers, tables, etc...</p>
<p>If the <code>execute</code> flag is set, then the <code>value</code> can be complex and run, as if the original Lua program contained a line 'name = value'. This can be used to pass in tables.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetFilterData(string name, out string value, out bool execute)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">name</span></td>
        <td><p>Name of the global variable</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>String value to use as data</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">execute</span></td>
        <td><p>If <code>true</code>, execute 'name = value'</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetFilterOutputBuffer_" data-uid="Efl.Canvas.ImageInternal.GetFilterOutputBuffer*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetFilterOutputBuffer" data-uid="Efl.Canvas.ImageInternal.GetFilterOutputBuffer">GetFilterOutputBuffer()</h4>
  <div class="markdown level1 summary"><p>Retrieve cached output buffer, if any.
Does not increment the reference count.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual IntPtr GetFilterOutputBuffer()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.IntPtr</span></td>
        <td><p>Output buffer</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetFilterPadding_" data-uid="Efl.Canvas.ImageInternal.GetFilterPadding*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetFilterPadding_System_Int32__System_Int32__System_Int32__System_Int32__" data-uid="Efl.Canvas.ImageInternal.GetFilterPadding(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">GetFilterPadding(out Int32, out Int32, out Int32, out Int32)</h4>
  <div class="markdown level1 summary"><p>Gets the padding required to apply this filter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetFilterPadding(out int l, out int r, out int t, out int b)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">l</span></td>
        <td><p>Padding on the left</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">r</span></td>
        <td><p>Padding on the right</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">t</span></td>
        <td><p>Padding on the top</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">b</span></td>
        <td><p>Padding on the bottom</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetFilterProgram_" data-uid="Efl.Canvas.ImageInternal.GetFilterProgram*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetFilterProgram_System_String__System_String__" data-uid="Efl.Canvas.ImageInternal.GetFilterProgram(System.String@,System.String@)">GetFilterProgram(out String, out String)</h4>
  <div class="markdown level1 summary"><p>Gets the code of the filter program set on this object. May be <code>null</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetFilterProgram(out string code, out string name)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">code</span></td>
        <td><p>The Lua program source code.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">name</span></td>
        <td><p>An optional name for this filter.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetFilterSource_" data-uid="Efl.Canvas.ImageInternal.GetFilterSource*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetFilterSource_System_String_" data-uid="Efl.Canvas.ImageInternal.GetFilterSource(System.String)">GetFilterSource(String)</h4>
  <div class="markdown level1 summary"><p>Bind an object to use as a mask or texture in a filter program.
This will create automatically a new RGBA buffer containing the source object's pixels (as it is rendered).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual IEntity GetFilterSource(string name)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">name</span></td>
        <td><p>Buffer name as used in the program.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IEntity.html">Efl.Gfx.IEntity</a></td>
        <td><p>Object to use as a source of pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetFilterState_" data-uid="Efl.Canvas.ImageInternal.GetFilterState*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetFilterState_System_String__System_Double__System_String__System_Double__System_Double__" data-uid="Efl.Canvas.ImageInternal.GetFilterState(System.String@,System.Double@,System.String@,System.Double@,System.Double@)">GetFilterState(out String, out Double, out String, out Double, out Double)</h4>
  <div class="markdown level1 summary"><p>Set the current state of the filter.
This should be used by Edje (EFL's internal layout engine), but could also be used when implementing animations programmatically.</p>
<p>A full state is defined by two states (name + value): origin state and target state of an ongoing animation, as well as the <code>pos</code> progress (from 0 to 1) of that animation timeline. The second state can be omitted if there is no ongoing animation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetFilterState(out string cur_state, out double cur_val, out string next_state, out double next_val, out double pos)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">cur_state</span></td>
        <td><p>Current state of the filter</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cur_val</span></td>
        <td><p>Current value</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">next_state</span></td>
        <td><p>Next filter state, optional</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">next_val</span></td>
        <td><p>Next value, optional</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">pos</span></td>
        <td><p>Position, optional</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetImageLoadError_" data-uid="Efl.Canvas.ImageInternal.GetImageLoadError*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetImageLoadError" data-uid="Efl.Canvas.ImageInternal.GetImageLoadError">GetImageLoadError()</h4>
  <div class="markdown level1 summary"><p>Gets the (last) file loading error for a given object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Error GetImageLoadError()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Error.html">Eina.Error</a></td>
        <td><p>The load error code.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetImageOrientation_" data-uid="Efl.Canvas.ImageInternal.GetImageOrientation*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetImageOrientation" data-uid="Efl.Canvas.ImageInternal.GetImageOrientation">GetImageOrientation()</h4>
  <div class="markdown level1 summary"><p>Control the orientation (rotation and flipping) of a visual object.
This can be used to set the rotation on an image or a window, for instance.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual ImageOrientation GetImageOrientation()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageOrientation.html">Efl.Gfx.ImageOrientation</a></td>
        <td><p>The final orientation of the object.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetImageSize_" data-uid="Efl.Canvas.ImageInternal.GetImageSize*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetImageSize" data-uid="Efl.Canvas.ImageInternal.GetImageSize">GetImageSize()</h4>
  <div class="markdown level1 summary"><p>This represents the size of the original image in pixels.
This may be different from the actual geometry on screen or even the size of the loaded pixel buffer. This is the size of the image as stored in the original file.</p>
<p>This is a read-only property, and may return 0x0.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Size2D GetImageSize()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>The size in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetRatio_" data-uid="Efl.Canvas.ImageInternal.GetRatio*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetRatio" data-uid="Efl.Canvas.ImageInternal.GetRatio">GetRatio()</h4>
  <div class="markdown level1 summary"><p>Returns 1.0 if not applicable (eg. height = 0).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual double GetRatio()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><p>The image's ratio.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetScaleHint_" data-uid="Efl.Canvas.ImageInternal.GetScaleHint*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetScaleHint" data-uid="Efl.Canvas.ImageInternal.GetScaleHint">GetScaleHint()</h4>
  <div class="markdown level1 summary"><p>Get the scale hint of a given image of the canvas.
This function returns the scale hint value of the given image object of the canvas.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual ImageScaleHint GetScaleHint()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleHint.html">Efl.Gfx.ImageScaleHint</a></td>
        <td><p>Scalable or static size hint, see <a class="xref" href="Efl.Gfx.ImageScaleHint.html">Efl.Gfx.ImageScaleHint</a></p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetScaleType_" data-uid="Efl.Canvas.ImageInternal.GetScaleType*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetScaleType" data-uid="Efl.Canvas.ImageInternal.GetScaleType">GetScaleType()</h4>
  <div class="markdown level1 summary"><p>Control how the image is scaled.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual ImageScaleType GetScaleType()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleType.html">Efl.Gfx.ImageScaleType</a></td>
        <td><p>Image scale type</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetSmoothScale_" data-uid="Efl.Canvas.ImageInternal.GetSmoothScale*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetSmoothScale" data-uid="Efl.Canvas.ImageInternal.GetSmoothScale">GetSmoothScale()</h4>
  <div class="markdown level1 summary"><p>Whether to use high-quality image scaling algorithm for this image.
When enabled, a higher quality image scaling algorithm is used when scaling images to sizes other than the source image's original one. This gives better results but is more computationally expensive.</p>
<p><code>true</code> by default</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool GetSmoothScale()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether to use smooth scale or not.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetStretchRegion_" data-uid="Efl.Canvas.ImageInternal.GetStretchRegion*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetStretchRegion_Eina_Iterator_Efl_Gfx_Image_StretchRegion___Eina_Iterator_Efl_Gfx_Image_StretchRegion___" data-uid="Efl.Canvas.ImageInternal.GetStretchRegion(Eina.Iterator{Efl.Gfx.Image.StretchRegion}@,Eina.Iterator{Efl.Gfx.Image.StretchRegion}@)">GetStretchRegion(out Iterator&lt;StretchRegion&gt;, out Iterator&lt;StretchRegion&gt;)</h4>
  <div class="markdown level1 summary"><p>This property defines the stretchable pixels region of an image.
When the regions are set by the user, the method will walk the iterators once and then destroy them. When the regions are retrieved by the user, it is his responsibility to destroy the iterators.. It will remember the information for the lifetime of the object. It will ignore all value of <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>, <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_BorderScale">Efl.Gfx.IImage.BorderScale</a> and <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_BorderCenterFill">Efl.Gfx.IImage.BorderCenterFill</a> . To reset the object you can just pass <code>null</code> to both horizontal and vertical at the same time.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void GetStretchRegion(out Iterator&lt;StretchRegion&gt; horizontal, out Iterator&lt;StretchRegion&gt; vertical)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">Eina.Iterator&lt;Efl.Gfx.Image.StretchRegion&gt;</span></td>
        <td><span class="parametername">horizontal</span></td>
        <td><p>Representation of area that are stretchable in the image horizontal space.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">Eina.Iterator&lt;Efl.Gfx.Image.StretchRegion&gt;</span></td>
        <td><span class="parametername">vertical</span></td>
        <td><p>Representation of area that are stretchable in the image vertical space.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetStride_" data-uid="Efl.Canvas.ImageInternal.GetStride*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetStride" data-uid="Efl.Canvas.ImageInternal.GetStride">GetStride()</h4>
  <div class="markdown level1 summary"><p>Length in bytes of one row of pixels in memory.
Usually this will be equal to width * 4, with a plain BGRA image. This may return 0 if the stride is not applicable.</p>
<p>When applicable, this will include the <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_GetBufferBorders_System_UInt32__System_UInt32__System_UInt32__System_UInt32__">Efl.Gfx.IBuffer.GetBufferBorders(out System.UInt32, out System.UInt32, out System.UInt32, out System.UInt32)</a> as well as potential extra padding.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual int GetStride()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>Stride</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_GetViewSize_" data-uid="Efl.Canvas.ImageInternal.GetViewSize*"></a>
  <h4 id="Efl_Canvas_ImageInternal_GetViewSize" data-uid="Efl.Canvas.ImageInternal.GetViewSize">GetViewSize()</h4>
  <div class="markdown level1 summary"><p>The dimensions of this object's viewport.
This property represents the size of an image (file on disk, vector graphics, GL or 3D scene, ...) view: this is the logical size of a view, not the number of pixels in the buffer, nor its visible size on the window.</p>
<p>For scalable scenes (vector graphics, 3D or GL), this means scaling the contents of the scene and drawing more pixels as a result; For pixmaps this means zooming and stretching up or down the backing buffer to fit this view.</p>
<p>In most cases the view should have the same dimensions as the object on the canvas, for best quality.</p>
<p><a class="xref" href="Efl.Gfx.IView.html#Efl_Gfx_IView_SetViewSize_Eina_Size2D_">Efl.Gfx.IView.SetViewSize(Eina.Size2D)</a> may not be implemented. If it is, it might trigger a complete recalculation of the scene, or reload of the pixel data.</p>
<p>Refer to each implementing class specific documentation for more details.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Size2D GetViewSize()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>Size of the view.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_OnImagePreloadEvt_" data-uid="Efl.Canvas.ImageInternal.OnImagePreloadEvt*"></a>
  <h4 id="Efl_Canvas_ImageInternal_OnImagePreloadEvt_EventArgs_" data-uid="Efl.Canvas.ImageInternal.OnImagePreloadEvt(EventArgs)">OnImagePreloadEvt(EventArgs)</h4>
  <div class="markdown level1 summary"><p>Method to raise event ImagePreloadEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnImagePreloadEvt(EventArgs e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventArgs</span></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_OnImageResizeEvt_" data-uid="Efl.Canvas.ImageInternal.OnImageResizeEvt*"></a>
  <h4 id="Efl_Canvas_ImageInternal_OnImageResizeEvt_EventArgs_" data-uid="Efl.Canvas.ImageInternal.OnImageResizeEvt(EventArgs)">OnImageResizeEvt(EventArgs)</h4>
  <div class="markdown level1 summary"><p>Method to raise event ImageResizeEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnImageResizeEvt(EventArgs e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventArgs</span></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_OnImageUnloadEvt_" data-uid="Efl.Canvas.ImageInternal.OnImageUnloadEvt*"></a>
  <h4 id="Efl_Canvas_ImageInternal_OnImageUnloadEvt_EventArgs_" data-uid="Efl.Canvas.ImageInternal.OnImageUnloadEvt(EventArgs)">OnImageUnloadEvt(EventArgs)</h4>
  <div class="markdown level1 summary"><p>Method to raise event ImageUnloadEvt.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void OnImageUnloadEvt(EventArgs e)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventArgs</span></td>
        <td><span class="parametername">e</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_Save_" data-uid="Efl.Canvas.ImageInternal.Save*"></a>
  <h4 id="Efl_Canvas_ImageInternal_Save_System_String_System_String_Efl_FileSaveInfo__" data-uid="Efl.Canvas.ImageInternal.Save(System.String,System.String,Efl.FileSaveInfo@)">Save(String, String, ref FileSaveInfo)</h4>
  <div class="markdown level1 summary"><p>Save the given image object's contents to an (image) file.
The extension suffix on <code>file</code> will determine which saver module Evas is to use when saving, thus the final file's format. If the file supports multiple data stored in it (Eet ones), you can specify the key to be used as the index of the image in it.</p>
<p>You can specify some flags when saving the image.  Currently acceptable flags are <code>quality</code> and <code>compress</code>. Eg.: &quot;quality=100 compress=9&quot;.
(Since EFL 1.22)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool Save(string file, string key, ref FileSaveInfo info)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">file</span></td>
        <td><p>The filename to be used to save the image (extension obligatory).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The image key in the file (if an Eet one), or <code>null</code>, otherwise.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.FileSaveInfo.html">Efl.FileSaveInfo</a></td>
        <td><span class="parametername">info</span></td>
        <td><p>The flags to be used (<code>null</code> for defaults).</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> on success, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetAlpha_" data-uid="Efl.Canvas.ImageInternal.SetAlpha*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetAlpha_System_Boolean_" data-uid="Efl.Canvas.ImageInternal.SetAlpha(System.Boolean)">SetAlpha(Boolean)</h4>
  <div class="markdown level1 summary"><p>Change alpha channel usage for this object.
This function sets a flag on an image object indicating whether or not to use alpha channel data. A value of <code>true</code> makes it use alpha channel data, and <code>false</code> makes it ignore that data. Note that this has nothing to do with an object's color as manipulated by <a class="xref" href="Efl.Gfx.IColor.html#Efl_Gfx_IColor_GetColor_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IColor.GetColor(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetAlpha(bool alpha)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">alpha</span></td>
        <td><p>Whether to use alpha channel (<code>true</code>) data or not (<code>false</code>).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetBorder_" data-uid="Efl.Canvas.ImageInternal.SetBorder*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetBorder_System_Int32_System_Int32_System_Int32_System_Int32_" data-uid="Efl.Canvas.ImageInternal.SetBorder(System.Int32,System.Int32,System.Int32,System.Int32)">SetBorder(Int32, Int32, Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Dimensions of this image's border, a region that does not scale with the center area.
When EFL renders an image, its source may be scaled to fit the size of the object. This function sets an area from the borders of the image inwards which is not to be scaled. This function is useful for making frames and for widget theming, where, for example, buttons may be of varying sizes, but their border size must remain constant.</p>
<p>The units used for <code>l</code>, <code>r</code>, <code>t</code> and <code>b</code> are canvas units (pixels).</p>
<p>Note: The border region itself may be scaled by the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_SetBorderScale_System_Double_">Efl.Gfx.IImage.SetBorderScale(System.Double)</a> function.</p>
<p>Note: By default, image objects have no borders set, i.e. <code>l</code>, <code>r</code>, <code>t</code> and <code>b</code> start as 0.</p>
<p>Note: Similar to the concepts of 9-patch images or cap insets.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetBorder(int l, int r, int t, int b)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">l</span></td>
        <td><p>The border's left width.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">r</span></td>
        <td><p>The border's right width.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">t</span></td>
        <td><p>The border's top height.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">b</span></td>
        <td><p>The border's bottom height.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetBorderCenterFill_" data-uid="Efl.Canvas.ImageInternal.SetBorderCenterFill*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetBorderCenterFill_Efl_Gfx_BorderFillMode_" data-uid="Efl.Canvas.ImageInternal.SetBorderCenterFill(Efl.Gfx.BorderFillMode)">SetBorderCenterFill(BorderFillMode)</h4>
  <div class="markdown level1 summary"><p>Specifies how the center part of the object (not the borders) should be drawn when EFL is rendering it.
This function sets how the center part of the image object's source image is to be drawn, which must be one of the values in <a class="xref" href="Efl.Gfx.BorderFillMode.html">Efl.Gfx.BorderFillMode</a>. By center we mean the complementary part of that defined by <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>. This is very useful for making frames and decorations. You would most probably also be using a filled image (as in <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_FillAuto">Efl.Gfx.IFill.FillAuto</a>) to use as a frame.</p>
<p>The default value is <a class="xref" href="Efl.Gfx.BorderFillMode.html#Efl_Gfx_BorderFillMode_Default">Efl.Gfx.BorderFillMode.Default</a>, ie. render and scale the center area, respecting its transparency.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetBorderCenterFill(BorderFillMode fill)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.BorderFillMode.html">Efl.Gfx.BorderFillMode</a></td>
        <td><span class="parametername">fill</span></td>
        <td><p>Fill mode of the center region.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetBorderScale_" data-uid="Efl.Canvas.ImageInternal.SetBorderScale*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetBorderScale_System_Double_" data-uid="Efl.Canvas.ImageInternal.SetBorderScale(System.Double)">SetBorderScale(Double)</h4>
  <div class="markdown level1 summary"><p>Scaling factor applied to the image borders.
This value multiplies the size of the <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a> when scaling an object.</p>
<p>Default value is 1.0 (no scaling).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetBorderScale(double scale)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">scale</span></td>
        <td><p>The scale factor.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetBufferCopy_" data-uid="Efl.Canvas.ImageInternal.SetBufferCopy*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetBufferCopy_Eina_Slice_Eina_Size2D_System_Int32_Efl_Gfx_Colorspace_System_Int32_" data-uid="Efl.Canvas.ImageInternal.SetBufferCopy(Eina.Slice,Eina.Size2D,System.Int32,Efl.Gfx.Colorspace,System.Int32)">SetBufferCopy(Slice, Size2D, Int32, Colorspace, Int32)</h4>
  <div class="markdown level1 summary"><p>Set the pixels for this buffer by copying them, or allocate a new memory region.
This will allocate a new buffer in memory and copy the input <code>pixels</code> to it. The internal colorspace is not guaranteed to be preserved, and colorspace conversion may happen internally.</p>
<p>If <code>pixels</code> is <code>null</code>, then a new empty buffer will be allocated. If the buffer already had pixel data, the previous image data will be dropped. This is the same as <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_SetBufferManaged_Eina_Slice_Eina_Size2D_System_Int32_Efl_Gfx_Colorspace_System_Int32_">Efl.Gfx.IBuffer.SetBufferManaged(Eina.Slice, Eina.Size2D, System.Int32, Efl.Gfx.Colorspace, System.Int32)</a>.</p>
<p>The memory buffer <code>pixels</code> must be large enough to hold <code>width</code> x <code>height</code> pixels encoded in the colorspace <code>cspace</code>.</p>
<p><code>slice</code> should not be the return value of <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_GetBufferManaged_System_Int32_">Efl.Gfx.IBuffer.GetBufferManaged(System.Int32)</a>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool SetBufferCopy(Slice slice, Size2D size, int stride, Colorspace cspace, int plane)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Slice.html">Eina.Slice</a></td>
        <td><span class="parametername">slice</span></td>
        <td><p>If <code>null</code>, allocates an empty buffer</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>The size in pixels.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">stride</span></td>
        <td><p>If 0, automatically guessed from the <code>width</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Gfx.Colorspace.html">Efl.Gfx.Colorspace</a></td>
        <td><span class="parametername">cspace</span></td>
        <td><p>argb8888 by default.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">plane</span></td>
        <td><p>Plane ID. 0 by default. Useful for planar formats only.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> on success, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetBufferManaged_" data-uid="Efl.Canvas.ImageInternal.SetBufferManaged*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetBufferManaged_Eina_Slice_Eina_Size2D_System_Int32_Efl_Gfx_Colorspace_System_Int32_" data-uid="Efl.Canvas.ImageInternal.SetBufferManaged(Eina.Slice,Eina.Size2D,System.Int32,Efl.Gfx.Colorspace,System.Int32)">SetBufferManaged(Slice, Size2D, Int32, Colorspace, Int32)</h4>
  <div class="markdown level1 summary"><p>Set the pixels for this buffer, managed externally by the client.
EFL will use the pixel data directly, and update the GPU-side texture if required. This will mark the image as dirty. If <code>slice</code> is <code>null</code>, this will detach the pixel data.</p>
<p>If the buffer already had pixel data, the previous image data will be dropped. This is the same as <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_SetBufferCopy_Eina_Slice_Eina_Size2D_System_Int32_Efl_Gfx_Colorspace_System_Int32_">Efl.Gfx.IBuffer.SetBufferCopy(Eina.Slice, Eina.Size2D, System.Int32, Efl.Gfx.Colorspace, System.Int32)</a>.</p>
<p>The memory buffer <code>pixels</code> must be large enough to hold <code>width</code> x <code>height</code> pixels encoded in the colorspace <code>cspace</code>.</p>
<p>See also <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_SetBufferCopy_Eina_Slice_Eina_Size2D_System_Int32_Efl_Gfx_Colorspace_System_Int32_">Efl.Gfx.IBuffer.SetBufferCopy(Eina.Slice, Eina.Size2D, System.Int32, Efl.Gfx.Colorspace, System.Int32)</a> if you want EFL to copy the input buffer internally.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual bool SetBufferManaged(Slice slice, Size2D size, int stride, Colorspace cspace, int plane)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Slice.html">Eina.Slice</a></td>
        <td><span class="parametername">slice</span></td>
        <td><p>If <code>null</code>, detaches the previous buffer.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>The size in pixels.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">stride</span></td>
        <td><p>If 0, automatically guessed from the <code>width</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Gfx.Colorspace.html">Efl.Gfx.Colorspace</a></td>
        <td><span class="parametername">cspace</span></td>
        <td><p>argb8888 by default.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">plane</span></td>
        <td><p>Plane ID. 0 by default. Useful for planar formats only.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> on success, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetBufferSize_" data-uid="Efl.Canvas.ImageInternal.SetBufferSize*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetBufferSize_Eina_Size2D_" data-uid="Efl.Canvas.ImageInternal.SetBufferSize(Eina.Size2D)">SetBufferSize(Size2D)</h4>
  <div class="markdown level1 summary"><p>Potentially not implemented, <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_BufferSize">Efl.Gfx.IBuffer.BufferSize</a> may be read-only.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetBufferSize(Size2D sz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><span class="parametername">sz</span></td>
        <td><p>Size of the buffer in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetContentHint_" data-uid="Efl.Canvas.ImageInternal.SetContentHint*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetContentHint_Efl_Gfx_ImageContentHint_" data-uid="Efl.Canvas.ImageInternal.SetContentHint(Efl.Gfx.ImageContentHint)">SetContentHint(ImageContentHint)</h4>
  <div class="markdown level1 summary"><p>Set the content hint setting of a given image object of the canvas.
This function sets the content hint value of the given image of the canvas. For example, if you're on the GL engine and your driver implementation supports it, setting this hint to #EVAS_IMAGE_CONTENT_HINT_DYNAMIC will make it need zero copies at texture upload time, which is an &quot;expensive&quot; operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetContentHint(ImageContentHint hint)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageContentHint.html">Efl.Gfx.ImageContentHint</a></td>
        <td><span class="parametername">hint</span></td>
        <td><p>Dynamic or static content hint, see <a class="xref" href="Efl.Gfx.ImageContentHint.html">Efl.Gfx.ImageContentHint</a></p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetFill_" data-uid="Efl.Canvas.ImageInternal.SetFill*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetFill_Eina_Rect_" data-uid="Efl.Canvas.ImageInternal.SetFill(Eina.Rect)">SetFill(Rect)</h4>
  <div class="markdown level1 summary"><p>Specifies how to tile an image to fill its rectangle geometry.
Note that if <code>w</code> or <code>h</code> are smaller than the dimensions of the object, the displayed image will be tiled around the object's area. To have only one copy of the bound image drawn, <code>x</code> and <code>y</code> must be 0 and <code>w</code> and <code>h</code> need to be the exact width and height of the image object itself, respectively.</p>
<p>Setting this property will reset the <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_FillAuto">Efl.Gfx.IFill.FillAuto</a> to <code>false</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetFill(Rect fill)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><span class="parametername">fill</span></td>
        <td><p>The top-left corner to start drawing from as well as the size at which the bound image will be displayed.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetFillAuto_" data-uid="Efl.Canvas.ImageInternal.SetFillAuto*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetFillAuto_System_Boolean_" data-uid="Efl.Canvas.ImageInternal.SetFillAuto(System.Boolean)">SetFillAuto(Boolean)</h4>
  <div class="markdown level1 summary"><p>Binds the object's <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_Fill">Efl.Gfx.IFill.Fill</a> property to its actual geometry.
If <code>true</code>, then every time the object is resized, it will automatically trigger a call to <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_SetFill_Eina_Rect_">Efl.Gfx.IFill.SetFill(Eina.Rect)</a> with the new size (and 0, 0 as source image's origin), so the image will cover the whole object's area.</p>
<p>This property takes precedence over <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_Fill">Efl.Gfx.IFill.Fill</a>. If set to <code>false</code>, then <a class="xref" href="Efl.Gfx.IFill.html#Efl_Gfx_IFill_Fill">Efl.Gfx.IFill.Fill</a> should be set.</p>
<p>This flag is <code>true</code> by default (used to be <code>false</code> with the old APIs, and was known as &quot;filled&quot;).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetFillAuto(bool filled)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">filled</span></td>
        <td><p><code>true</code> to make the fill property follow object size or <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetFilterChanged_" data-uid="Efl.Canvas.ImageInternal.SetFilterChanged*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetFilterChanged_System_Boolean_" data-uid="Efl.Canvas.ImageInternal.SetFilterChanged(System.Boolean)">SetFilterChanged(Boolean)</h4>
  <div class="markdown level1 summary"><p>Marks this filter as changed.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetFilterChanged(bool val)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">val</span></td>
        <td><p><code>true</code> if filter changed, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetFilterData_" data-uid="Efl.Canvas.ImageInternal.SetFilterData*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetFilterData_System_String_System_String_System_Boolean_" data-uid="Efl.Canvas.ImageInternal.SetFilterData(System.String,System.String,System.Boolean)">SetFilterData(String, String, Boolean)</h4>
  <div class="markdown level1 summary"><p>Extra data used by the filter program.
Each data element is a string (<code>value</code>) stored as a global variable <code>name</code>. The program is then responsible for conversion to numbers, tables, etc...</p>
<p>If the <code>execute</code> flag is set, then the <code>value</code> can be complex and run, as if the original Lua program contained a line 'name = value'. This can be used to pass in tables.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetFilterData(string name, string value, bool execute)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">name</span></td>
        <td><p>Name of the global variable</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>String value to use as data</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">execute</span></td>
        <td><p>If <code>true</code>, execute 'name = value'</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetFilterInvalid_" data-uid="Efl.Canvas.ImageInternal.SetFilterInvalid*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetFilterInvalid_System_Boolean_" data-uid="Efl.Canvas.ImageInternal.SetFilterInvalid(System.Boolean)">SetFilterInvalid(Boolean)</h4>
  <div class="markdown level1 summary"><p>Marks this filter as invalid.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetFilterInvalid(bool val)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">val</span></td>
        <td><p><code>true</code> if filter is invalid, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetFilterProgram_" data-uid="Efl.Canvas.ImageInternal.SetFilterProgram*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetFilterProgram_System_String_System_String_" data-uid="Efl.Canvas.ImageInternal.SetFilterProgram(System.String,System.String)">SetFilterProgram(String, String)</h4>
  <div class="markdown level1 summary"><p>Set a graphical filter program on this object.
Valid for Text and Image objects at the moment.</p>
<p>The argument passed to this function is a string containing a valid Lua program based on the filters API as described in the &quot;EFL Graphics Filters&quot; reference page.</p>
<p>Set to <code>null</code> to disable filtering.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetFilterProgram(string code, string name)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">code</span></td>
        <td><p>The Lua program source code.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">name</span></td>
        <td><p>An optional name for this filter.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetFilterSource_" data-uid="Efl.Canvas.ImageInternal.SetFilterSource*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetFilterSource_System_String_Efl_Gfx_IEntity_" data-uid="Efl.Canvas.ImageInternal.SetFilterSource(System.String,Efl.Gfx.IEntity)">SetFilterSource(String, IEntity)</h4>
  <div class="markdown level1 summary"><p>Bind an object to use as a mask or texture in a filter program.
This will create automatically a new RGBA buffer containing the source object's pixels (as it is rendered).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetFilterSource(string name, IEntity source)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">name</span></td>
        <td><p>Buffer name as used in the program.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Gfx.IEntity.html">Efl.Gfx.IEntity</a></td>
        <td><span class="parametername">source</span></td>
        <td><p>Object to use as a source of pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetFilterState_" data-uid="Efl.Canvas.ImageInternal.SetFilterState*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetFilterState_System_String_System_Double_System_String_System_Double_System_Double_" data-uid="Efl.Canvas.ImageInternal.SetFilterState(System.String,System.Double,System.String,System.Double,System.Double)">SetFilterState(String, Double, String, Double, Double)</h4>
  <div class="markdown level1 summary"><p>Set the current state of the filter.
This should be used by Edje (EFL's internal layout engine), but could also be used when implementing animations programmatically.</p>
<p>A full state is defined by two states (name + value): origin state and target state of an ongoing animation, as well as the <code>pos</code> progress (from 0 to 1) of that animation timeline. The second state can be omitted if there is no ongoing animation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetFilterState(string cur_state, double cur_val, string next_state, double next_val, double pos)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">cur_state</span></td>
        <td><p>Current state of the filter</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">cur_val</span></td>
        <td><p>Current value</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">next_state</span></td>
        <td><p>Next filter state, optional</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">next_val</span></td>
        <td><p>Next value, optional</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">pos</span></td>
        <td><p>Position, optional</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetImageOrientation_" data-uid="Efl.Canvas.ImageInternal.SetImageOrientation*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetImageOrientation_Efl_Gfx_ImageOrientation_" data-uid="Efl.Canvas.ImageInternal.SetImageOrientation(Efl.Gfx.ImageOrientation)">SetImageOrientation(ImageOrientation)</h4>
  <div class="markdown level1 summary"><p>Control the orientation (rotation and flipping) of a visual object.
This can be used to set the rotation on an image or a window, for instance.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetImageOrientation(ImageOrientation dir)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageOrientation.html">Efl.Gfx.ImageOrientation</a></td>
        <td><span class="parametername">dir</span></td>
        <td><p>The final orientation of the object.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetScaleHint_" data-uid="Efl.Canvas.ImageInternal.SetScaleHint*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetScaleHint_Efl_Gfx_ImageScaleHint_" data-uid="Efl.Canvas.ImageInternal.SetScaleHint(Efl.Gfx.ImageScaleHint)">SetScaleHint(ImageScaleHint)</h4>
  <div class="markdown level1 summary"><p>Set the scale hint of a given image of the canvas.
This function sets the scale hint value of the given image object in the canvas, which will affect how Evas is to cache scaled versions of its original source image.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetScaleHint(ImageScaleHint hint)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleHint.html">Efl.Gfx.ImageScaleHint</a></td>
        <td><span class="parametername">hint</span></td>
        <td><p>Scalable or static size hint, see <a class="xref" href="Efl.Gfx.ImageScaleHint.html">Efl.Gfx.ImageScaleHint</a></p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetScaleType_" data-uid="Efl.Canvas.ImageInternal.SetScaleType*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetScaleType_Efl_Gfx_ImageScaleType_" data-uid="Efl.Canvas.ImageInternal.SetScaleType(Efl.Gfx.ImageScaleType)">SetScaleType(ImageScaleType)</h4>
  <div class="markdown level1 summary"><p>Control how the image is scaled.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetScaleType(ImageScaleType scale_type)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.ImageScaleType.html">Efl.Gfx.ImageScaleType</a></td>
        <td><span class="parametername">scale_type</span></td>
        <td><p>Image scale type</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetSmoothScale_" data-uid="Efl.Canvas.ImageInternal.SetSmoothScale*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetSmoothScale_System_Boolean_" data-uid="Efl.Canvas.ImageInternal.SetSmoothScale(System.Boolean)">SetSmoothScale(Boolean)</h4>
  <div class="markdown level1 summary"><p>Whether to use high-quality image scaling algorithm for this image.
When enabled, a higher quality image scaling algorithm is used when scaling images to sizes other than the source image's original one. This gives better results but is more computationally expensive.</p>
<p><code>true</code> by default</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetSmoothScale(bool smooth_scale)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">smooth_scale</span></td>
        <td><p>Whether to use smooth scale or not.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetStretchRegion_" data-uid="Efl.Canvas.ImageInternal.SetStretchRegion*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetStretchRegion_Eina_Iterator_Efl_Gfx_Image_StretchRegion__Eina_Iterator_Efl_Gfx_Image_StretchRegion__" data-uid="Efl.Canvas.ImageInternal.SetStretchRegion(Eina.Iterator{Efl.Gfx.Image.StretchRegion},Eina.Iterator{Efl.Gfx.Image.StretchRegion})">SetStretchRegion(Iterator&lt;StretchRegion&gt;, Iterator&lt;StretchRegion&gt;)</h4>
  <div class="markdown level1 summary"><p>This property defines the stretchable pixels region of an image.
When the regions are set by the user, the method will walk the iterators once and then destroy them. When the regions are retrieved by the user, it is his responsibility to destroy the iterators.. It will remember the information for the lifetime of the object. It will ignore all value of <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_GetBorder_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IImage.GetBorder(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>, <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_BorderScale">Efl.Gfx.IImage.BorderScale</a> and <a class="xref" href="Efl.Gfx.IImage.html#Efl_Gfx_IImage_BorderCenterFill">Efl.Gfx.IImage.BorderCenterFill</a> . To reset the object you can just pass <code>null</code> to both horizontal and vertical at the same time.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Error SetStretchRegion(Iterator&lt;StretchRegion&gt; horizontal, Iterator&lt;StretchRegion&gt; vertical)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">Eina.Iterator&lt;Efl.Gfx.Image.StretchRegion&gt;</span></td>
        <td><span class="parametername">horizontal</span></td>
        <td><p>Representation of area that are stretchable in the image horizontal space.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">Eina.Iterator&lt;Efl.Gfx.Image.StretchRegion&gt;</span></td>
        <td><span class="parametername">vertical</span></td>
        <td><p>Representation of area that are stretchable in the image vertical space.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Error.html">Eina.Error</a></td>
        <td><p>return an error code if the stretch_region provided are incorrect.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Canvas_ImageInternal_SetViewSize_" data-uid="Efl.Canvas.ImageInternal.SetViewSize*"></a>
  <h4 id="Efl_Canvas_ImageInternal_SetViewSize_Eina_Size2D_" data-uid="Efl.Canvas.ImageInternal.SetViewSize(Eina.Size2D)">SetViewSize(Size2D)</h4>
  <div class="markdown level1 summary"><p>The dimensions of this object's viewport.
This property represents the size of an image (file on disk, vector graphics, GL or 3D scene, ...) view: this is the logical size of a view, not the number of pixels in the buffer, nor its visible size on the window.</p>
<p>For scalable scenes (vector graphics, 3D or GL), this means scaling the contents of the scene and drawing more pixels as a result; For pixmaps this means zooming and stretching up or down the backing buffer to fit this view.</p>
<p>In most cases the view should have the same dimensions as the object on the canvas, for best quality.</p>
<p><a class="xref" href="Efl.Gfx.IView.html#Efl_Gfx_IView_SetViewSize_Eina_Size2D_">Efl.Gfx.IView.SetViewSize(Eina.Size2D)</a> may not be implemented. If it is, it might trigger a complete recalculation of the scene, or reload of the pixel data.</p>
<p>Refer to each implementing class specific documentation for more details.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual void SetViewSize(Size2D size)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>Size of the view.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="events">Events
  </h3>
  
  
  <h4 id="Efl_Canvas_ImageInternal_ImagePreloadEvt" data-uid="Efl.Canvas.ImageInternal.ImagePreloadEvt">ImagePreloadEvt</h4>
  <div class="markdown level1 summary"><p>Image data has been preloaded.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler ImagePreloadEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_ImageInternal_ImageResizeEvt" data-uid="Efl.Canvas.ImageInternal.ImageResizeEvt">ImageResizeEvt</h4>
  <div class="markdown level1 summary"><p>Image was resized (its pixel data).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler ImageResizeEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <h4 id="Efl_Canvas_ImageInternal_ImageUnloadEvt" data-uid="Efl.Canvas.ImageInternal.ImageUnloadEvt">ImageUnloadEvt</h4>
  <div class="markdown level1 summary"><p>Image data has been unloaded (by some mechanism in EFL that threw out the original image data).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public event EventHandler ImageUnloadEvt</code></pre>
  </div>
  <h5 class="eventType">Event Type</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">EventHandler</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h3 id="implements">Implements</h3>
  <div>
      <a class="xref" href="Efl.Canvas.IPointer.html">Efl.Canvas.IPointer</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gesture.IEvents.html">Efl.Gesture.IEvents</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IColor.html">Efl.Gfx.IColor</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IEntity.html">Efl.Gfx.IEntity</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IHint.html">Efl.Gfx.IHint</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IMapping.html">Efl.Gfx.IMapping</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IStack.html">Efl.Gfx.IStack</a>
  </div>
  <div>
      <a class="xref" href="Efl.Input.IInterface.html">Efl.Input.IInterface</a>
  </div>
  <div>
      <a class="xref" href="Efl.Ui.II18n.html">Efl.Ui.II18n</a>
  </div>
  <div>
      <a class="xref" href="Efl.IFileSave.html">Efl.IFileSave</a>
  </div>
  <div>
      <a class="xref" href="Efl.Canvas.Filter.IInternal.html">Efl.Canvas.Filter.IInternal</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IBuffer.html">Efl.Gfx.IBuffer</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IFill.html">Efl.Gfx.IFill</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IFilter.html">Efl.Gfx.IFilter</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IImage.html">Efl.Gfx.IImage</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IImageOrientable.html">Efl.Gfx.IImageOrientable</a>
  </div>
  <div>
      <a class="xref" href="Efl.Gfx.IView.html">Efl.Gfx.IView</a>
  </div>
  <div>
      <a class="xref" href="Efl.Eo.IWrapper.html">Efl.Eo.IWrapper</a>
  </div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
