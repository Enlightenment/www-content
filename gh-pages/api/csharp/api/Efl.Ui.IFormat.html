<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Interface Efl.Ui.IFormat
   </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Interface Efl.Ui.IFormat
   ">
    <meta name="generator" content="docfx 2.45.0.0">
    
    <link rel="shortcut icon" href="../e-logo-title.png">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../e-logo-title.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Efl.Ui.IFormat">
  
  
  <h1 id="Efl_Ui_IFormat" data-uid="Efl.Ui.IFormat" class="text-break">Interface Efl.Ui.IFormat
  </h1>
  <div class="markdown level0 summary"><p>Helper mixin that simplifies converting numerical values to text.
A number of widgets represent a numerical value but display a text representation. For example, an <span class="text-muted">Efl.Ui.Progressbar (object still in beta stage)</span> can hold the number 0.75 but display the string &quot;75%&quot;, or an <a class="xref" href="Efl.Ui.Spin.html">Efl.Ui.Spin</a> can hold numbers 1 to 7, but display the strings &quot;Monday&quot; thru &quot;Sunday&quot;.</p>
<p>This conversion can be controlled through the <a class="xref" href="Efl.Ui.IFormat.html#Efl_Ui_IFormat_FormatFunc">Efl.Ui.IFormat.FormatFunc</a>, <a class="xref" href="Efl.Ui.IFormat.html#Efl_Ui_IFormat_FormatValues">Efl.Ui.IFormat.FormatValues</a> and <a class="xref" href="Efl.Ui.IFormat.html#Efl_Ui_IFormat_GetFormatString_System_String__Efl_Ui_FormatStringType__">Efl.Ui.IFormat.GetFormatString(out System.String, out Efl.Ui.FormatStringType)</a> properties. Only one of them needs to be set. When more than one is set <a class="xref" href="Efl.Ui.IFormat.html#Efl_Ui_IFormat_FormatValues">Efl.Ui.IFormat.FormatValues</a> has the highest priority, followed by <a class="xref" href="Efl.Ui.IFormat.html#Efl_Ui_IFormat_FormatFunc">Efl.Ui.IFormat.FormatFunc</a> and then <a class="xref" href="Efl.Ui.IFormat.html#Efl_Ui_IFormat_GetFormatString_System_String__Efl_Ui_FormatStringType__">Efl.Ui.IFormat.GetFormatString(out System.String, out Efl.Ui.FormatStringType)</a>. If one mechanism fails to produce a valid string the others will be tried (if provided) in descending order of priority. If no user-provided mechanism works, a fallback is used that just displays the value.</p>
<p>Widgets including this mixin offer their users different properties to control how <span class="text-muted">Eina.Value (object still in beta stage)</span>'s are converted to text.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  
  <h5 id="Efl_Ui_IFormat_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public interface IFormat : IWrapper, IDisposable</code></pre>
  </div>
  <h3 id="properties">Properties
  </h3>
  
  
  <a id="Efl_Ui_IFormat_FormatFunc_" data-uid="Efl.Ui.IFormat.FormatFunc*"></a>
  <h4 id="Efl_Ui_IFormat_FormatFunc" data-uid="Efl.Ui.IFormat.FormatFunc">FormatFunc</h4>
  <div class="markdown level1 summary"><p>User-provided function which takes care of converting an <span class="text-muted">Eina.Value (object still in beta stage)</span> into a text string. The user is then completely in control of how the string is generated, but it is the most cumbersome method to use. If the conversion fails the other mechanisms will be tried, according to their priorities.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">FormatFunc FormatFunc { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Ui.FormatFunc.html">Efl.Ui.FormatFunc</a></td>
        <td><p>User-provided formatting function.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_IFormat_FormatString_" data-uid="Efl.Ui.IFormat.FormatString*"></a>
  <h4 id="Efl_Ui_IFormat_FormatString" data-uid="Efl.Ui.IFormat.FormatString">FormatString</h4>
  <div class="markdown level1 summary"><p>A user-provided, string used to format the numerical value.
For example, &quot;%1.2f meters&quot;, &quot;%.0%%&quot; or &quot;%d items&quot;.</p>
<p>This is the simplest formatting mechanism, working pretty much like <code>printf</code>.</p>
<p>Different format specifiers (the character after the %) are available, depending on the <code>type</code> used. Use <a class="xref" href="Efl.Ui.FormatStringType.html#Efl_Ui_FormatStringType_Simple">Efl.Ui.FormatStringType.Simple</a> for simple numerical values and <a class="xref" href="Efl.Ui.FormatStringType.html#Efl_Ui_FormatStringType_Time">Efl.Ui.FormatStringType.Time</a> for time and date values. For instance, %d means &quot;integer&quot; when the first type is used, but it means &quot;day of the month as a decimal number&quot; in the second.</p>
<p>Pass <code>NULL</code> to disable this mechanism.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">(string, FormatStringType)FormatString { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple&lt;System.String, Efl.Ui.FormatStringType&gt;</span></td>
        <td><p>Formatting string containing regular characters and format specifiers.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_IFormat_FormatValues_" data-uid="Efl.Ui.IFormat.FormatValues*"></a>
  <h4 id="Efl_Ui_IFormat_FormatValues" data-uid="Efl.Ui.IFormat.FormatValues">FormatValues</h4>
  <div class="markdown level1 summary"><p>User-provided list of values which are to be rendered using specific text strings. This is more convenient to use than <a class="xref" href="Efl.Ui.IFormat.html#Efl_Ui_IFormat_FormatFunc">Efl.Ui.IFormat.FormatFunc</a> and is perfectly suited for cases where the strings make more sense than the numerical values. For example, weekday names (&quot;Monday&quot;, &quot;Tuesday&quot;, ...) are friendlier than numbers 1 to 7. If a value is not found in the list, the other mechanisms will be tried according to their priorities. List members do not need to be in any particular order. They are sorted internally for performance reasons.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">Accessor&lt;FormatValue&gt; FormatValues { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">Eina.Accessor&lt;Efl.Ui.FormatValue&gt;</span></td>
        <td><p>Accessor over a list of value-text pairs. The method will dispose of the accessor, but not of its contents. For convenience, Eina offers a range of helper methods to obtain accessors from Eina.Array, Eina.List or even plain C arrays.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="Efl_Ui_IFormat_GetFormatFunc_" data-uid="Efl.Ui.IFormat.GetFormatFunc*"></a>
  <h4 id="Efl_Ui_IFormat_GetFormatFunc" data-uid="Efl.Ui.IFormat.GetFormatFunc">GetFormatFunc()</h4>
  <div class="markdown level1 summary"><p>User-provided function which takes care of converting an <span class="text-muted">Eina.Value (object still in beta stage)</span> into a text string. The user is then completely in control of how the string is generated, but it is the most cumbersome method to use. If the conversion fails the other mechanisms will be tried, according to their priorities.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">FormatFunc GetFormatFunc()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Ui.FormatFunc.html">Efl.Ui.FormatFunc</a></td>
        <td><p>User-provided formatting function.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_IFormat_GetFormatString_" data-uid="Efl.Ui.IFormat.GetFormatString*"></a>
  <h4 id="Efl_Ui_IFormat_GetFormatString_System_String__Efl_Ui_FormatStringType__" data-uid="Efl.Ui.IFormat.GetFormatString(System.String@,Efl.Ui.FormatStringType@)">GetFormatString(out String, out FormatStringType)</h4>
  <div class="markdown level1 summary"><p>A user-provided, string used to format the numerical value.
For example, &quot;%1.2f meters&quot;, &quot;%.0%%&quot; or &quot;%d items&quot;.</p>
<p>This is the simplest formatting mechanism, working pretty much like <code>printf</code>.</p>
<p>Different format specifiers (the character after the %) are available, depending on the <code>type</code> used. Use <a class="xref" href="Efl.Ui.FormatStringType.html#Efl_Ui_FormatStringType_Simple">Efl.Ui.FormatStringType.Simple</a> for simple numerical values and <a class="xref" href="Efl.Ui.FormatStringType.html#Efl_Ui_FormatStringType_Time">Efl.Ui.FormatStringType.Time</a> for time and date values. For instance, %d means &quot;integer&quot; when the first type is used, but it means &quot;day of the month as a decimal number&quot; in the second.</p>
<p>Pass <code>NULL</code> to disable this mechanism.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">void GetFormatString(out string kw_string, out FormatStringType type)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.string">System.String</a></td>
        <td><span class="parametername">kw_string</span></td>
        <td><p>Formatting string containing regular characters and format specifiers.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Ui.FormatStringType.html">Efl.Ui.FormatStringType</a></td>
        <td><span class="parametername">type</span></td>
        <td><p>Type of formatting string, which controls how the different format specifiers are to be translated.<br>The default value is <a class="xref" href="Efl.Ui.FormatStringType.html#Efl_Ui_FormatStringType_Simple">Efl.Ui.FormatStringType.Simple</a>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_IFormat_GetFormatValues_" data-uid="Efl.Ui.IFormat.GetFormatValues*"></a>
  <h4 id="Efl_Ui_IFormat_GetFormatValues" data-uid="Efl.Ui.IFormat.GetFormatValues">GetFormatValues()</h4>
  <div class="markdown level1 summary"><p>User-provided list of values which are to be rendered using specific text strings. This is more convenient to use than <a class="xref" href="Efl.Ui.IFormat.html#Efl_Ui_IFormat_FormatFunc">Efl.Ui.IFormat.FormatFunc</a> and is perfectly suited for cases where the strings make more sense than the numerical values. For example, weekday names (&quot;Monday&quot;, &quot;Tuesday&quot;, ...) are friendlier than numbers 1 to 7. If a value is not found in the list, the other mechanisms will be tried according to their priorities. List members do not need to be in any particular order. They are sorted internally for performance reasons.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">Accessor&lt;FormatValue&gt; GetFormatValues()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">Eina.Accessor&lt;Efl.Ui.FormatValue&gt;</span></td>
        <td><p>Accessor over a list of value-text pairs. The method will dispose of the accessor, but not of its contents. For convenience, Eina offers a range of helper methods to obtain accessors from Eina.Array, Eina.List or even plain C arrays.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_IFormat_SetFormatFunc_" data-uid="Efl.Ui.IFormat.SetFormatFunc*"></a>
  <h4 id="Efl_Ui_IFormat_SetFormatFunc_Efl_Ui_FormatFunc_" data-uid="Efl.Ui.IFormat.SetFormatFunc(Efl.Ui.FormatFunc)">SetFormatFunc(FormatFunc)</h4>
  <div class="markdown level1 summary"><p>User-provided function which takes care of converting an <span class="text-muted">Eina.Value (object still in beta stage)</span> into a text string. The user is then completely in control of how the string is generated, but it is the most cumbersome method to use. If the conversion fails the other mechanisms will be tried, according to their priorities.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">void SetFormatFunc(FormatFunc func)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Ui.FormatFunc.html">Efl.Ui.FormatFunc</a></td>
        <td><span class="parametername">func</span></td>
        <td><p>User-provided formatting function.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_IFormat_SetFormatString_" data-uid="Efl.Ui.IFormat.SetFormatString*"></a>
  <h4 id="Efl_Ui_IFormat_SetFormatString_System_String_Efl_Ui_FormatStringType_" data-uid="Efl.Ui.IFormat.SetFormatString(System.String,Efl.Ui.FormatStringType)">SetFormatString(String, FormatStringType)</h4>
  <div class="markdown level1 summary"><p>A user-provided, string used to format the numerical value.
For example, &quot;%1.2f meters&quot;, &quot;%.0%%&quot; or &quot;%d items&quot;.</p>
<p>This is the simplest formatting mechanism, working pretty much like <code>printf</code>.</p>
<p>Different format specifiers (the character after the %) are available, depending on the <code>type</code> used. Use <a class="xref" href="Efl.Ui.FormatStringType.html#Efl_Ui_FormatStringType_Simple">Efl.Ui.FormatStringType.Simple</a> for simple numerical values and <a class="xref" href="Efl.Ui.FormatStringType.html#Efl_Ui_FormatStringType_Time">Efl.Ui.FormatStringType.Time</a> for time and date values. For instance, %d means &quot;integer&quot; when the first type is used, but it means &quot;day of the month as a decimal number&quot; in the second.</p>
<p>Pass <code>NULL</code> to disable this mechanism.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">void SetFormatString(string kw_string, FormatStringType type)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="https://docs.microsoft.com/dotnet/api/system.string">System.String</a></td>
        <td><span class="parametername">kw_string</span></td>
        <td><p>Formatting string containing regular characters and format specifiers.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Ui.FormatStringType.html">Efl.Ui.FormatStringType</a></td>
        <td><span class="parametername">type</span></td>
        <td><p>Type of formatting string, which controls how the different format specifiers are to be translated.<br>The default value is <a class="xref" href="Efl.Ui.FormatStringType.html#Efl_Ui_FormatStringType_Simple">Efl.Ui.FormatStringType.Simple</a>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Ui_IFormat_SetFormatValues_" data-uid="Efl.Ui.IFormat.SetFormatValues*"></a>
  <h4 id="Efl_Ui_IFormat_SetFormatValues_Eina_Accessor_Efl_Ui_FormatValue__" data-uid="Efl.Ui.IFormat.SetFormatValues(Eina.Accessor{Efl.Ui.FormatValue})">SetFormatValues(Accessor&lt;FormatValue&gt;)</h4>
  <div class="markdown level1 summary"><p>User-provided list of values which are to be rendered using specific text strings. This is more convenient to use than <a class="xref" href="Efl.Ui.IFormat.html#Efl_Ui_IFormat_FormatFunc">Efl.Ui.IFormat.FormatFunc</a> and is perfectly suited for cases where the strings make more sense than the numerical values. For example, weekday names (&quot;Monday&quot;, &quot;Tuesday&quot;, ...) are friendlier than numbers 1 to 7. If a value is not found in the list, the other mechanisms will be tried according to their priorities. List members do not need to be in any particular order. They are sorted internally for performance reasons.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">void SetFormatValues(Accessor&lt;FormatValue&gt; values)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">Eina.Accessor&lt;Efl.Ui.FormatValue&gt;</span></td>
        <td><span class="parametername">values</span></td>
        <td><p>Accessor over a list of value-text pairs. The method will dispose of the accessor, but not of its contents. For convenience, Eina offers a range of helper methods to obtain accessors from Eina.Array, Eina.List or even plain C arrays.</p>
</td>
      </tr>
    </tbody>
  </table>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
