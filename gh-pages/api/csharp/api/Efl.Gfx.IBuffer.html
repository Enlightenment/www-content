<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Interface Efl.Gfx.IBuffer
   </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Interface Efl.Gfx.IBuffer
   ">
    <meta name="generator" content="docfx 2.40.4.0">
    
    <link rel="shortcut icon" href="../e-logo-title.png">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../e-logo-title.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Efl.Gfx.IBuffer">
  
  
  <h1 id="Efl_Gfx_IBuffer" data-uid="Efl.Gfx.IBuffer" class="text-break">Interface Efl.Gfx.IBuffer
  </h1>
  <div class="markdown level0 summary"><p>Common APIs for all objects representing images and 2D pixel buffers.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="remarks">
  <h5 id="Efl_Gfx_IBuffer_remarks"><strong>Remarks</strong></h5>
  <p>This is a <strong>BETA</strong> class. It can be modified or removed in the future. Do not use it for product development.</p>

  </div>
  
  <h5 id="Efl_Gfx_IBuffer_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public interface IBuffer : IWrapper, IDisposable</code></pre>
  </div>
  <h3 id="properties">Properties
  </h3>
  
  
  <a id="Efl_Gfx_IBuffer_Alpha_" data-uid="Efl.Gfx.IBuffer.Alpha*"></a>
  <h4 id="Efl_Gfx_IBuffer_Alpha" data-uid="Efl.Gfx.IBuffer.Alpha">Alpha</h4>
  <div class="markdown level1 summary"><p>Indicates whether the alpha channel should be used.
This does not indicate whether the image source file contains an alpha channel, only whether to respect it or discard it.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">bool Alpha { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether to use alpha channel (<code>true</code>) data or not (<code>false</code>).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Gfx_IBuffer_BufferSize_" data-uid="Efl.Gfx.IBuffer.BufferSize*"></a>
  <h4 id="Efl_Gfx_IBuffer_BufferSize" data-uid="Efl.Gfx.IBuffer.BufferSize">BufferSize</h4>
  <div class="markdown level1 summary"><p>Rectangular size of the pixel buffer as allocated in memory.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">Size2D BufferSize { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>Size of the buffer in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Gfx_IBuffer_Colorspace_" data-uid="Efl.Gfx.IBuffer.Colorspace*"></a>
  <h4 id="Efl_Gfx_IBuffer_Colorspace" data-uid="Efl.Gfx.IBuffer.Colorspace">Colorspace</h4>
  <div class="markdown level1 summary"><p>The colorspace defines how pixels are encoded in the image in memory.
By default, images are encoded in 32-bit BGRA, ie. each pixel takes 4 bytes in memory, with each channel B,G,R,A encoding the color with values from 0 to 255.</p>
<p>All images used in EFL use alpha-premultipied BGRA values, which means that for each pixel, B &lt;= A, G &lt;= A and R &lt;= A.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">Colorspace Colorspace { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.Colorspace.html">Efl.Gfx.Colorspace</a></td>
        <td><p>Colorspace</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Gfx_IBuffer_Stride_" data-uid="Efl.Gfx.IBuffer.Stride*"></a>
  <h4 id="Efl_Gfx_IBuffer_Stride" data-uid="Efl.Gfx.IBuffer.Stride">Stride</h4>
  <div class="markdown level1 summary"><p>Length in bytes of one row of pixels in memory.
Usually this will be equal to width * 4, with a plain BGRA image. This may return 0 if the stride is not applicable.</p>
<p>When applicable, this will include the <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_GetBufferBorders_System_UInt32__System_UInt32__System_UInt32__System_UInt32__">Efl.Gfx.IBuffer.GetBufferBorders(out System.UInt32, out System.UInt32, out System.UInt32, out System.UInt32)</a> as well as potential extra padding.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">int Stride { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>Stride</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="Efl_Gfx_IBuffer_AddBufferUpdate_" data-uid="Efl.Gfx.IBuffer.AddBufferUpdate*"></a>
  <h4 id="Efl_Gfx_IBuffer_AddBufferUpdate_Eina_Rect__" data-uid="Efl.Gfx.IBuffer.AddBufferUpdate(Eina.Rect@)">AddBufferUpdate(ref Rect)</h4>
  <div class="markdown level1 summary"><p>Mark a sub-region of the given image object to be redrawn.
This function schedules a particular rectangular region of an image object to be updated (redrawn) at the next rendering cycle.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">void AddBufferUpdate(ref Rect region)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><span class="parametername">region</span></td>
        <td><p>The updated region.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Gfx_IBuffer_BufferMap_" data-uid="Efl.Gfx.IBuffer.BufferMap*"></a>
  <h4 id="Efl_Gfx_IBuffer_BufferMap_Efl_Gfx_BufferAccessMode_Eina_Rect__Efl_Gfx_Colorspace_System_Int32_System_Int32__" data-uid="Efl.Gfx.IBuffer.BufferMap(Efl.Gfx.BufferAccessMode,Eina.Rect@,Efl.Gfx.Colorspace,System.Int32,System.Int32@)">BufferMap(BufferAccessMode, ref Rect, Colorspace, Int32, out Int32)</h4>
  <div class="markdown level1 summary"><p>Map a region of this buffer for read or write access by the CPU.
Fetches data from the GPU if needed. This operation may be slow if cpu_readable_fast or cpu_writeable_fast are not true, or if the required colorspace is different from the internal one.</p>
<p>Note that if the buffer has <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_GetBufferBorders_System_UInt32__System_UInt32__System_UInt32__System_UInt32__">Efl.Gfx.IBuffer.GetBufferBorders(out System.UInt32, out System.UInt32, out System.UInt32, out System.UInt32)</a>, then <code>x</code> and <code>y</code> may be negative.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">RwSlice BufferMap(BufferAccessMode mode, ref Rect region, Colorspace cspace, int plane, out int stride)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.BufferAccessMode.html">Efl.Gfx.BufferAccessMode</a></td>
        <td><span class="parametername">mode</span></td>
        <td><p>Specifies whether to map for read-only, write-only or read-write access (OR combination of flags).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Eina.Rect.html">Eina.Rect</a></td>
        <td><span class="parametername">region</span></td>
        <td><p>The region to map.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Gfx.Colorspace.html">Efl.Gfx.Colorspace</a></td>
        <td><span class="parametername">cspace</span></td>
        <td><p>Requested colorspace. If different from the internal cspace, map should try to convert the data into a new buffer. argb8888 by default.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">plane</span></td>
        <td><p>Plane ID. 0 by default. Useful for planar formats only.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">stride</span></td>
        <td><p>Returns the length in bytes of a mapped line</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.RwSlice.html">Eina.RwSlice</a></td>
        <td><p>The data slice. In case of failure, the memory pointer will be <code>null</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Gfx_IBuffer_BufferUnmap_" data-uid="Efl.Gfx.IBuffer.BufferUnmap*"></a>
  <h4 id="Efl_Gfx_IBuffer_BufferUnmap_Eina_RwSlice_" data-uid="Efl.Gfx.IBuffer.BufferUnmap(Eina.RwSlice)">BufferUnmap(RwSlice)</h4>
  <div class="markdown level1 summary"><p>Unmap a region of this buffer, and update the internal data if needed.
EFL will update the internal image if the map had write access.</p>
<p>Note: The <code>slice</code> struct does not need to be the one returned by <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_BufferMap_Efl_Gfx_BufferAccessMode_Eina_Rect__Efl_Gfx_Colorspace_System_Int32_System_Int32__">Efl.Gfx.IBuffer.BufferMap(Efl.Gfx.BufferAccessMode, ref Eina.Rect, Efl.Gfx.Colorspace, System.Int32, out System.Int32)</a>, only its contents (<code>mem</code> and <code>len</code>) must match. But after a call to <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_BufferUnmap_Eina_RwSlice_">Efl.Gfx.IBuffer.BufferUnmap(Eina.RwSlice)</a> the original <code>slice</code> structure is not valid anymore.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">bool BufferUnmap(RwSlice slice)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.RwSlice.html">Eina.RwSlice</a></td>
        <td><span class="parametername">slice</span></td>
        <td><p>Data slice returned by a previous call to map.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> on success, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Gfx_IBuffer_GetAlpha_" data-uid="Efl.Gfx.IBuffer.GetAlpha*"></a>
  <h4 id="Efl_Gfx_IBuffer_GetAlpha" data-uid="Efl.Gfx.IBuffer.GetAlpha">GetAlpha()</h4>
  <div class="markdown level1 summary"><p>Retrieve whether alpha channel data is used on this object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">bool GetAlpha()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>Whether to use alpha channel (<code>true</code>) data or not (<code>false</code>).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Gfx_IBuffer_GetBufferBorders_" data-uid="Efl.Gfx.IBuffer.GetBufferBorders*"></a>
  <h4 id="Efl_Gfx_IBuffer_GetBufferBorders_System_UInt32__System_UInt32__System_UInt32__System_UInt32__" data-uid="Efl.Gfx.IBuffer.GetBufferBorders(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">GetBufferBorders(out UInt32, out UInt32, out UInt32, out UInt32)</h4>
  <div class="markdown level1 summary"><p>Duplicated pixel borders inside this buffer.
Internally, EFL may require an image to have its border pixels duplicated, in particular for GL textures. This property exposes the internal duplicated borders to allow calling <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_BufferMap_Efl_Gfx_BufferAccessMode_Eina_Rect__Efl_Gfx_Colorspace_System_Int32_System_Int32__">Efl.Gfx.IBuffer.BufferMap(Efl.Gfx.BufferAccessMode, ref Eina.Rect, Efl.Gfx.Colorspace, System.Int32, out System.Int32)</a> with the entire pixel data, including those edge pixels.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">void GetBufferBorders(out uint l, out uint r, out uint t, out uint b)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">l</span></td>
        <td><p>Left border pixels, usually 0 or 1</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">r</span></td>
        <td><p>Right border pixels, usually 0 or 1</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">t</span></td>
        <td><p>Top border pixels, usually 0 or 1</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">b</span></td>
        <td><p>Bottom border pixels, usually 0 or 1</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Gfx_IBuffer_GetBufferManaged_" data-uid="Efl.Gfx.IBuffer.GetBufferManaged*"></a>
  <h4 id="Efl_Gfx_IBuffer_GetBufferManaged_System_Int32_" data-uid="Efl.Gfx.IBuffer.GetBufferManaged(System.Int32)">GetBufferManaged(Int32)</h4>
  <div class="markdown level1 summary"><p>Get a direct pointer to the internal pixel data, if available.
This will return <code>null</code> unless <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_SetBufferManaged_Eina_Slice_Eina_Size2D_System_Int32_Efl_Gfx_Colorspace_System_Int32_">Efl.Gfx.IBuffer.SetBufferManaged(Eina.Slice, Eina.Size2D, System.Int32, Efl.Gfx.Colorspace, System.Int32)</a> was used to pass in an external data pointer.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">Slice GetBufferManaged(int plane)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">plane</span></td>
        <td><p>Plane ID. 0 by default. Useful for planar formats only.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Slice.html">Eina.Slice</a></td>
        <td><p>The data slice. The memory pointer will be <code>null</code> in case of failure.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Gfx_IBuffer_GetBufferSize_" data-uid="Efl.Gfx.IBuffer.GetBufferSize*"></a>
  <h4 id="Efl_Gfx_IBuffer_GetBufferSize" data-uid="Efl.Gfx.IBuffer.GetBufferSize">GetBufferSize()</h4>
  <div class="markdown level1 summary"><p>Rectangular size of the pixel buffer as allocated in memory.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">Size2D GetBufferSize()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><p>Size of the buffer in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Gfx_IBuffer_GetColorspace_" data-uid="Efl.Gfx.IBuffer.GetColorspace*"></a>
  <h4 id="Efl_Gfx_IBuffer_GetColorspace" data-uid="Efl.Gfx.IBuffer.GetColorspace">GetColorspace()</h4>
  <div class="markdown level1 summary"><p>Returns the current encoding of this buffer's pixels.
See <a class="xref" href="Efl.Gfx.Colorspace.html">Efl.Gfx.Colorspace</a> for more information on the supported formats.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">Colorspace GetColorspace()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Efl.Gfx.Colorspace.html">Efl.Gfx.Colorspace</a></td>
        <td><p>Colorspace</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Gfx_IBuffer_GetStride_" data-uid="Efl.Gfx.IBuffer.GetStride*"></a>
  <h4 id="Efl_Gfx_IBuffer_GetStride" data-uid="Efl.Gfx.IBuffer.GetStride">GetStride()</h4>
  <div class="markdown level1 summary"><p>Length in bytes of one row of pixels in memory.
Usually this will be equal to width * 4, with a plain BGRA image. This may return 0 if the stride is not applicable.</p>
<p>When applicable, this will include the <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_GetBufferBorders_System_UInt32__System_UInt32__System_UInt32__System_UInt32__">Efl.Gfx.IBuffer.GetBufferBorders(out System.UInt32, out System.UInt32, out System.UInt32, out System.UInt32)</a> as well as potential extra padding.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">int GetStride()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>Stride</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Gfx_IBuffer_SetAlpha_" data-uid="Efl.Gfx.IBuffer.SetAlpha*"></a>
  <h4 id="Efl_Gfx_IBuffer_SetAlpha_System_Boolean_" data-uid="Efl.Gfx.IBuffer.SetAlpha(System.Boolean)">SetAlpha(Boolean)</h4>
  <div class="markdown level1 summary"><p>Change alpha channel usage for this object.
This function sets a flag on an image object indicating whether or not to use alpha channel data. A value of <code>true</code> makes it use alpha channel data, and <code>false</code> makes it ignore that data. Note that this has nothing to do with an object's color as manipulated by <a class="xref" href="Efl.Gfx.IColor.html#Efl_Gfx_IColor_GetColor_System_Int32__System_Int32__System_Int32__System_Int32__">Efl.Gfx.IColor.GetColor(out System.Int32, out System.Int32, out System.Int32, out System.Int32)</a>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">void SetAlpha(bool alpha)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">alpha</span></td>
        <td><p>Whether to use alpha channel (<code>true</code>) data or not (<code>false</code>).</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Gfx_IBuffer_SetBufferCopy_" data-uid="Efl.Gfx.IBuffer.SetBufferCopy*"></a>
  <h4 id="Efl_Gfx_IBuffer_SetBufferCopy_Eina_Slice_Eina_Size2D_System_Int32_Efl_Gfx_Colorspace_System_Int32_" data-uid="Efl.Gfx.IBuffer.SetBufferCopy(Eina.Slice,Eina.Size2D,System.Int32,Efl.Gfx.Colorspace,System.Int32)">SetBufferCopy(Slice, Size2D, Int32, Colorspace, Int32)</h4>
  <div class="markdown level1 summary"><p>Set the pixels for this buffer by copying them, or allocate a new memory region.
This will allocate a new buffer in memory and copy the input <code>pixels</code> to it. The internal colorspace is not guaranteed to be preserved, and colorspace conversion may happen internally.</p>
<p>If <code>pixels</code> is <code>null</code>, then a new empty buffer will be allocated. If the buffer already had pixel data, the previous image data will be dropped. This is the same as <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_SetBufferManaged_Eina_Slice_Eina_Size2D_System_Int32_Efl_Gfx_Colorspace_System_Int32_">Efl.Gfx.IBuffer.SetBufferManaged(Eina.Slice, Eina.Size2D, System.Int32, Efl.Gfx.Colorspace, System.Int32)</a>.</p>
<p>The memory buffer <code>pixels</code> must be large enough to hold <code>width</code> x <code>height</code> pixels encoded in the colorspace <code>cspace</code>.</p>
<p><code>slice</code> should not be the return value of <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_GetBufferManaged_System_Int32_">Efl.Gfx.IBuffer.GetBufferManaged(System.Int32)</a>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">bool SetBufferCopy(Slice slice, Size2D size, int stride, Colorspace cspace, int plane)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Slice.html">Eina.Slice</a></td>
        <td><span class="parametername">slice</span></td>
        <td><p>If <code>null</code>, allocates an empty buffer</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>The size in pixels.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">stride</span></td>
        <td><p>If 0, automatically guessed from the <code>width</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Gfx.Colorspace.html">Efl.Gfx.Colorspace</a></td>
        <td><span class="parametername">cspace</span></td>
        <td><p>argb8888 by default.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">plane</span></td>
        <td><p>Plane ID. 0 by default. Useful for planar formats only.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> on success, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Gfx_IBuffer_SetBufferManaged_" data-uid="Efl.Gfx.IBuffer.SetBufferManaged*"></a>
  <h4 id="Efl_Gfx_IBuffer_SetBufferManaged_Eina_Slice_Eina_Size2D_System_Int32_Efl_Gfx_Colorspace_System_Int32_" data-uid="Efl.Gfx.IBuffer.SetBufferManaged(Eina.Slice,Eina.Size2D,System.Int32,Efl.Gfx.Colorspace,System.Int32)">SetBufferManaged(Slice, Size2D, Int32, Colorspace, Int32)</h4>
  <div class="markdown level1 summary"><p>Set the pixels for this buffer, managed externally by the client.
EFL will use the pixel data directly, and update the GPU-side texture if required. This will mark the image as dirty. If <code>slice</code> is <code>null</code>, this will detach the pixel data.</p>
<p>If the buffer already had pixel data, the previous image data will be dropped. This is the same as <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_SetBufferCopy_Eina_Slice_Eina_Size2D_System_Int32_Efl_Gfx_Colorspace_System_Int32_">Efl.Gfx.IBuffer.SetBufferCopy(Eina.Slice, Eina.Size2D, System.Int32, Efl.Gfx.Colorspace, System.Int32)</a>.</p>
<p>The memory buffer <code>pixels</code> must be large enough to hold <code>width</code> x <code>height</code> pixels encoded in the colorspace <code>cspace</code>.</p>
<p>See also <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_SetBufferCopy_Eina_Slice_Eina_Size2D_System_Int32_Efl_Gfx_Colorspace_System_Int32_">Efl.Gfx.IBuffer.SetBufferCopy(Eina.Slice, Eina.Size2D, System.Int32, Efl.Gfx.Colorspace, System.Int32)</a> if you want EFL to copy the input buffer internally.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">bool SetBufferManaged(Slice slice, Size2D size, int stride, Colorspace cspace, int plane)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Slice.html">Eina.Slice</a></td>
        <td><span class="parametername">slice</span></td>
        <td><p>If <code>null</code>, detaches the previous buffer.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>The size in pixels.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">stride</span></td>
        <td><p>If 0, automatically guessed from the <code>width</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Efl.Gfx.Colorspace.html">Efl.Gfx.Colorspace</a></td>
        <td><span class="parametername">cspace</span></td>
        <td><p>argb8888 by default.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">plane</span></td>
        <td><p>Plane ID. 0 by default. Useful for planar formats only.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code> on success, <code>false</code> otherwise</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Efl_Gfx_IBuffer_SetBufferSize_" data-uid="Efl.Gfx.IBuffer.SetBufferSize*"></a>
  <h4 id="Efl_Gfx_IBuffer_SetBufferSize_Eina_Size2D_" data-uid="Efl.Gfx.IBuffer.SetBufferSize(Eina.Size2D)">SetBufferSize(Size2D)</h4>
  <div class="markdown level1 summary"><p>Potentially not implemented, <a class="xref" href="Efl.Gfx.IBuffer.html#Efl_Gfx_IBuffer_BufferSize">Efl.Gfx.IBuffer.BufferSize</a> may be read-only.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">void SetBufferSize(Size2D sz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Eina.Size2D.html">Eina.Size2D</a></td>
        <td><span class="parametername">sz</span></td>
        <td><p>Size of the buffer in pixels.</p>
</td>
      </tr>
    </tbody>
  </table>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
