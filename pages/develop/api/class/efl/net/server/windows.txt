<title>Efl.Net.Server.Windows</title>
++++ Inheritance graph |

<graphviz>
digraph hierarchy {
    bgcolor = "transparent"
    size = "6"
    rankdir = "TB"

    node [shape = "box"]
    edge [color = "gray35"]

    efl_net_server_windows [fillcolor = "black", label = "Efl.Net.Server.Windows", color = "gray15", fontcolor = "white", style = "filled"]
    efl_loop_user [fillcolor = "gray15", label = "Efl.Loop_User", color = "gray15", fontcolor = "white", style = "filled"]
    efl_object [fillcolor = "gray15", label = "Efl.Object", color = "gray15", fontcolor = "white", style = "filled"]
    efl_net_server [fillcolor = "gray15", label = "Efl.Net.Server", color = "cornflowerblue", fontcolor = "white", style = "filled"]

    efl_net_server_windows -> efl_loop_user
    efl_loop_user -> efl_object
    efl_net_server_windows -> efl_net_server
}
</graphviz>

++++

===== Inheritance hierarchy =====

  * **[[:develop:api:class:efl:net:server:windows|Efl.Net.Server.Windows]] //(class)//**
    * [[:develop:api:class:efl:loop_user|Efl.Loop_User]] //(class)//
      * [[:develop:api:class:efl:object|Efl.Object]] //(class)//
    * [[:develop:api:interface:efl:net:server|Efl.Net.Server]] //(interface)//

===== Description =====

%%A Windows NamedPipe server.%%

%%The %%[[:develop:api:interface:efl:net:server:method:serve|Efl.Net.Server.serve]]%% method will call CreateNamedPipe() directly, thus path will be accessed and created in that method. If the created socket must be subject to some special mode or user, change before executing that method.%%

//Since 1.19//

{{page>:develop:user:class:efl:net:server:windows:description&nouser&nolink&nodate}}

===== Members =====

**[[:develop:api:class:efl:net:server:windows:property:allow_remote|allow_remote]]** //**(get, set)**//
<code c>
Eina_Bool efl_net_server_windows_allow_remote_get(const Eo *obj);
void efl_net_server_windows_allow_remote_set(Eo *obj, Eina_Bool allow_remote);
</code>

%%If server allows remote (different machine) clients.%%\\ 
\\ 

==== Inherited ====

[[:develop:api:class:efl:loop_user|Efl.Loop_User]].**[[:develop:api:class:efl:loop_user:property:loop|loop]]** //**(get)**//
<code c>
Efl_Loop *efl_loop_get(const Eo *obj);
</code>

%%The loop to which this object belongs to.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:loop_user:property:parent|parent]]** //**(get, set)**// //[Overridden in [[:develop:api:class:efl:loop_user|Efl.Loop_User]]]//
<code c>
Efl_Object *efl_parent_get(const Eo *obj);
void efl_parent_set(Eo *obj, Efl_Object *parent);
</code>

%%The parent of an object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:net:server:windows:method:constructor|constructor]]** //[Overridden here]//
<code c>
Efl_Object *efl_constructor(Eo *obj);
</code>

%%Call the object's constructor.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:net:server:windows:method:destructor|destructor]]** //[Overridden here]//
<code c>
void efl_destructor(Eo *obj);
</code>

%%Call the object's destructor.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:children_iterator_new|children_iterator_new]]**
<code c>
Eina_Iterator *efl_children_iterator_new(Eo *obj);
</code>

%%Get an iterator on all childrens%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:composite_attach|composite_attach]]**
<code c>
Eina_Bool efl_composite_attach(Eo *obj, Efl_Object *comp_obj);
</code>

%%Make an object a composite object of another.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:composite_detach|composite_detach]]**
<code c>
Eina_Bool efl_composite_detach(Eo *obj, Efl_Object *comp_obj);
</code>

%%Detach a composite object from another object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:composite_part_is|composite_part_is]]**
<code c>
Eina_Bool efl_composite_part_is(Eo *obj);
</code>

%%Check if an object is part of a composite object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:debug_name_override|debug_name_override]]**
<code c>
void efl_debug_name_override(Eo *obj, Eina_Strbuf *sb);
</code>

%%Build a read-only name for this object used for debugging.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:del|del]]**
<code c>
void efl_del(const Eo *obj);
</code>

%%Unrefs the object and reparents it to NULL.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_callback_forwarder_add|event_callback_forwarder_add]]**
<code c>
void efl_event_callback_forwarder_add(Eo *obj, const Efl_Event_Description *desc, Efl_Object *new_obj);
</code>

%%Add an event callback forwarder for an event and an object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_callback_forwarder_del|event_callback_forwarder_del]]**
<code c>
void efl_event_callback_forwarder_del(Eo *obj, const Efl_Event_Description *desc, Efl_Object *new_obj);
</code>

%%Remove an event callback forwarder for an event and an object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_callback_stop|event_callback_stop]]**
<code c>
void efl_event_callback_stop(Eo *obj);
</code>

%%Stop the current callback call.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_freeze|event_freeze]]**
<code c>
void efl_event_freeze(Eo *obj);
</code>

%%Freeze events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_global_freeze|event_global_freeze]]**
<code c>
void efl_event_global_freeze(const Eo *obj);
</code>

%%Freeze events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_global_thaw|event_global_thaw]]**
<code c>
void efl_event_global_thaw(const Eo *obj);
</code>

%%Thaw events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_thaw|event_thaw]]**
<code c>
void efl_event_thaw(Eo *obj);
</code>

%%Thaw events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:finalize|finalize]]**
<code c>
Efl_Object *efl_finalize(Eo *obj);
</code>

%%Called at the end of #eo_add. Should not be called, just overridden.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:name_find|name_find]]**
<code c>
Efl_Object *efl_name_find(const Eo *obj, const char *search);
</code>

%%Find a child object with the given name and return it.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:provider_find|provider_find]]**
<code c>
Efl_Object *efl_provider_find(Eo *obj, const Efl_Object *klass);
</code>

%%Searches up in the object tree for a provider which knows the given class/interface.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:allow_parent_unref|allow_parent_unref]]** //**(get, set)**//
<code c>
Eina_Bool efl_allow_parent_unref_get(const Eo *obj);
void efl_allow_parent_unref_set(Eo *obj, Eina_Bool allow);
</code>

%%Allow an object to be deleted by unref even if it has a parent.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:comment|comment]]** //**(get, set)**//
<code c>
const char *efl_comment_get(const Eo *obj);
void efl_comment_set(Eo *obj, const char *comment);
</code>

%%A human readable comment for the object%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:event_freeze_count|event_freeze_count]]** //**(get)**//
<code c>
int efl_event_freeze_count_get(const Eo *obj);
</code>

%%Return freeze events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:event_global_freeze_count|event_global_freeze_count]]** //**(get)**//
<code c>
int efl_event_global_freeze_count_get(const Eo *obj);
</code>

%%Return freeze events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:finalized|finalized]]** //**(get)**//
<code c>
Eina_Bool efl_finalized_get(const Eo *obj);
</code>

%%True if the object is already finalized, false otherwise.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:name|name]]** //**(get, set)**//
<code c>
const char *efl_name_get(const Eo *obj);
void efl_name_set(Eo *obj, const char *name);
</code>

%%The name of the object.%%\\ 
\\ 
[[:develop:api:interface:efl:net:server|Efl.Net.Server]].**[[:develop:api:class:efl:net:server:windows:method:serve|serve]]** //[Overridden here]//
<code c>
Eina_Error efl_net_server_serve(Eo *obj, const char *address);
</code>

%%address parameter will have "\\.\pipe\" prepended%%\\ 
\\ 
[[:develop:api:interface:efl:net:server|Efl.Net.Server]].**[[:develop:api:class:efl:net:server:windows:property:address|address]]** //**(get, set)**// //[Overridden here]// ''protected set''
<code c>
const char *efl_net_server_address_get(const Eo *obj);
void efl_net_server_address_set(Eo *obj, const char *address);
</code>

%%The address the server is bound to.%%\\ 
\\ 
[[:develop:api:interface:efl:net:server|Efl.Net.Server]].**[[:develop:api:class:efl:net:server:windows:property:clients_count|clients_count]]** //**(get, set)**// //[Overridden here]// ''protected set''
<code c>
unsigned int efl_net_server_clients_count_get(const Eo *obj);
void efl_net_server_clients_count_set(Eo *obj, unsigned int count);
</code>

%%Number of concurrent clients accepted by this server.%%\\ 
\\ 
[[:develop:api:interface:efl:net:server|Efl.Net.Server]].**[[:develop:api:class:efl:net:server:windows:property:clients_limit|clients_limit]]** //**(get, set)**// //[Overridden here]//
<code c>
void efl_net_server_clients_limit_get(const Eo *obj, unsigned int *limit, Eina_Bool *reject_excess);
void efl_net_server_clients_limit_set(Eo *obj, unsigned int limit, Eina_Bool reject_excess);
</code>

%%Number of maximum concurrent clients allowed by this server.%%\\ 
\\ 
[[:develop:api:interface:efl:net:server|Efl.Net.Server]].**[[:develop:api:class:efl:net:server:windows:property:serving|serving]]** //**(get, set)**// //[Overridden here]// ''protected set''
<code c>
Eina_Bool efl_net_server_serving_get(const Eo *obj);
void efl_net_server_serving_set(Eo *obj, Eina_Bool serving);
</code>

%%Returns whenever the server is ready to accept clients or not.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:auto_unref|auto_unref]]** //**(set)**// ''protected''
<code c>
void efl_auto_unref_set(Eo *obj, Eina_Bool enable);
</code>

%%Mark an object to be automatically deleted after a function call.%%\\ 
\\ 
[[:develop:api:interface:efl:net:server|Efl.Net.Server]].**[[:develop:api:class:efl:net:server:windows:method:client_announce|client_announce]]** //[Overridden here]// ''protected''
<code c>
Eina_Bool efl_net_server_client_announce(Eo *obj, Efl_Net_Socket *client);
</code>

%%Implementions should call this method to announce new clients.%%\\ 
\\ 

==== Inherited ====

[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:event:callback_add|callback,add]]**
<code c>
EFL_EVENT_CALLBACK_ADD(void, @hot)
</code>

%%A callback was added.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:event:callback_del|callback,del]]**
<code c>
EFL_EVENT_CALLBACK_DEL(void, @hot)
</code>

%%A callback was deleted.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:event:del|del]]**
<code c>
EFL_EVENT_DEL(void, @hot)
</code>

%%Object is being deleted.%%\\ 
\\ 
[[:develop:api:interface:efl:net:server|Efl.Net.Server]].**[[:develop:api:interface:efl:net:server:event:client_add|client,add]]**
<code c>
EFL_NET_SERVER_EVENT_CLIENT_ADD(Efl_Net_Socket *, @hot)
</code>

%%A new client socket was created.%%\\ 
\\ 
[[:develop:api:interface:efl:net:server|Efl.Net.Server]].**[[:develop:api:interface:efl:net:server:event:client_rejected|client,rejected]]**
<code c>
EFL_NET_SERVER_EVENT_CLIENT_REJECTED(const char *)
</code>

%%Notifies a client was rejected due excess, see %%[[:develop:api:interface:efl:net:server:property:clients_limit|Efl.Net.Server.clients_limit]]%%.%%\\ 
\\ 
[[:develop:api:interface:efl:net:server|Efl.Net.Server]].**[[:develop:api:interface:efl:net:server:event:error|error]]**
<code c>
EFL_NET_SERVER_EVENT_ERROR(Eina_Error)
</code>

%%Some error happened and the server needs to be stopped.%%\\ 
\\ 
[[:develop:api:interface:efl:net:server|Efl.Net.Server]].**[[:develop:api:interface:efl:net:server:event:serving|serving]]**
<code c>
EFL_NET_SERVER_EVENT_SERVING(void)
</code>

%%Notifies the server is ready to accept clients. See property %%[[:develop:api:interface:efl:net:server:property:serving|Efl.Net.Server.serving]]%%%%\\ 
\\ 
