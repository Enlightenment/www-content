<title>Efl.Net.Socket.Simple</title>
++++ Inheritance graph |

<graphviz>
digraph hierarchy {
    bgcolor = "transparent"
    size = "6"
    rankdir = "TB"

    node [shape = "box"]
    edge [color = "gray35"]

    efl_net_socket_simple [fillcolor = "black", label = "Efl.Net.Socket.Simple", color = "gray15", fontcolor = "white", style = "filled"]
    efl_io_buffered_stream [fillcolor = "gray15", label = "Efl.Io.Buffered_Stream", color = "gray15", fontcolor = "white", style = "filled"]
    efl_loop_user [fillcolor = "gray15", label = "Efl.Loop_User", color = "gray15", fontcolor = "white", style = "filled"]
    efl_object [fillcolor = "gray15", label = "Efl.Object", color = "gray15", fontcolor = "white", style = "filled"]
    efl_io_reader [fillcolor = "gray15", label = "Efl.Io.Reader", color = "cornflowerblue", fontcolor = "white", style = "filled"]
    efl_io_writer [fillcolor = "gray15", label = "Efl.Io.Writer", color = "cornflowerblue", fontcolor = "white", style = "filled"]
    efl_io_closer [fillcolor = "gray15", label = "Efl.Io.Closer", color = "deepskyblue", fontcolor = "white", style = "filled"]
    efl_net_socket [fillcolor = "gray15", label = "Efl.Net.Socket", color = "cornflowerblue", fontcolor = "white", style = "filled"]
    efl_io_reader [fillcolor = "gray15", label = "Efl.Io.Reader", color = "cornflowerblue", fontcolor = "white", style = "filled"]
    efl_io_writer [fillcolor = "gray15", label = "Efl.Io.Writer", color = "cornflowerblue", fontcolor = "white", style = "filled"]
    efl_io_closer [fillcolor = "gray15", label = "Efl.Io.Closer", color = "deepskyblue", fontcolor = "white", style = "filled"]

    efl_net_socket_simple -> efl_io_buffered_stream
    efl_io_buffered_stream -> efl_loop_user
    efl_loop_user -> efl_object
    efl_io_buffered_stream -> efl_io_reader
    efl_io_buffered_stream -> efl_io_writer
    efl_io_buffered_stream -> efl_io_closer
    efl_net_socket_simple -> efl_net_socket
    efl_net_socket -> efl_io_reader
    efl_net_socket -> efl_io_writer
    efl_net_socket -> efl_io_closer
}
</graphviz>

++++

===== Inheritance hierarchy =====

  * **[[:develop:api:class:efl:net:socket:simple|Efl.Net.Socket.Simple]] //(class)//**
    * [[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]] //(class)//
      * [[:develop:api:class:efl:loop_user|Efl.Loop_User]] //(class)//
        * [[:develop:api:class:efl:object|Efl.Object]] //(class)//
      * [[:develop:api:interface:efl:io:reader|Efl.Io.Reader]] //(interface)//
      * [[:develop:api:interface:efl:io:writer|Efl.Io.Writer]] //(interface)//
      * [[:develop:api:mixin:efl:io:closer|Efl.Io.Closer]] //(mixin)//
    * [[:develop:api:interface:efl:net:socket|Efl.Net.Socket]] //(interface)//
      * [[:develop:api:interface:efl:io:reader|Efl.Io.Reader]] //(interface)//
      * [[:develop:api:interface:efl:io:writer|Efl.Io.Writer]] //(interface)//
      * [[:develop:api:mixin:efl:io:closer|Efl.Io.Closer]] //(mixin)//

===== Description =====

%%A wrapper socket offering an easy to use, buffered I/O.%%

%%The simple socket encapsulates an actual %%[[:develop:api:interface:efl:net:socket|Efl.Net.Socket]]%%, and uses it with an %%[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]]%%, which creates an input %%[[:develop:api:class:efl:io:queue|Efl.Io.Queue]]%%, an output %%[[:develop:api:class:efl:io:queue|Efl.Io.Queue]]%% and these are linked using a receiver and a sender %%[[:develop:api:class:efl:io:copier|Efl.Io.Copier]]%%.%%

%%The idea is that unlike traditional %%[[:develop:api:interface:efl:net:socket|Efl.Net.Socket]]%% that will attempt to write directly to socket and thus may take less data than requested, this one will keep the pending data in its own buffer, feeding to the actual socket when it %%[[:develop:api:interface:efl:io:writer:property:can_write|Efl.Io.Writer.can_write]]%%. That makes its operation much simpler as %%[[:develop:api:interface:efl:io:writer:method:write|Efl.Io.Writer.write]]%% will always take the full data -- allows "write and forget", if unlimited (see %%[[:develop:api:class:efl:io:buffered_stream:property:max_queue_size_output|Efl.Io.Buffered_Stream.max_queue_size_output]]%%).%%

%%Reading is also much simpler since received data is kept in an %%[[:develop:api:class:efl:io:queue|Efl.Io.Queue]]%%, thus its size can be queried with %%[[:develop:api:class:efl:io:buffered_stream:property:pending_read|Efl.Io.Buffered_Stream.pending_read]]%% and read with %%[[:develop:api:interface:efl:io:reader:method:read|Efl.Io.Reader.read]]%% or peeked with %%[[:develop:api:class:efl:io:buffered_stream:property:slice|Efl.Io.Buffered_Stream.slice]]%%, then discarded with %%[[:develop:api:class:efl:io:buffered_stream:method:discard|Efl.Io.Buffered_Stream.discard]]%% or %%[[:develop:api:class:efl:io:buffered_stream:method:clear|Efl.Io.Buffered_Stream.clear]]%%.%%

%%Then when waiting for a complete message, just peek at its contents, if not complete do nothing, if complete then either %%[[:develop:api:interface:efl:io:reader:method:read|Efl.Io.Reader.read]]%% to get a copy or manipulate a read-only reference from %%[[:develop:api:class:efl:io:buffered_stream:property:slice|Efl.Io.Buffered_Stream.slice]]%% and then %%[[:develop:api:class:efl:io:buffered_stream:method:discard|Efl.Io.Buffered_Stream.discard]]%%%%

%%The actual socket is set with the constructor method %%[[:develop:api:class:efl:io:buffered_stream:property:inner_io|Efl.Io.Buffered_Stream.inner_io.set]]%% and can be retrieved with %%[[:develop:api:class:efl:io:buffered_stream:property:inner_io|Efl.Io.Buffered_Stream.inner_io.get]]%%, which should be used with care.%%

//Since 1.19//

{{page>:develop:user:class:efl:net:socket:simple:description&nouser&nolink&nodate}}

==== Inherited ====

[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:method:clear|clear]]**
<code c>
void efl_io_buffered_stream_clear(Eo *obj);
</code>

%%Clears the incoming queue. Same as reading all data.%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:method:discard|discard]]**
<code c>
void efl_io_buffered_stream_discard(Eo *obj, size_t amount);
</code>

%%Discards the given number of bytes.%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:method:eos_mark|eos_mark]]**
<code c>
void efl_io_buffered_stream_eos_mark(Eo *obj);
</code>

%%Marks this end-of-stream, signals nothing else will be written.%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:method:flush|flush]]**
<code c>
Eina_Bool efl_io_buffered_stream_flush(Eo *obj, Eina_Bool may_block, Eina_Bool ignore_line_delimiter);
</code>

%%Forces writing all pending data to destination.%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:property:line_delimiter|line_delimiter]]** //**(get, set)**//
<code c>
const Eina_Slice efl_io_buffered_stream_line_delimiter_get(const Eo *obj);
void efl_io_buffered_stream_line_delimiter_set(Eo *obj, const Eina_Slice slice);
</code>

%%If set, incoming data will be checked for the delimiter and "line" events are The line may include the delimiter, unless it's end-of-stream on %%[[:develop:api:class:efl:io:buffered_stream:property:max_queue_size_input|Efl.Io.Buffered_Stream.max_queue_size_input]]%% was reached.%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:property:max_queue_size_input|max_queue_size_input]]** //**(get, set)**//
<code c>
size_t efl_io_buffered_stream_max_queue_size_input_get(const Eo *obj);
void efl_io_buffered_stream_max_queue_size_input_set(Eo *obj, size_t max_queue_size_input);
</code>

%%Limits how big the input queue can grow, in bytes.%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:property:max_queue_size_output|max_queue_size_output]]** //**(get, set)**//
<code c>
size_t efl_io_buffered_stream_max_queue_size_output_get(const Eo *obj);
void efl_io_buffered_stream_max_queue_size_output_set(Eo *obj, size_t max_queue_size_output);
</code>

%%Limits how big the output queue can grow, in bytes.%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:property:pending_read|pending_read]]** //**(get)**//
<code c>
size_t efl_io_buffered_stream_pending_read_get(const Eo *obj);
</code>

%%How many bytes are pending (available) for read%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:property:pending_write|pending_write]]** //**(get)**//
<code c>
size_t efl_io_buffered_stream_pending_write_get(const Eo *obj);
</code>

%%How many bytes are pending write to %%[[:develop:api:class:efl:io:buffered_stream:property:inner_io|Efl.Io.Buffered_Stream.inner_io]]%%%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:property:progress|progress]]** //**(get)**//
<code c>
void efl_io_buffered_stream_progress_get(const Eo *obj, size_t *read_bytes, size_t *written_bytes);
</code>

%%How many bytes were written and read.%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:property:read_chunk_size|read_chunk_size]]** //**(get, set)**//
<code c>
size_t efl_io_buffered_stream_read_chunk_size_get(const Eo *obj);
void efl_io_buffered_stream_read_chunk_size_set(Eo *obj, size_t size);
</code>

%%Reads chunk size property, in bytes.%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:property:slice|slice]]** //**(get)**//
<code c>
Eina_Slice efl_io_buffered_stream_slice_get(const Eo *obj);
</code>

%%Gets a temporary access to input queue's internal read memory.%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:property:timeout_inactivity|timeout_inactivity]]** //**(get, set)**//
<code c>
double efl_io_buffered_stream_timeout_inactivity_get(const Eo *obj);
void efl_io_buffered_stream_timeout_inactivity_set(Eo *obj, double seconds);
</code>

%%Error as ETIMEDOUT if it becomes inactive for some time.%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:net:socket:simple:property:inner_io|inner_io]]** //**(get, set)**// //[Overridden here]//
<code c>
Efl_Object *efl_io_buffered_stream_inner_io_get(const Eo *obj);
void efl_io_buffered_stream_inner_io_set(Eo *obj, Efl_Object *io);
</code>

%%The inner I/O this wrapper operates on.%%\\ 
\\ 
[[:develop:api:class:efl:loop_user|Efl.Loop_User]].**[[:develop:api:class:efl:loop_user:property:loop|loop]]** //**(get)**//
<code c>
Efl_Loop *efl_loop_get(const Eo *obj);
</code>

%%The loop to which this object belongs to.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:io:buffered_stream:method:destructor|destructor]]** //[Overridden in [[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]]]//
<code c>
void efl_destructor(Eo *obj);
</code>

%%Call the object's destructor.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:io:buffered_stream:method:finalize|finalize]]** //[Overridden in [[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]]]//
<code c>
Efl_Object *efl_finalize(Eo *obj);
</code>

%%Called at the end of #eo_add. Should not be called, just overridden.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:loop_user:property:parent|parent]]** //**(get, set)**// //[Overridden in [[:develop:api:class:efl:loop_user|Efl.Loop_User]]]//
<code c>
Efl_Object *efl_parent_get(const Eo *obj);
void efl_parent_set(Eo *obj, Efl_Object *parent);
</code>

%%The parent of an object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:children_iterator_new|children_iterator_new]]**
<code c>
Eina_Iterator *efl_children_iterator_new(Eo *obj);
</code>

%%Get an iterator on all childrens%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:composite_attach|composite_attach]]**
<code c>
Eina_Bool efl_composite_attach(Eo *obj, Efl_Object *comp_obj);
</code>

%%Make an object a composite object of another.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:composite_detach|composite_detach]]**
<code c>
Eina_Bool efl_composite_detach(Eo *obj, Efl_Object *comp_obj);
</code>

%%Detach a composite object from another object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:composite_part_is|composite_part_is]]**
<code c>
Eina_Bool efl_composite_part_is(Eo *obj);
</code>

%%Check if an object is part of a composite object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:constructor|constructor]]**
<code c>
Efl_Object *efl_constructor(Eo *obj);
</code>

%%Call the object's constructor.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:debug_name_override|debug_name_override]]**
<code c>
void efl_debug_name_override(Eo *obj, Eina_Strbuf *sb);
</code>

%%Build a read-only name for this object used for debugging.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:del|del]]**
<code c>
void efl_del(const Eo *obj);
</code>

%%Unrefs the object and reparents it to NULL.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_callback_forwarder_add|event_callback_forwarder_add]]**
<code c>
void efl_event_callback_forwarder_add(Eo *obj, const Efl_Event_Description *desc, Efl_Object *new_obj);
</code>

%%Add an event callback forwarder for an event and an object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_callback_forwarder_del|event_callback_forwarder_del]]**
<code c>
void efl_event_callback_forwarder_del(Eo *obj, const Efl_Event_Description *desc, Efl_Object *new_obj);
</code>

%%Remove an event callback forwarder for an event and an object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_callback_stop|event_callback_stop]]**
<code c>
void efl_event_callback_stop(Eo *obj);
</code>

%%Stop the current callback call.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_freeze|event_freeze]]**
<code c>
void efl_event_freeze(Eo *obj);
</code>

%%Freeze events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_global_freeze|event_global_freeze]]**
<code c>
void efl_event_global_freeze(const Eo *obj);
</code>

%%Freeze events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_global_thaw|event_global_thaw]]**
<code c>
void efl_event_global_thaw(const Eo *obj);
</code>

%%Thaw events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_thaw|event_thaw]]**
<code c>
void efl_event_thaw(Eo *obj);
</code>

%%Thaw events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:name_find|name_find]]**
<code c>
Efl_Object *efl_name_find(const Eo *obj, const char *search);
</code>

%%Find a child object with the given name and return it.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:provider_find|provider_find]]**
<code c>
Efl_Object *efl_provider_find(Eo *obj, const Efl_Object *klass);
</code>

%%Searches up in the object tree for a provider which knows the given class/interface.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:allow_parent_unref|allow_parent_unref]]** //**(get, set)**//
<code c>
Eina_Bool efl_allow_parent_unref_get(const Eo *obj);
void efl_allow_parent_unref_set(Eo *obj, Eina_Bool allow);
</code>

%%Allow an object to be deleted by unref even if it has a parent.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:comment|comment]]** //**(get, set)**//
<code c>
const char *efl_comment_get(const Eo *obj);
void efl_comment_set(Eo *obj, const char *comment);
</code>

%%A human readable comment for the object%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:event_freeze_count|event_freeze_count]]** //**(get)**//
<code c>
int efl_event_freeze_count_get(const Eo *obj);
</code>

%%Return freeze events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:event_global_freeze_count|event_global_freeze_count]]** //**(get)**//
<code c>
int efl_event_global_freeze_count_get(const Eo *obj);
</code>

%%Return freeze events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:finalized|finalized]]** //**(get)**//
<code c>
Eina_Bool efl_finalized_get(const Eo *obj);
</code>

%%True if the object is already finalized, false otherwise.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:name|name]]** //**(get, set)**//
<code c>
const char *efl_name_get(const Eo *obj);
void efl_name_set(Eo *obj, const char *name);
</code>

%%The name of the object.%%\\ 
\\ 
[[:develop:api:interface:efl:io:reader|Efl.Io.Reader]].**[[:develop:api:class:efl:io:buffered_stream:method:read|read]]** //[Overridden in [[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]]]//
<code c>
Eina_Error efl_io_reader_read(Eo *obj, Eina_Rw_Slice rw_slice);
</code>

%%Reads data into a pre-allocated buffer.%%\\ 
\\ 
[[:develop:api:interface:efl:io:reader|Efl.Io.Reader]].**[[:develop:api:class:efl:io:buffered_stream:property:can_read|can_read]]** //**(get, set)**// //[Overridden in [[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]]]// ''protected set''
<code c>
Eina_Bool efl_io_reader_can_read_get(const Eo *obj);
void efl_io_reader_can_read_set(Eo *obj, Eina_Bool can_read);
</code>

%%If %%''true''%% will notify %%[[:develop:api:interface:efl:io:reader:method:read|Efl.Io.Reader.read]]%% can be called without blocking or failing.%%\\ 
\\ 
[[:develop:api:interface:efl:io:reader|Efl.Io.Reader]].**[[:develop:api:class:efl:io:buffered_stream:property:eos|eos]]** //**(get, set)**// //[Overridden in [[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]]]// ''protected set''
<code c>
Eina_Bool efl_io_reader_eos_get(const Eo *obj);
void efl_io_reader_eos_set(Eo *obj, Eina_Bool is_eos);
</code>

%%If %%''true''%% will notify end of stream.%%\\ 
\\ 
[[:develop:api:interface:efl:io:writer|Efl.Io.Writer]].**[[:develop:api:class:efl:io:buffered_stream:method:write|write]]** //[Overridden in [[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]]]//
<code c>
Eina_Error efl_io_writer_write(Eo *obj, Eina_Slice slice, Eina_Slice *remaining);
</code>

%%Writes data from a pre-populated buffer.%%\\ 
\\ 
[[:develop:api:interface:efl:io:writer|Efl.Io.Writer]].**[[:develop:api:class:efl:io:buffered_stream:property:can_write|can_write]]** //**(get, set)**// //[Overridden in [[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]]]// ''protected set''
<code c>
Eina_Bool efl_io_writer_can_write_get(const Eo *obj);
void efl_io_writer_can_write_set(Eo *obj, Eina_Bool can_write);
</code>

%%If %%''true''%% will notify %%[[:develop:api:interface:efl:io:writer:method:write|Efl.Io.Writer.write]]%% can be called without blocking or failing.%%\\ 
\\ 
[[:develop:api:interface:efl:net:socket|Efl.Net.Socket]].**[[:develop:api:class:efl:net:socket:simple:property:address_local|address_local]]** //**(get, set)**// //[Overridden here]// ''protected set''
<code c>
const char *efl_net_socket_address_local_get(const Eo *obj);
void efl_net_socket_address_local_set(Eo *obj, const char *address);
</code>

%%The local address, similar to getsockname().%%\\ 
\\ 
[[:develop:api:interface:efl:net:socket|Efl.Net.Socket]].**[[:develop:api:class:efl:net:socket:simple:property:address_remote|address_remote]]** //**(get, set)**// //[Overridden here]// ''protected set''
<code c>
const char *efl_net_socket_address_remote_get(const Eo *obj);
void efl_net_socket_address_remote_set(Eo *obj, const char *address);
</code>

%%The remote address, similar to getpeername().%%\\ 
\\ 
[[:develop:api:mixin:efl:io:closer|Efl.Io.Closer]].**[[:develop:api:class:efl:io:buffered_stream:method:close|close]]** //[Overridden in [[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]]]//
<code c>
Eina_Error efl_io_closer_close(Eo *obj);
</code>

%%Closes the Input/Output object.%%\\ 
\\ 
[[:develop:api:mixin:efl:io:closer|Efl.Io.Closer]].**[[:develop:api:class:efl:io:buffered_stream:property:close_on_destructor|close_on_destructor]]** //**(get, set)**// //[Overridden in [[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]]]//
<code c>
Eina_Bool efl_io_closer_close_on_destructor_get(const Eo *obj);
void efl_io_closer_close_on_destructor_set(Eo *obj, Eina_Bool close_on_destructor);
</code>

%%If true will automatically close() on object destructor.%%\\ 
\\ 
[[:develop:api:mixin:efl:io:closer|Efl.Io.Closer]].**[[:develop:api:class:efl:io:buffered_stream:property:close_on_exec|close_on_exec]]** //**(get, set)**// //[Overridden in [[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]]]//
<code c>
Eina_Bool efl_io_closer_close_on_exec_get(const Eo *obj);
Eina_Bool efl_io_closer_close_on_exec_set(Eo *obj, Eina_Bool close_on_exec);
</code>

%%If true will automatically close resources on exec() calls.%%\\ 
\\ 
[[:develop:api:mixin:efl:io:closer|Efl.Io.Closer]].**[[:develop:api:class:efl:io:buffered_stream:property:closed|closed]]** //**(get, set)**// //[Overridden in [[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]]]//
<code c>
Eina_Bool efl_io_closer_closed_get(const Eo *obj);
Eina_Bool efl_io_closer_closed_set(Eo *obj, Eina_Bool is_closed);
</code>

%%If true will notify object was closed.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:auto_unref|auto_unref]]** //**(set)**// ''protected''
<code c>
void efl_auto_unref_set(Eo *obj, Eina_Bool enable);
</code>

%%Mark an object to be automatically deleted after a function call.%%\\ 
\\ 

==== Inherited ====

[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:event:error|error]]**
<code c>
EFL_IO_BUFFERED_STREAM_EVENT_ERROR(Eina_Error)
</code>

%%An error happened and the I/O stopped%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:event:finished|finished]]**
<code c>
EFL_IO_BUFFERED_STREAM_EVENT_FINISHED(void)
</code>

%%Both read and write are finished.%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:event:line|line]]**
<code c>
EFL_IO_BUFFERED_STREAM_EVENT_LINE(const Eina_Slice *)
</code>

%%If %%[[:develop:api:class:efl:io:buffered_stream:property:line_delimiter|Efl.Io.Buffered_Stream.line_delimiter]]%% is set, will be emitted with current line. The memory is only valid during event callback dispatched and should not be modified. Note that the line slice may not be inside %%[[:develop:api:class:efl:io:buffered_stream:property:slice|Efl.Io.Buffered_Stream.slice]]%%, don't assume that!%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:event:progress|progress]]**
<code c>
EFL_IO_BUFFERED_STREAM_EVENT_PROGRESS(void)
</code>

%%Property %%[[:develop:api:class:efl:io:buffered_stream:property:progress|Efl.Io.Buffered_Stream.progress]]%% changed%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:event:read_finished|read,finished]]**
<code c>
EFL_IO_BUFFERED_STREAM_EVENT_READ_FINISHED(void)
</code>

%%Same as %%[[:develop:api:interface:efl:io:reader|Efl.Io.Reader]]%% "eos", for consistency.%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:event:slice_changed|slice,changed]]**
<code c>
EFL_IO_BUFFERED_STREAM_EVENT_SLICE_CHANGED(void)
</code>

%%The read-slice returned by %%[[:develop:api:class:efl:io:buffered_stream:property:slice|Efl.Io.Buffered_Stream.slice]]%% may have changed.%%\\ 
\\ 
[[:develop:api:class:efl:io:buffered_stream|Efl.Io.Buffered_Stream]].**[[:develop:api:class:efl:io:buffered_stream:event:write_finished|write,finished]]**
<code c>
EFL_IO_BUFFERED_STREAM_EVENT_WRITE_FINISHED(void)
</code>

%%%%[[:develop:api:class:efl:io:buffered_stream:method:eos_mark|Efl.Io.Buffered_Stream.eos_mark]]%% was called and all available data was sent to destination%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:event:callback_add|callback,add]]**
<code c>
EFL_EVENT_CALLBACK_ADD(void, @hot)
</code>

%%A callback was added.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:event:callback_del|callback,del]]**
<code c>
EFL_EVENT_CALLBACK_DEL(void, @hot)
</code>

%%A callback was deleted.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:event:del|del]]**
<code c>
EFL_EVENT_DEL(void, @hot)
</code>

%%Object is being deleted.%%\\ 
\\ 
[[:develop:api:interface:efl:io:reader|Efl.Io.Reader]].**[[:develop:api:interface:efl:io:reader:event:can_read_changed|can_read,changed]]**
<code c>
EFL_IO_READER_EVENT_CAN_READ_CHANGED(void)
</code>

%%Notifies can_read property changed.%%\\ 
\\ 
[[:develop:api:interface:efl:io:reader|Efl.Io.Reader]].**[[:develop:api:interface:efl:io:reader:event:can_read_changed|can_read,changed]]**
<code c>
EFL_IO_READER_EVENT_CAN_READ_CHANGED(void)
</code>

%%Notifies can_read property changed.%%\\ 
\\ 
[[:develop:api:interface:efl:io:reader|Efl.Io.Reader]].**[[:develop:api:interface:efl:io:reader:event:eos|eos]]**
<code c>
EFL_IO_READER_EVENT_EOS(void)
</code>

%%Notifies end of stream, when property is marked as true.%%\\ 
\\ 
[[:develop:api:interface:efl:io:reader|Efl.Io.Reader]].**[[:develop:api:interface:efl:io:reader:event:eos|eos]]**
<code c>
EFL_IO_READER_EVENT_EOS(void)
</code>

%%Notifies end of stream, when property is marked as true.%%\\ 
\\ 
[[:develop:api:interface:efl:io:writer|Efl.Io.Writer]].**[[:develop:api:interface:efl:io:writer:event:can_write_changed|can_write,changed]]**
<code c>
EFL_IO_WRITER_EVENT_CAN_WRITE_CHANGED(void)
</code>

%%Notifies can_write property changed.%%\\ 
\\ 
[[:develop:api:interface:efl:io:writer|Efl.Io.Writer]].**[[:develop:api:interface:efl:io:writer:event:can_write_changed|can_write,changed]]**
<code c>
EFL_IO_WRITER_EVENT_CAN_WRITE_CHANGED(void)
</code>

%%Notifies can_write property changed.%%\\ 
\\ 
[[:develop:api:mixin:efl:io:closer|Efl.Io.Closer]].**[[:develop:api:mixin:efl:io:closer:event:closed|closed]]**
<code c>
EFL_IO_CLOSER_EVENT_CLOSED(void)
</code>

%%Notifies closed, when property is marked as true%%\\ 
\\ 
[[:develop:api:mixin:efl:io:closer|Efl.Io.Closer]].**[[:develop:api:mixin:efl:io:closer:event:closed|closed]]**
<code c>
EFL_IO_CLOSER_EVENT_CLOSED(void)
</code>

%%Notifies closed, when property is marked as true%%\\ 
\\ 
