<title>Efl.Net.Session</title>
++++ Inheritance graph |

<graphviz>
digraph hierarchy {
    bgcolor = "transparent"
    size = "6"
    rankdir = "TB"

    node [shape = "box"]
    edge [color = "gray35"]

    efl_net_session [fillcolor = "black", label = "Efl.Net.Session", color = "gray15", fontcolor = "white", style = "filled"]
    efl_loop_user [fillcolor = "gray15", label = "Efl.Loop_User", color = "gray15", fontcolor = "white", style = "filled"]
    efl_object [fillcolor = "gray15", label = "Efl.Object", color = "gray15", fontcolor = "white", style = "filled"]

    efl_net_session -> efl_loop_user
    efl_loop_user -> efl_object
}
</graphviz>

++++

===== Inheritance hierarchy =====

  * **[[:develop:api:class:efl:net:session|Efl.Net.Session]] //(class)//**
    * [[:develop:api:class:efl:loop_user|Efl.Loop_User]] //(class)//
      * [[:develop:api:class:efl:object|Efl.Object]] //(class)//

===== Description =====

%%Used by application to request network connectivity.%%

%%This API is targeted at applications that need access to the network, specifying the allowed bearer technologies to connect to the internet, as well as if just local networking is enough or validated internet access is required.%%

%%Some platforms may not implement the backend for this class, in such cases the system will report always %%[[:develop:api:class:efl:net:session:property:state|Efl.Net.Session.state]]%% "online" (%%[[:develop:api:enum:efl:net:session:state|Efl.Net.Session.State.online]]%%) and other properties will be NULL, such as %%[[:develop:api:class:efl:net:session:property:name|Efl.Net.Session.name]]%%, %%[[:develop:api:class:efl:net:session:property:interface|Efl.Net.Session.interface]]%%, %%[[:develop:api:class:efl:net:session:property:ipv4|Efl.Net.Session.ipv4]]%% and %%[[:develop:api:class:efl:net:session:property:ipv6|Efl.Net.Session.ipv6]]%%; as well as %%[[:develop:api:class:efl:net:session:property:technology|Efl.Net.Session.technology]]%% is set to %%[[:develop:api:enum:efl:net:session:technology|Efl.Net.Session.Technology.unknown]]%%. Thus if there is need to detect for an actual backend, check if the state is online but those properties are NULL or technology is unknown.%%

%%@note the %%[[:develop:api:class:efl:net:session:method:connect|Efl.Net.Session.connect]]%% method is subject to backend policy. For instance, ConnMan uses https://github.com/aldebaran/connman/blob/master/doc/session-policy-format.txt%%

//Since 1.19//

{{page>:develop:user:class:efl:net:session:description&nouser&nolink&nodate}}

===== Members =====

**[[:develop:api:class:efl:net:session:method:connect|connect]]**
<code c>
void efl_net_session_connect(Eo *obj, Eina_Bool online_required, Efl_Net_Session_Technology technologies_allowed);
</code>

%%Asks the session to be connected.%%\\ 
\\ 
**[[:develop:api:class:efl:net:session:method:disconnect|disconnect]]**
<code c>
void efl_net_session_disconnect(Eo *obj);
</code>

%%Indicates this session doesn't need a connection anymore.%%\\ 
\\ 
**[[:develop:api:class:efl:net:session:property:interface|interface]]** //**(get)**//
<code c>
const char *efl_net_session_interface_get(const Eo *obj);
</code>

%%The interface allows the application to assign the socket to a given device using SO_BINDTODEVICE%%\\ 
\\ 
**[[:develop:api:class:efl:net:session:property:ipv4|ipv4]]** //**(get)**//
<code c>
void efl_net_session_ipv4_get(const Eo *obj, const char **address, const char **netmask, const char **gateway);
</code>

%%IPv4 in use for this session.%%\\ 
\\ 
**[[:develop:api:class:efl:net:session:property:ipv6|ipv6]]** //**(get)**//
<code c>
void efl_net_session_ipv6_get(const Eo *obj, const char **address, uint8_t *prefix_length, const char **netmask, const char **gateway);
</code>

%%IPv6 in use for this session.%%\\ 
\\ 
**[[:develop:api:class:efl:net:session:property:name|name]]** //**(get)**//
<code c>
const char *efl_net_session_name_get(const Eo *obj);
</code>

%%The user-friendly access point name.%%\\ 
\\ 
**[[:develop:api:class:efl:net:session:property:state|state]]** //**(get)**//
<code c>
Efl_Net_Session_State efl_net_session_state_get(const Eo *obj);
</code>

%%If the session connectivity is offline, local or online.%%\\ 
\\ 
**[[:develop:api:class:efl:net:session:property:technology|technology]]** //**(get)**//
<code c>
Efl_Net_Session_Technology efl_net_session_technology_get(const Eo *obj);
</code>

%%The access point technology that backs this session%%\\ 
\\ 

==== Inherited ====

[[:develop:api:class:efl:loop_user|Efl.Loop_User]].**[[:develop:api:class:efl:loop_user:property:loop|loop]]** //**(get)**//
<code c>
Efl_Loop *efl_loop_get(const Eo *obj);
</code>

%%The loop to which this object belongs to.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:loop_user:property:parent|parent]]** //**(get, set)**// //[Overridden in [[:develop:api:class:efl:loop_user|Efl.Loop_User]]]//
<code c>
Efl_Object *efl_parent_get(const Eo *obj);
void efl_parent_set(Eo *obj, Efl_Object *parent);
</code>

%%The parent of an object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:net:session:method:constructor|constructor]]** //[Overridden here]//
<code c>
Efl_Object *efl_constructor(Eo *obj);
</code>

%%Call the object's constructor.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:net:session:method:destructor|destructor]]** //[Overridden here]//
<code c>
void efl_destructor(Eo *obj);
</code>

%%Call the object's destructor.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:net:session:method:finalize|finalize]]** //[Overridden here]//
<code c>
Efl_Object *efl_finalize(Eo *obj);
</code>

%%Called at the end of #eo_add. Should not be called, just overridden.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:children_iterator_new|children_iterator_new]]**
<code c>
Eina_Iterator *efl_children_iterator_new(Eo *obj);
</code>

%%Get an iterator on all childrens%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:composite_attach|composite_attach]]**
<code c>
Eina_Bool efl_composite_attach(Eo *obj, Efl_Object *comp_obj);
</code>

%%Make an object a composite object of another.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:composite_detach|composite_detach]]**
<code c>
Eina_Bool efl_composite_detach(Eo *obj, Efl_Object *comp_obj);
</code>

%%Detach a composite object from another object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:composite_part_is|composite_part_is]]**
<code c>
Eina_Bool efl_composite_part_is(Eo *obj);
</code>

%%Check if an object is part of a composite object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:debug_name_override|debug_name_override]]**
<code c>
void efl_debug_name_override(Eo *obj, Eina_Strbuf *sb);
</code>

%%Build a read-only name for this object used for debugging.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:del|del]]**
<code c>
void efl_del(const Eo *obj);
</code>

%%Unrefs the object and reparents it to NULL.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_callback_forwarder_add|event_callback_forwarder_add]]**
<code c>
void efl_event_callback_forwarder_add(Eo *obj, const Efl_Event_Description *desc, Efl_Object *new_obj);
</code>

%%Add an event callback forwarder for an event and an object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_callback_forwarder_del|event_callback_forwarder_del]]**
<code c>
void efl_event_callback_forwarder_del(Eo *obj, const Efl_Event_Description *desc, Efl_Object *new_obj);
</code>

%%Remove an event callback forwarder for an event and an object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_callback_stop|event_callback_stop]]**
<code c>
void efl_event_callback_stop(Eo *obj);
</code>

%%Stop the current callback call.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_freeze|event_freeze]]**
<code c>
void efl_event_freeze(Eo *obj);
</code>

%%Freeze events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_global_freeze|event_global_freeze]]**
<code c>
void efl_event_global_freeze(const Eo *obj);
</code>

%%Freeze events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_global_thaw|event_global_thaw]]**
<code c>
void efl_event_global_thaw(const Eo *obj);
</code>

%%Thaw events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:event_thaw|event_thaw]]**
<code c>
void efl_event_thaw(Eo *obj);
</code>

%%Thaw events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:name_find|name_find]]**
<code c>
Efl_Object *efl_name_find(const Eo *obj, const char *search);
</code>

%%Find a child object with the given name and return it.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:method:provider_find|provider_find]]**
<code c>
Efl_Object *efl_provider_find(Eo *obj, const Efl_Object *klass);
</code>

%%Searches up in the object tree for a provider which knows the given class/interface.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:allow_parent_unref|allow_parent_unref]]** //**(get, set)**//
<code c>
Eina_Bool efl_allow_parent_unref_get(const Eo *obj);
void efl_allow_parent_unref_set(Eo *obj, Eina_Bool allow);
</code>

%%Allow an object to be deleted by unref even if it has a parent.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:comment|comment]]** //**(get, set)**//
<code c>
const char *efl_comment_get(const Eo *obj);
void efl_comment_set(Eo *obj, const char *comment);
</code>

%%A human readable comment for the object%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:event_freeze_count|event_freeze_count]]** //**(get)**//
<code c>
int efl_event_freeze_count_get(const Eo *obj);
</code>

%%Return freeze events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:event_global_freeze_count|event_global_freeze_count]]** //**(get)**//
<code c>
int efl_event_global_freeze_count_get(const Eo *obj);
</code>

%%Return freeze events of object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:finalized|finalized]]** //**(get)**//
<code c>
Eina_Bool efl_finalized_get(const Eo *obj);
</code>

%%True if the object is already finalized, false otherwise.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:name|name]]** //**(get, set)**//
<code c>
const char *efl_name_get(const Eo *obj);
void efl_name_set(Eo *obj, const char *name);
</code>

%%The name of the object.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:property:auto_unref|auto_unref]]** //**(set)**// ''protected''
<code c>
void efl_auto_unref_set(Eo *obj, Eina_Bool enable);
</code>

%%Mark an object to be automatically deleted after a function call.%%\\ 
\\ 

===== Events =====

**[[:develop:api:class:efl:net:session:event:changed|changed]]**
<code c>
EFL_NET_SESSION_EVENT_CHANGED(void)
</code>

%%Called when some properties were changed.%%\\ 
\\ 
==== Inherited ====

[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:event:callback_add|callback,add]]**
<code c>
EFL_EVENT_CALLBACK_ADD(void, @hot)
</code>

%%A callback was added.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:event:callback_del|callback,del]]**
<code c>
EFL_EVENT_CALLBACK_DEL(void, @hot)
</code>

%%A callback was deleted.%%\\ 
\\ 
[[:develop:api:class:efl:object|Efl.Object]].**[[:develop:api:class:efl:object:event:del|del]]**
<code c>
EFL_EVENT_DEL(void, @hot)
</code>

%%Object is being deleted.%%\\ 
\\ 
