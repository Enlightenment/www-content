<title>Efl.Io.Copier</title>
++++ Inheritance graph |

<graphviz>
digraph hierarchy {
    bgcolor = "transparent"
    size = "6"
    rankdir = "TB"

    node [shape = "box"]
    edge [color = "gray35"]

    efl_io_copier [fillcolor = "black", label = "Efl.Io.Copier", color = "gray15", fontcolor = "white", style = "filled"]
    efl_loop_user [fillcolor = "gray15", label = "Efl.Loop_User", color = "gray15", fontcolor = "white", style = "filled"]
    efl_object [fillcolor = "gray15", label = "Efl.Object", color = "gray15", fontcolor = "white", style = "filled"]
    efl_io_closer [fillcolor = "gray15", label = "Efl.Io.Closer", color = "deepskyblue", fontcolor = "white", style = "filled"]

    efl_io_copier -> efl_loop_user
    efl_loop_user -> efl_object
    efl_io_copier -> efl_io_closer
}
</graphviz>

++++

===== Inheritance hierarchy =====

  * **[[:develop:efl:auto:class:efl:io:copier|Efl.Io.Copier]] //(class)//**
    * [[:develop:efl:auto:class:efl:loop_user|Efl.Loop_User]] //(class)//
      * [[:develop:efl:auto:class:efl:object|Efl.Object]] //(class)//
    * [[:develop:efl:auto:mixin:efl:io:closer|Efl.Io.Closer]] //(mixin)//

===== Description =====

%%Copy from an %%[[:develop:efl:auto:interface:efl:io:reader|Efl.Io.Reader]]%% source to %%[[:develop:efl:auto:interface:efl:io:writer|Efl.Io.Writer]]%% destination.%%

%%During usage it will keep reference to %%[[:develop:efl:auto:class:efl:io:copier:property:source|Efl.Io.Copier.source]]%% and %%[[:develop:efl:auto:class:efl:io:copier:property:destination|Efl.Io.Copier.destination]]%% objects, automatically relasing them on destructor.%%

%%By default the read-write process is done based on fixed-size chunks (%%[[:develop:efl:auto:class:efl:io:copier:property:read_chunk_size|Efl.Io.Copier.read_chunk_size]]%%), however if %%[[:develop:efl:auto:class:efl:io:copier:property:line_delimiter|Efl.Io.Copier.line_delimiter]]%% is set, the behavior changes to wait for such delimiter or a maximum buffer limit is reached (%%[[:develop:efl:auto:class:efl:io:copier:property:buffer_limit|Efl.Io.Copier.buffer_limit]]%%).%%

%%While a %%[[:develop:efl:auto:class:efl:io:copier:property:source|Efl.Io.Copier.source]]%% is mandatory for the copier to operate properly, the %%[[:develop:efl:auto:class:efl:io:copier:property:destination|Efl.Io.Copier.destination]]%% is optional: if it's not provided, all read data is stored in an internal buffer that can be retrieved using %%[[:develop:efl:auto:class:efl:io:copier:method:binbuf_steal|Efl.Io.Copier.binbuf_steal]]%%, usually called when one of "data", "line" or "done" events are emitted.%%

%%Most important events:%%

%%- The "data" event is general and notifies some data was written to %%[[:develop:efl:auto:class:efl:io:copier:property:destination|Efl.Io.Copier.destination]]%% (if any, otherwise it will be reported for data when it's read from %%[[:develop:efl:auto:class:efl:io:copier:property:source|Efl.Io.Copier.source]]%%).%%

%%- The "line" event is only emitted when %%[[:develop:efl:auto:class:efl:io:copier:property:line_delimiter|Efl.Io.Copier.line_delimiter]]%% is set and not empty. It's simiar to "data".%%

%%- The "done" event is emitted if %%[[:develop:efl:auto:class:efl:io:copier:property:source|Efl.Io.Copier.source]]%% is %%[[:develop:efl:auto:interface:efl:io:reader:property:eos|Efl.Io.Reader.eos]]%% %%''true''%% and all data was written to %%[[:develop:efl:auto:class:efl:io:copier:property:destination|Efl.Io.Copier.destination]]%% (if any, otherwise it will be reported when all data was read from %%[[:develop:efl:auto:class:efl:io:copier:property:source|Efl.Io.Copier.source]]%%).%%

%%- The "error" event is reported if the %%[[:develop:efl:auto:interface:efl:io:reader:method:read|Efl.Io.Reader.read]]%%, %%[[:develop:efl:auto:interface:efl:io:writer:method:write|Efl.Io.Writer.write]]%% or some other internal error happened, like out of memory. Another common error is ETIMEDOUT if %%[[:develop:efl:auto:class:efl:io:copier:property:timeout_inactivity|Efl.Io.Copier.timeout_inactivity]]%% is set.%%

%%A copier is handful to simplify common I/O use cases, such as:%%

%%- Read a file or download content to memory: provide only the source and wait for "done" event, calling %%[[:develop:efl:auto:class:efl:io:copier:method:binbuf_steal|Efl.Io.Copier.binbuf_steal]]%% afterwards.%%

%%- Download content to disk: provide a network socket as source and use %%[[:develop:efl:auto:class:efl:io:file|Efl.Io.File]]%% as destination, then wait for "done" event.%%

%%- Link two I/O streams: provide both source and destination streams, such as %%[[:develop:efl:auto:class:efl:io:stdin|Efl.Io.Stdin]]%% and %%[[:develop:efl:auto:class:efl:io:stdout|Efl.Io.Stdout]]%%, or some network socket. As data is received from source it will be copied to destination in an endless (asynchronous) loop. You may monitor for "done" if the source may be closed.%%

%%If %%[[:develop:efl:auto:mixin:efl:io:closer:method:close|Efl.Io.Closer.close]]%% is called, then it will be called on %%[[:develop:efl:auto:class:efl:io:copier:property:source|Efl.Io.Copier.source]]%% and %%[[:develop:efl:auto:class:efl:io:copier:property:destination|Efl.Io.Copier.destination]]%% if they implement those interfaces.%%

%%%%[[:develop:efl:auto:mixin:efl:io:closer:property:close_on_exec|Efl.Io.Closer.close_on_exec]]%% and %%[[:develop:efl:auto:mixin:efl:io:closer:property:close_on_destructor|Efl.Io.Closer.close_on_destructor]]%% are respected and applied to both source and destination. Both default to %%''true''%%.%%

//Since 1.19//

{{page>:develop:efl:user:class:efl:io:copier:description&nouser&nolink&nodate}}

===== Members =====

**[[:develop:efl:auto:class:efl:io:copier:method:binbuf_steal|binbuf_steal]]**
<code c>
Eina_Binbuf *efl_io_copier_binbuf_steal(Eo *obj);
</code>

%%Steals the internal binbuf and return it to caller.%%\\ 
\\ 
**[[:develop:efl:auto:class:efl:io:copier:method:flush|flush]]**
<code c>
Eina_Bool efl_io_copier_flush(Eo *obj, Eina_Bool may_block, Eina_Bool ignore_line_delimiter);
</code>

%%Forces reading from source and writing to destination.%%\\ 
\\ 
**[[:develop:efl:auto:class:efl:io:copier:property:buffer_limit|buffer_limit]]** //**(get, set)**//
<code c>
size_t efl_io_copier_buffer_limit_get(const Eo *obj);
void efl_io_copier_buffer_limit_set(Eo *obj, size_t size);
</code>

%%Copier buffer limit property, in bytes.%%\\ 
\\ 
**[[:develop:efl:auto:class:efl:io:copier:property:destination|destination]]** //**(get, set)**//
<code c>
Efl_Io_Writer *efl_io_copier_destination_get(const Eo *obj);
void efl_io_copier_destination_set(Eo *obj, Efl_Io_Writer *destination);
</code>

%%Copier destination object.%%\\ 
\\ 
**[[:develop:efl:auto:class:efl:io:copier:property:done|done]]** //**(get, set)**// ''protected set''
<code c>
Eina_Bool efl_io_copier_done_get(const Eo *obj);
void efl_io_copier_done_set(Eo *obj, Eina_Bool done);
</code>

%%Reports if copier is done.%%\\ 
\\ 
**[[:develop:efl:auto:class:efl:io:copier:property:line_delimiter|line_delimiter]]** //**(get, set)**//
<code c>
const Eina_Slice efl_io_copier_line_delimiter_get(const Eo *obj);
void efl_io_copier_line_delimiter_set(Eo *obj, const Eina_Slice slice);
</code>

%%If there is a line delimiter, the reads will buffer/queue up to the line delimiter before calling %%[[:develop:efl:auto:interface:efl:io:writer:method:write|Efl.Io.Writer.write]]%% on the %%[[:develop:efl:auto:class:efl:io:copier:property:destination|Efl.Io.Copier.destination]]%% and the event line is emitted with current line. The line may include the delimiter, unless it's end-of-stream on %%[[:develop:efl:auto:class:efl:io:copier:property:source|Efl.Io.Copier.source]]%% or %%[[:develop:efl:auto:class:efl:io:copier:property:buffer_limit|Efl.Io.Copier.buffer_limit]]%% was reached.%%\\ 
\\ 
**[[:develop:efl:auto:class:efl:io:copier:property:pending_size|pending_size]]** //**(get)**//
<code c>
size_t efl_io_copier_pending_size_get(const Eo *obj);
</code>

%%Returns the size of the pending buffer.%%\\ 
\\ 
**[[:develop:efl:auto:class:efl:io:copier:property:progress|progress]]** //**(get)**//
<code c>
void efl_io_copier_progress_get(const Eo *obj, uint64_t *read, uint64_t *written, uint64_t *total);
</code>

%%Progress for read and write.%%\\ 
\\ 
**[[:develop:efl:auto:class:efl:io:copier:property:read_chunk_size|read_chunk_size]]** //**(get, set)**//
<code c>
size_t efl_io_copier_read_chunk_size_get(const Eo *obj);
void efl_io_copier_read_chunk_size_set(Eo *obj, size_t size);
</code>

%%Copier read chunk size property, in bytes.%%\\ 
\\ 
**[[:develop:efl:auto:class:efl:io:copier:property:source|source]]** //**(get, set)**//
<code c>
Efl_Io_Reader *efl_io_copier_source_get(const Eo *obj);
void efl_io_copier_source_set(Eo *obj, Efl_Io_Reader *source);
</code>

%%Copier source object.%%\\ 
\\ 
**[[:develop:efl:auto:class:efl:io:copier:property:timeout_inactivity|timeout_inactivity]]** //**(get, set)**//
<code c>
double efl_io_copier_timeout_inactivity_get(const Eo *obj);
void efl_io_copier_timeout_inactivity_set(Eo *obj, double seconds);
</code>

%%Terminates the copier with ETIMEDOUT if it becomes inactive for some time.%%\\ 
\\ 

==== Inherited ====

[[:develop:efl:auto:class:efl:loop_user|Efl.Loop_User]].**[[:develop:efl:auto:class:efl:loop_user:property:loop|loop]]** //**(get)**//
<code c>
Efl_Loop *efl_loop_get(const Eo *obj);
</code>

%%The loop to which this object belongs to.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:io:copier:method:constructor|constructor]]** //[Overridden here]//
<code c>
Efl_Object *efl_constructor(Eo *obj);
</code>

%%Call the object's constructor.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:io:copier:method:destructor|destructor]]** //[Overridden here]//
<code c>
void efl_destructor(Eo *obj);
</code>

%%Call the object's destructor.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:io:copier:method:finalize|finalize]]** //[Overridden here]//
<code c>
Efl_Object *efl_finalize(Eo *obj);
</code>

%%Called at the end of #eo_add. Should not be called, just overridden.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:loop_user:property:parent|parent]]** //**(get, set)**// //[Overridden in [[:develop:efl:auto:class:efl:loop_user|Efl.Loop_User]]]//
<code c>
Efl_Object *efl_parent_get(const Eo *obj);
void efl_parent_set(Eo *obj, Efl_Object *parent);
</code>

%%The parent of an object.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:method:children_iterator_new|children_iterator_new]]**
<code c>
Eina_Iterator *efl_children_iterator_new(Eo *obj);
</code>

%%Get an iterator on all childrens%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:method:composite_attach|composite_attach]]**
<code c>
Eina_Bool efl_composite_attach(Eo *obj, Efl_Object *comp_obj);
</code>

%%Make an object a composite object of another.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:method:composite_detach|composite_detach]]**
<code c>
Eina_Bool efl_composite_detach(Eo *obj, Efl_Object *comp_obj);
</code>

%%Detach a composite object from another object.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:method:composite_part_is|composite_part_is]]**
<code c>
Eina_Bool efl_composite_part_is(Eo *obj);
</code>

%%Check if an object is part of a composite object.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:method:debug_name_override|debug_name_override]]**
<code c>
void efl_debug_name_override(Eo *obj, Eina_Strbuf *sb);
</code>

%%Build a read-only name for this object used for debugging.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:method:del|del]]**
<code c>
void efl_del(const Eo *obj);
</code>

%%Unrefs the object and reparents it to NULL.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:method:event_callback_forwarder_add|event_callback_forwarder_add]]**
<code c>
void efl_event_callback_forwarder_add(Eo *obj, const Efl_Event_Description *desc, Efl_Object *new_obj);
</code>

%%Add an event callback forwarder for an event and an object.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:method:event_callback_forwarder_del|event_callback_forwarder_del]]**
<code c>
void efl_event_callback_forwarder_del(Eo *obj, const Efl_Event_Description *desc, Efl_Object *new_obj);
</code>

%%Remove an event callback forwarder for an event and an object.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:method:event_callback_stop|event_callback_stop]]**
<code c>
void efl_event_callback_stop(Eo *obj);
</code>

%%Stop the current callback call.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:method:event_freeze|event_freeze]]**
<code c>
void efl_event_freeze(Eo *obj);
</code>

%%Freeze events of object.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:method:event_global_freeze|event_global_freeze]]**
<code c>
void efl_event_global_freeze(const Eo *obj);
</code>

%%Freeze events of object.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:method:event_global_thaw|event_global_thaw]]**
<code c>
void efl_event_global_thaw(const Eo *obj);
</code>

%%Thaw events of object.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:method:event_thaw|event_thaw]]**
<code c>
void efl_event_thaw(Eo *obj);
</code>

%%Thaw events of object.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:method:name_find|name_find]]**
<code c>
Efl_Object *efl_name_find(const Eo *obj, const char *search);
</code>

%%Find a child object with the given name and return it.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:method:provider_find|provider_find]]**
<code c>
Efl_Object *efl_provider_find(Eo *obj, const Efl_Object *klass);
</code>

%%Searches up in the object tree for a provider which knows the given class/interface.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:property:allow_parent_unref|allow_parent_unref]]** //**(get, set)**//
<code c>
Eina_Bool efl_allow_parent_unref_get(const Eo *obj);
void efl_allow_parent_unref_set(Eo *obj, Eina_Bool allow);
</code>

%%Allow an object to be deleted by unref even if it has a parent.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:property:comment|comment]]** //**(get, set)**//
<code c>
const char *efl_comment_get(const Eo *obj);
void efl_comment_set(Eo *obj, const char *comment);
</code>

%%A human readable comment for the object%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:property:event_freeze_count|event_freeze_count]]** //**(get)**//
<code c>
int efl_event_freeze_count_get(const Eo *obj);
</code>

%%Return freeze events of object.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:property:event_global_freeze_count|event_global_freeze_count]]** //**(get)**//
<code c>
int efl_event_global_freeze_count_get(const Eo *obj);
</code>

%%Return freeze events of object.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:property:finalized|finalized]]** //**(get)**//
<code c>
Eina_Bool efl_finalized_get(const Eo *obj);
</code>

%%True if the object is already finalized, false otherwise.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:property:name|name]]** //**(get, set)**//
<code c>
const char *efl_name_get(const Eo *obj);
void efl_name_set(Eo *obj, const char *name);
</code>

%%The name of the object.%%\\ 
\\ 
[[:develop:efl:auto:mixin:efl:io:closer|Efl.Io.Closer]].**[[:develop:efl:auto:class:efl:io:copier:method:close|close]]** //[Overridden here]//
<code c>
Eina_Error efl_io_closer_close(Eo *obj);
</code>

%%Closes the Input/Output object.%%\\ 
\\ 
[[:develop:efl:auto:mixin:efl:io:closer|Efl.Io.Closer]].**[[:develop:efl:auto:class:efl:io:copier:property:close_on_destructor|close_on_destructor]]** //**(get, set)**// //[Overridden here]//
<code c>
Eina_Bool efl_io_closer_close_on_destructor_get(const Eo *obj);
void efl_io_closer_close_on_destructor_set(Eo *obj, Eina_Bool close_on_destructor);
</code>

%%If true will automatically close() on object destructor.%%\\ 
\\ 
[[:develop:efl:auto:mixin:efl:io:closer|Efl.Io.Closer]].**[[:develop:efl:auto:class:efl:io:copier:property:close_on_exec|close_on_exec]]** //**(get, set)**// //[Overridden here]//
<code c>
Eina_Bool efl_io_closer_close_on_exec_get(const Eo *obj);
Eina_Bool efl_io_closer_close_on_exec_set(Eo *obj, Eina_Bool close_on_exec);
</code>

%%If true will automatically close resources on exec() calls.%%\\ 
\\ 
[[:develop:efl:auto:mixin:efl:io:closer|Efl.Io.Closer]].**[[:develop:efl:auto:class:efl:io:copier:property:closed|closed]]** //**(get, set)**// //[Overridden here]//
<code c>
Eina_Bool efl_io_closer_closed_get(const Eo *obj);
Eina_Bool efl_io_closer_closed_set(Eo *obj, Eina_Bool is_closed);
</code>

%%If true will notify object was closed.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:property:auto_unref|auto_unref]]** //**(set)**// ''protected''
<code c>
void efl_auto_unref_set(Eo *obj, Eina_Bool enable);
</code>

%%Mark an object to be automatically deleted after a function call.%%\\ 
\\ 

===== Events =====

**[[:develop:efl:auto:class:efl:io:copier:event:data|data]]**
<code c>
EFL_IO_COPIER_EVENT_DATA(const Eina_Slice *)
</code>

%%When data is read to internal buffer, it's emitted in this event. The memory is only valid during event callback dispatched and should not be modified.%%\\ 
\\ 
**[[:develop:efl:auto:class:efl:io:copier:event:done|done]]**
<code c>
EFL_IO_COPIER_EVENT_DONE(void)
</code>

%%All available data was copied from source to destination%%\\ 
\\ 
**[[:develop:efl:auto:class:efl:io:copier:event:error|error]]**
<code c>
EFL_IO_COPIER_EVENT_ERROR(Eina_Error)
</code>

%%An error happened and the copy stopped%%\\ 
\\ 
**[[:develop:efl:auto:class:efl:io:copier:event:line|line]]**
<code c>
EFL_IO_COPIER_EVENT_LINE(const Eina_Slice *)
</code>

%%If %%[[:develop:efl:auto:class:efl:io:copier:property:line_delimiter|Efl.Io.Copier.line_delimiter]]%% is set, will be emitted with current line. The memory is only valid during event callback dispatched and should not be modified.%%\\ 
\\ 
**[[:develop:efl:auto:class:efl:io:copier:event:progress|progress]]**
<code c>
EFL_IO_COPIER_EVENT_PROGRESS(void)
</code>

%%Total size changed or Data was read/written%%\\ 
\\ 
==== Inherited ====

[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:event:callback_add|callback,add]]**
<code c>
EFL_EVENT_CALLBACK_ADD(void, @hot)
</code>

%%A callback was added.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:event:callback_del|callback,del]]**
<code c>
EFL_EVENT_CALLBACK_DEL(void, @hot)
</code>

%%A callback was deleted.%%\\ 
\\ 
[[:develop:efl:auto:class:efl:object|Efl.Object]].**[[:develop:efl:auto:class:efl:object:event:del|del]]**
<code c>
EFL_EVENT_DEL(void, @hot)
</code>

%%Object is being deleted.%%\\ 
\\ 
[[:develop:efl:auto:mixin:efl:io:closer|Efl.Io.Closer]].**[[:develop:efl:auto:mixin:efl:io:closer:event:closed|closed]]**
<code c>
EFL_IO_CLOSER_EVENT_CLOSED(void)
</code>

%%Notifies closed, when property is marked as true%%\\ 
\\ 
