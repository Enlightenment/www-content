<title>Elm.Interface_Scrollable</title>
++++ Inheritance graph |

<graphviz>
digraph hierarchy {
    bgcolor = "transparent"
    size = "6"
    rankdir = "TB"

    node [shape = "box"]
    edge [color = "gray35"]

    elm_interface_scrollable [fillcolor = "deepskyblue4", label = "Elm.Interface_Scrollable", color = "deepskyblue", fontcolor = "white", style = "filled"]
    efl_ui_scrollable [fillcolor = "gray15", label = "Efl.Ui.Scrollable", color = "cornflowerblue", fontcolor = "white", style = "filled"]
    efl_canvas_group [fillcolor = "gray15", label = "Efl.Canvas.Group", color = "gray15", fontcolor = "white", style = "filled"]
    efl_canvas_object [fillcolor = "gray15", label = "Efl.Canvas.Object", color = "gray15", fontcolor = "white", style = "filled"]
    efl_object [fillcolor = "gray15", label = "Efl.Object", color = "gray15", fontcolor = "white", style = "filled"]
    efl_gfx [fillcolor = "gray15", label = "Efl.Gfx", color = "cornflowerblue", fontcolor = "white", style = "filled"]
    efl_gfx_stack [fillcolor = "gray15", label = "Efl.Gfx.Stack", color = "cornflowerblue", fontcolor = "white", style = "filled"]
    efl_animator [fillcolor = "gray15", label = "Efl.Animator", color = "cornflowerblue", fontcolor = "white", style = "filled"]
    efl_input_interface [fillcolor = "gray15", label = "Efl.Input.Interface", color = "cornflowerblue", fontcolor = "white", style = "filled"]
    efl_gfx_size_hint [fillcolor = "gray15", label = "Efl.Gfx.Size.Hint", color = "cornflowerblue", fontcolor = "white", style = "filled"]
    efl_gfx_map [fillcolor = "gray15", label = "Efl.Gfx.Map", color = "deepskyblue", fontcolor = "white", style = "filled"]
    efl_interface [fillcolor = "gray15", label = "Efl.Interface", color = "cornflowerblue", fontcolor = "white", style = "filled"]
    efl_object [fillcolor = "gray15", label = "Efl.Object", color = "gray15", fontcolor = "white", style = "filled"]
    efl_loop_user [fillcolor = "gray15", label = "Efl.Loop_User", color = "gray15", fontcolor = "white", style = "filled"]
    efl_object [fillcolor = "gray15", label = "Efl.Object", color = "gray15", fontcolor = "white", style = "filled"]
    efl_ui_focus_manager [fillcolor = "gray15", label = "Efl.Ui.Focus.Manager", color = "gray15", fontcolor = "white", style = "filled"]
    efl_object [fillcolor = "gray15", label = "Efl.Object", color = "gray15", fontcolor = "white", style = "filled"]

    elm_interface_scrollable -> efl_ui_scrollable
    elm_interface_scrollable -> efl_canvas_group
    efl_canvas_group -> efl_canvas_object
    efl_canvas_object -> efl_object
    efl_canvas_object -> efl_gfx
    efl_canvas_object -> efl_gfx_stack
    efl_canvas_object -> efl_animator
    efl_canvas_object -> efl_input_interface
    efl_canvas_object -> efl_gfx_size_hint
    efl_canvas_object -> efl_gfx_map
    efl_gfx_map -> efl_interface
    efl_gfx_map -> efl_object
    efl_canvas_object -> efl_loop_user
    efl_loop_user -> efl_object
    elm_interface_scrollable -> efl_ui_focus_manager
    efl_ui_focus_manager -> efl_object
}
</graphviz>

++++

===== Inheritance hierarchy =====

  * **[[:docs:efl:auto:mixin:elm:interface_scrollable|Elm.Interface_Scrollable]] //(mixin)//**
    * [[:docs:efl:auto:interface:efl:ui:scrollable|Efl.Ui.Scrollable]] //(interface)//
    * [[:docs:efl:auto:class:efl:canvas:group|Efl.Canvas.Group]] //(class)//
      * [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]] //(class)//
        * [[:docs:efl:auto:class:efl:object|Efl.Object]] //(class)//
        * [[:docs:efl:auto:interface:efl:gfx|Efl.Gfx]] //(interface)//
        * [[:docs:efl:auto:interface:efl:gfx:stack|Efl.Gfx.Stack]] //(interface)//
        * [[:docs:efl:auto:interface:efl:animator|Efl.Animator]] //(interface)//
        * [[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]] //(interface)//
        * [[:docs:efl:auto:interface:efl:gfx:size:hint|Efl.Gfx.Size.Hint]] //(interface)//
        * [[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]] //(mixin)//
          * [[:docs:efl:auto:interface:efl:interface|Efl.Interface]] //(interface)//
          * [[:docs:efl:auto:class:efl:object|Efl.Object]] //(class)//
        * [[:docs:efl:auto:class:efl:loop_user|Efl.Loop_User]] //(class)//
          * [[:docs:efl:auto:class:efl:object|Efl.Object]] //(class)//
    * [[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]] //(class)//
      * [[:docs:efl:auto:class:efl:object|Efl.Object]] //(class)//

===== Description =====

%%Elm scrollable mixin%%

{{page>:docs:efl:user:mixin:elm:interface_scrollable:description&nodate&nolink&nouser}}

===== Members =====

**[[:docs:efl:auto:mixin:elm:interface_scrollable:method:content_min_limit|content_min_limit]]**
<code c>
void elm_interface_scrollable_content_min_limit(Eo *obj, Eina_Bool w, Eina_Bool h);
</code>

%%Prevent the scrollable from being smaller than the minimum size of the content.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:method:content_pos_get|content_pos_get]]**
<code c>
void elm_interface_scrollable_content_pos_get(Eo *obj, int *x, int *y);
</code>

%%Get content position%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:method:content_pos_set|content_pos_set]]**
<code c>
void elm_interface_scrollable_content_pos_set(Eo *obj, int x, int y, Eina_Bool sig);
</code>

%%Set the content position%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:method:content_region_show|content_region_show]]**
<code c>
void elm_interface_scrollable_content_region_show(Eo *obj, int x, int y, int w, int h);
</code>

%%Show a specific virtual region within the scroller content object%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:method:page_bring_in|page_bring_in]]**
<code c>
void elm_interface_scrollable_page_bring_in(Eo *obj, int pagenumber_h, int pagenumber_v);
</code>

%%Show a specific virtual region within the scroller content object by page number.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:method:page_show|page_show]]**
<code c>
void elm_interface_scrollable_page_show(Eo *obj, int pagenumber_h, int pagenumber_v);
</code>

%%Show a specific virtual region within the scroller content object by page number.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:method:region_bring_in|region_bring_in]]**
<code c>
void elm_interface_scrollable_region_bring_in(Eo *obj, int x, int y, int w, int h);
</code>

%%Show a specific virtual region within the scroller content object.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:animate_start_cb|animate_start_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_animate_start_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb animate_start_cb);
</code>

%%Set the callback to run when the scrolling animation has started.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:animate_stop_cb|animate_stop_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_animate_stop_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb animate_stop_cb);
</code>

%%Set the callback to run when the scrolling animation has stopped.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:bounce_allow|bounce_allow]]** //**(get, set)**//
<code c>
void elm_interface_scrollable_bounce_allow_get(const Eo *obj, Eina_Bool *horiz, Eina_Bool *vert);
void elm_interface_scrollable_bounce_allow_set(Eo *obj, Eina_Bool horiz, Eina_Bool vert);
</code>

%%Bouncing behavior%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:bounce_animator_disabled|bounce_animator_disabled]]** //**(get, set)**//
<code c>
Eina_Bool elm_interface_scrollable_bounce_animator_disabled_get(const Eo *obj);
void elm_interface_scrollable_bounce_animator_disabled_set(Eo *obj, Eina_Bool disabled);
</code>

%%Bounce animator%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:content_min_limit_cb|content_min_limit_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_content_min_limit_cb_set(Eo *obj, Elm_Interface_Scrollable_Min_Limit_Cb min_limit_cb);
</code>

%%set the callback to run on minimal limit content%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:content_region|content_region]]** //**(get, set)**//
<code c>
void elm_interface_scrollable_content_region_get(const Eo *obj, int *x, int *y, int *w, int *h);
void elm_interface_scrollable_content_region_set(Eo *obj, int x, int y, int w, int h);
</code>

%%Currently visible content region%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:content_size|content_size]]** //**(get)**//
<code c>
void elm_interface_scrollable_content_size_get(const Eo *obj, int *w, int *h);
</code>

%%Get the size of the content object%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:content_viewport_geometry|content_viewport_geometry]]** //**(get)**//
<code c>
void elm_interface_scrollable_content_viewport_geometry_get(const Eo *obj, int *x, int *y, int *w, int *h);
</code>

%%Content viewport geometry%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:content_viewport_resize_cb|content_viewport_resize_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_content_viewport_resize_cb_set(Eo *obj, Elm_Interface_Scrollable_Resize_Cb viewport_resize_cb);
</code>

%%When the viewport is resized, the callback is called.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:content|content]]** //**(set)**//
<code c>
void elm_interface_scrollable_content_set(Eo *obj, Efl_Canvas_Object *content);
</code>

%%Content property%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:current_page|current_page]]** //**(get)**//
<code c>
void elm_interface_scrollable_current_page_get(const Eo *obj, int *pagenumber_h, int *pagenumber_v);
</code>

%%Get scroll current page number.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:drag_start_cb|drag_start_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_drag_start_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb drag_start_cb);
</code>

%%Set the callback to run when dragging of the contents has started.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:drag_stop_cb|drag_stop_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_drag_stop_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb drag_stop_cb);
</code>

%%Set the callback to run when dragging of the contents has stopped.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:edge_bottom_cb|edge_bottom_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_edge_bottom_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb edge_bottom_cb);
</code>

%%Set the callback to run when the bottom edge of the content has been reached.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:edge_left_cb|edge_left_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_edge_left_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb edge_left_cb);
</code>

%%Set the callback to run when the left edge of the content has been reached.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:edge_right_cb|edge_right_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_edge_right_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb edge_right_cb);
</code>

%%Set the callback to run when the right edge of the content has been reached.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:edge_top_cb|edge_top_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_edge_top_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb edge_top_cb);
</code>

%%Set the callback to run when the top edge of the content has been reached.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:extern_pan|extern_pan]]** //**(set)**//
<code c>
void elm_interface_scrollable_extern_pan_set(Eo *obj, Efl_Canvas_Object *pan);
</code>

%%Extern pan%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:freeze|freeze]]** //**(set)**//
<code c>
void elm_interface_scrollable_freeze_set(Eo *obj, Eina_Bool freeze);
</code>

%%Freeze property%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:gravity|gravity]]** //**(get, set)**//
<code c>
void elm_interface_scrollable_gravity_get(const Eo *obj, double *x, double *y);
void elm_interface_scrollable_gravity_set(Eo *obj, double x, double y);
</code>

%%Control scrolling gravity on the scrollable%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:hbar_drag_cb|hbar_drag_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_hbar_drag_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb hbar_drag_cb);
</code>

%%Set the callback to run when the horizontal scrollbar is dragged.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:hbar_press_cb|hbar_press_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_hbar_press_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb hbar_press_cb);
</code>

%%Set the callback to run when the horizontal scrollbar is pressed.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:hbar_unpress_cb|hbar_unpress_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_hbar_unpress_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb hbar_unpress_cb);
</code>

%%Set the callback to run when the horizontal scrollbar is unpressed.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:hold|hold]]** //**(set)**//
<code c>
void elm_interface_scrollable_hold_set(Eo *obj, Eina_Bool hold);
</code>

%%Hold property%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:last_page|last_page]]** //**(get)**//
<code c>
void elm_interface_scrollable_last_page_get(const Eo *obj, int *pagenumber_h, int *pagenumber_v);
</code>

%%Get scroll last page number.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:loop|loop]]** //**(get, set)**//
<code c>
void elm_interface_scrollable_loop_get(const Eo *obj, Eina_Bool *loop_h, Eina_Bool *loop_v);
void elm_interface_scrollable_loop_set(Eo *obj, Eina_Bool loop_h, Eina_Bool loop_v);
</code>

%%Controls an infinite loop for a scroller.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:mirrored|mirrored]]** //**(set)**//
<code c>
void elm_interface_scrollable_mirrored_set(Eo *obj, Eina_Bool mirrored);
</code>

%%Mirroed property%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:momentum_animator_disabled|momentum_animator_disabled]]** //**(get, set)**//
<code c>
Eina_Bool elm_interface_scrollable_momentum_animator_disabled_get(const Eo *obj);
void elm_interface_scrollable_momentum_animator_disabled_set(Eo *obj, Eina_Bool disabled);
</code>

%%Momentum animator%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:movement_block|movement_block]]** //**(get, set)**//
<code c>
Elm_Scroller_Movement_Block elm_interface_scrollable_movement_block_get(const Eo *obj);
void elm_interface_scrollable_movement_block_set(Eo *obj, Elm_Scroller_Movement_Block block);
</code>

%%Blocking of scrolling (per axis)%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:objects|objects]]** //**(set)**//
<code c>
void elm_interface_scrollable_objects_set(Eo *obj, Efl_Canvas_Object *edje_object, Efl_Canvas_Object *hit_rectangle);
</code>

%%Object property%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:page_change_cb|page_change_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_page_change_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb page_change_cb);
</code>

%%Set the callback to run when the visible page changes.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:page_relative|page_relative]]** //**(set)**//
<code c>
void elm_interface_scrollable_page_relative_set(Eo *obj, double h_pagerel, double v_pagerel);
</code>

%%Set scroll page size relative to viewport size.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:page_scroll_limit|page_scroll_limit]]** //**(get, set)**//
<code c>
void elm_interface_scrollable_page_scroll_limit_get(const Eo *obj, int *page_limit_h, int *page_limit_v);
void elm_interface_scrollable_page_scroll_limit_set(Eo *obj, int page_limit_h, int page_limit_v);
</code>

%%Page scroll limit%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:page_size|page_size]]** //**(get, set)**//
<code c>
void elm_interface_scrollable_page_size_get(const Eo *obj, int *x, int *y);
void elm_interface_scrollable_page_size_set(Eo *obj, int x, int y);
</code>

%%Scroll page size relative to viewport size.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:page_snap_allow|page_snap_allow]]** //**(get, set)**//
<code c>
void elm_interface_scrollable_page_snap_allow_get(const Eo *obj, Eina_Bool *horiz, Eina_Bool *vert);
void elm_interface_scrollable_page_snap_allow_set(Eo *obj, Eina_Bool horiz, Eina_Bool vert);
</code>

%%Page snapping behavior%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:paging|paging]]** //**(get, set)**//
<code c>
void elm_interface_scrollable_paging_get(const Eo *obj, double *pagerel_h, double *pagerel_v, int *pagesize_h, int *pagesize_v);
void elm_interface_scrollable_paging_set(Eo *obj, double pagerel_h, double pagerel_v, int pagesize_h, int pagesize_v);
</code>

%%Pagin property%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:policy|policy]]** //**(get, set)**//
<code c>
void elm_interface_scrollable_policy_get(const Eo *obj, Elm_Scroller_Policy *hbar, Elm_Scroller_Policy *vbar);
void elm_interface_scrollable_policy_set(Eo *obj, Elm_Scroller_Policy hbar, Elm_Scroller_Policy vbar);
</code>

%%Scrollbar visibility policy%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:repeat_events|repeat_events]]** //**(get, set)**//
<code c>
Eina_Bool elm_interface_scrollable_repeat_events_get(const Eo *obj);
void elm_interface_scrollable_repeat_events_set(Eo *obj, Eina_Bool repeat_events);
</code>

%%It decides whether the scrollable object propagates the events to content object or not.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:scroll_cb|scroll_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_scroll_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb scroll_cb);
</code>

%%Set the callback to run when the content has been moved.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:scroll_down_cb|scroll_down_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_scroll_down_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb scroll_down_cb);
</code>

%%Set the callback to run when the content has been moved down.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:scroll_left_cb|scroll_left_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_scroll_left_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb scroll_left_cb);
</code>

%%Set the callback to run when the content has been moved to the left%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:scroll_right_cb|scroll_right_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_scroll_right_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb scroll_right_cb);
</code>

%%Set the callback to run when the content has been moved to the right.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:scroll_up_cb|scroll_up_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_scroll_up_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb scroll_up_cb);
</code>

%%Set the callback to run when the content has been moved up.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:single_direction|single_direction]]** //**(get, set)**//
<code c>
Elm_Scroller_Single_Direction elm_interface_scrollable_single_direction_get(const Eo *obj);
void elm_interface_scrollable_single_direction_set(Eo *obj, Elm_Scroller_Single_Direction single_dir);
</code>

%%Single direction scroll configuration%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:step_size|step_size]]** //**(get, set)**//
<code c>
void elm_interface_scrollable_step_size_get(const Eo *obj, int *x, int *y);
void elm_interface_scrollable_step_size_set(Eo *obj, int x, int y);
</code>

%%Step size%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:vbar_drag_cb|vbar_drag_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_vbar_drag_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb vbar_drag_cb);
</code>

%%Set the callback to run when the horizontal scrollbar is dragged.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:vbar_press_cb|vbar_press_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_vbar_press_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb vbar_press_cb);
</code>

%%Set the callback to run when the vertical scrollbar is pressed.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:vbar_unpress_cb|vbar_unpress_cb]]** //**(set)**//
<code c>
void elm_interface_scrollable_vbar_unpress_cb_set(Eo *obj, Elm_Interface_Scrollable_Cb vbar_unpress_cb);
</code>

%%Set the callback to run when the horizontal scrollbar is unpressed.%%\\ 
\\ 
**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:wheel_disabled|wheel_disabled]]** //**(get, set)**//
<code c>
Eina_Bool elm_interface_scrollable_wheel_disabled_get(const Eo *obj);
void elm_interface_scrollable_wheel_disabled_set(Eo *obj, Eina_Bool disabled);
</code>

%%Control Wheel disable Enable or disable mouse wheel to be used to scroll the scroller content. heel is enabled by default.%%\\ 
\\ 

==== Inherited ====

[[:docs:efl:auto:class:efl:canvas:group|Efl.Canvas.Group]].**[[:docs:efl:auto:class:efl:canvas:group:method:group_calculate|group_calculate]]**
<code c>
void efl_canvas_group_calculate(Eo *obj);
</code>

%%Triggers an immediate recalculation of this object's geometry.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:group|Efl.Canvas.Group]].**[[:docs:efl:auto:class:efl:canvas:group:method:group_change|group_change]]**
<code c>
void efl_canvas_group_change(Eo *obj);
</code>

%%Marks the object as dirty.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:group|Efl.Canvas.Group]].**[[:docs:efl:auto:class:efl:canvas:group:method:group_children_iterate|group_children_iterate]]**
<code c>
Eina_Iterator *efl_canvas_group_children_iterate(const Eo *obj);
</code>

%%Returns an iterator over the children of this object, that are canvas objects.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:group|Efl.Canvas.Group]].**[[:docs:efl:auto:class:efl:canvas:group:method:group_member_add|group_member_add]]**
<code c>
void efl_canvas_group_member_add(Eo *obj, Efl_Canvas_Object *sub_obj);
</code>

%%Set an Evas object as a member of a given smart object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:group|Efl.Canvas.Group]].**[[:docs:efl:auto:class:efl:canvas:group:method:group_member_del|group_member_del]]**
<code c>
void efl_canvas_group_member_del(Eo *obj, Efl_Canvas_Object *sub_obj);
</code>

%%Removes a member object from a given smart object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:group|Efl.Canvas.Group]].**[[:docs:efl:auto:class:efl:canvas:group:property:group_need_recalculate|group_need_recalculate]]** //**(get, set)**//
<code c>
Eina_Bool efl_canvas_group_need_recalculate_get(const Eo *obj);
void efl_canvas_group_need_recalculate_set(Eo *obj, Eina_Bool value);
</code>

%%Indicates that the group's layout need to be recalculated.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:group:property:no_render|no_render]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:group|Efl.Canvas.Group]]]//
<code c>
Eina_Bool efl_canvas_object_no_render_get(const Eo *obj);
void efl_canvas_object_no_render_set(Eo *obj, Eina_Bool enable);
</code>

\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:group:property:paragraph_direction|paragraph_direction]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:group|Efl.Canvas.Group]]]//
<code c>
Efl_Text_Bidirectional_Type efl_canvas_object_paragraph_direction_get(const Eo *obj);
void efl_canvas_object_paragraph_direction_set(Eo *obj, Efl_Text_Bidirectional_Type dir);
</code>

%%This handles text paragraph direction of the given object. Even if the given object is not textblock or text, its smart child objects can inherit the paragraph direction from the given object. The default paragraph direction is %%''inherit''%%.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:method:clipees_has|clipees_has]]**
<code c>
Eina_Bool efl_canvas_object_clipees_has(const Eo *obj);
</code>

%%Test if any object is clipped by %%''obj''%%.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:method:key_grab|key_grab]]**
<code c>
Eina_Bool efl_canvas_object_key_grab(Eo *obj, const char *keyname, Efl_Input_Modifier modifiers, Efl_Input_Modifier not_modifiers, Eina_Bool exclusive);
</code>

%%Requests %%''keyname''%% key events be directed to %%''obj''%%.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:method:key_ungrab|key_ungrab]]**
<code c>
void efl_canvas_object_key_ungrab(Eo *obj, const char *keyname, Efl_Input_Modifier modifiers, Efl_Input_Modifier not_modifiers);
</code>

%%Removes the grab on %%''keyname''%% key events by %%''obj''%%.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:method:seat_focus_add|seat_focus_add]]**
<code c>
Eina_Bool efl_canvas_object_seat_focus_add(Eo *obj, Efl_Input_Device *seat);
</code>

%%Add a seat to the focus list.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:method:seat_focus_check|seat_focus_check]]**
<code c>
Eina_Bool efl_canvas_object_seat_focus_check(Eo *obj, Efl_Input_Device *seat);
</code>

%%Check if this object is focused by a given seat%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:method:seat_focus_del|seat_focus_del]]**
<code c>
Eina_Bool efl_canvas_object_seat_focus_del(Eo *obj, Efl_Input_Device *seat);
</code>

%%Remove a seat from the focus list.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:anti_alias|anti_alias]]** //**(get, set)**//
<code c>
Eina_Bool efl_canvas_object_anti_alias_get(const Eo *obj);
void efl_canvas_object_anti_alias_set(Eo *obj, Eina_Bool anti_alias);
</code>

\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:clipees|clipees]]** //**(get)**//
<code c>
Eina_Iterator *efl_canvas_object_clipees_get(const Eo *obj);
</code>

%%Return a list of objects currently clipped by %%''obj''%%.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:clip|clip]]** //**(get, set)**//
<code c>
Efl_Canvas_Object *efl_canvas_object_clip_get(const Eo *obj);
void efl_canvas_object_clip_set(Eo *obj, Efl_Canvas_Object *clip);
</code>

\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:freeze_events|freeze_events]]** //**(get, set)**//
<code c>
Eina_Bool efl_canvas_object_freeze_events_get(const Eo *obj);
void efl_canvas_object_freeze_events_set(Eo *obj, Eina_Bool freeze);
</code>

\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:is_frame_object|is_frame_object]]** //**(get, set)**//
<code c>
Eina_Bool efl_canvas_object_is_frame_object_get(const Eo *obj);
void efl_canvas_object_is_frame_object_set(Eo *obj, Eina_Bool is_frame);
</code>

%%If %%''true''%% the object belongs to the window border decorations.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:key_focus|key_focus]]** //**(get, set)**//
<code c>
Eina_Bool efl_canvas_object_key_focus_get(const Eo *obj);
void efl_canvas_object_key_focus_set(Eo *obj, Eina_Bool focus);
</code>

%%Indicates that this object is the keyboard event receiver on its canvas.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:pass_events|pass_events]]** //**(get, set)**//
<code c>
Eina_Bool efl_canvas_object_pass_events_get(const Eo *obj);
void efl_canvas_object_pass_events_set(Eo *obj, Eina_Bool pass);
</code>

\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:pointer_device_in|pointer_device_in]]** //**(get)**//
<code c>
Eina_Bool efl_canvas_object_pointer_device_in_get(const Eo *obj, Efl_Input_Device *pointer);
</code>

%%Read-only value indicating whether a pointer is in the object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:pointer_in|pointer_in]]** //**(get)**//
<code c>
Eina_Bool efl_canvas_object_pointer_in_get(const Eo *obj);
</code>

%%Read-only value indicating whether the main pointer is in the object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:pointer_mode_by_device|pointer_mode_by_device]]** //**(get, set)**//
<code c>
Efl_Input_Object_Pointer_Mode efl_canvas_object_pointer_mode_by_device_get(const Eo *obj, Efl_Input_Device *dev);
Eina_Bool efl_canvas_object_pointer_mode_by_device_set(Eo *obj, Efl_Input_Device *dev, Efl_Input_Object_Pointer_Mode pointer_mode);
</code>

%%Low-level pointer behaviour by device. See %%[[:docs:efl:auto:class:efl:canvas:object:property:pointer_mode|Efl.Canvas.Object.pointer_mode.get]]%% and %%[[:docs:efl:auto:class:efl:canvas:object:property:pointer_mode|Efl.Canvas.Object.pointer_mode.set]]%% for more explanation.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:pointer_mode|pointer_mode]]** //**(get, set)**//
<code c>
Efl_Input_Object_Pointer_Mode efl_canvas_object_pointer_mode_get(const Eo *obj);
Eina_Bool efl_canvas_object_pointer_mode_set(Eo *obj, Efl_Input_Object_Pointer_Mode pointer_mode);
</code>

%%Low-level pointer behaviour.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:precise_is_inside|precise_is_inside]]** //**(get, set)**//
<code c>
Eina_Bool efl_canvas_object_precise_is_inside_get(const Eo *obj);
void efl_canvas_object_precise_is_inside_set(Eo *obj, Eina_Bool precise);
</code>

\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:propagate_events|propagate_events]]** //**(get, set)**//
<code c>
Eina_Bool efl_canvas_object_propagate_events_get(const Eo *obj);
void efl_canvas_object_propagate_events_set(Eo *obj, Eina_Bool propagate);
</code>

\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:render_op|render_op]]** //**(get, set)**//
<code c>
Efl_Gfx_Render_Op efl_canvas_object_render_op_get(const Eo *obj);
void efl_canvas_object_render_op_set(Eo *obj, Efl_Gfx_Render_Op render_op);
</code>

%%Render mode to be used for compositing the Evas object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:repeat_events|repeat_events]]** //**(get, set)**//
<code c>
Eina_Bool efl_canvas_object_repeat_events_get(const Eo *obj);
void efl_canvas_object_repeat_events_set(Eo *obj, Eina_Bool repeat);
</code>

\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:scale|scale]]** //**(get, set)**//
<code c>
double efl_canvas_object_scale_get(const Eo *obj);
void efl_canvas_object_scale_set(Eo *obj, double scale);
</code>

\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:seat_focus|seat_focus]]** //**(get)**//
<code c>
Eina_Bool efl_canvas_object_seat_focus_get(const Eo *obj);
</code>

%%Check if this object is focused.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:loop_user|Efl.Loop_User]].**[[:docs:efl:auto:class:efl:canvas:object:property:loop|loop]]** //**(get)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
Efl_Loop *efl_loop_get(const Eo *obj);
</code>

%%The loop to which this object belongs to.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:canvas:group:method:destructor|destructor]]** //[Overridden in [[:docs:efl:auto:class:efl:canvas:group|Efl.Canvas.Group]]]//
<code c>
void efl_destructor(Eo *obj);
</code>

%%Call the object's destructor.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:canvas:object:method:provider_find|provider_find]]** //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
Efl_Object *efl_provider_find(Eo *obj, const Efl_Object *klass);
</code>

%%Searches up in the object tree for a provider which knows the given class/interface.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:children_iterator_new|children_iterator_new]]**
<code c>
Eina_Iterator *efl_children_iterator_new(Eo *obj);
</code>

%%Get an iterator on all childrens%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:composite_attach|composite_attach]]**
<code c>
Eina_Bool efl_composite_attach(Eo *obj, Efl_Object *comp_obj);
</code>

%%Make an object a composite object of another.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:composite_detach|composite_detach]]**
<code c>
Eina_Bool efl_composite_detach(Eo *obj, Efl_Object *comp_obj);
</code>

%%Detach a composite object from another object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:composite_part_is|composite_part_is]]**
<code c>
Eina_Bool efl_composite_part_is(Eo *obj);
</code>

%%Check if an object is part of a composite object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:del|del]]**
<code c>
void efl_del(const Eo *obj);
</code>

%%Unrefs the object and reparents it to NULL.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_callback_forwarder_add|event_callback_forwarder_add]]**
<code c>
void efl_event_callback_forwarder_add(Eo *obj, const Efl_Event_Description *desc, Efl_Object *new_obj);
</code>

%%Add an event callback forwarder for an event and an object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_callback_forwarder_del|event_callback_forwarder_del]]**
<code c>
void efl_event_callback_forwarder_del(Eo *obj, const Efl_Event_Description *desc, Efl_Object *new_obj);
</code>

%%Remove an event callback forwarder for an event and an object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_callback_stop|event_callback_stop]]**
<code c>
void efl_event_callback_stop(Eo *obj);
</code>

%%Stop the current callback call.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_freeze|event_freeze]]**
<code c>
void efl_event_freeze(Eo *obj);
</code>

%%Freeze events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_global_freeze|event_global_freeze]]**
<code c>
void efl_event_global_freeze(const Eo *obj);
</code>

%%Freeze events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_global_thaw|event_global_thaw]]**
<code c>
void efl_event_global_thaw(const Eo *obj);
</code>

%%Thaw events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_thaw|event_thaw]]**
<code c>
void efl_event_thaw(Eo *obj);
</code>

%%Thaw events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:finalize|finalize]]**
<code c>
Efl_Object *efl_finalize(Eo *obj);
</code>

%%Called at the end of #eo_add. Should not be called, just overridden.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:name_find|name_find]]**
<code c>
Efl_Object *efl_name_find(Eo *obj, const char *search);
</code>

%%Find a child object with the given name and return it. The search string can be a glob (shell style). It can also specify class name in the format of "class:name" where ":" separates class and name. Both class and name can be globs. If class is specified, and name is empty like "class:" then the search will match any object of that class.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:comment|comment]]** //**(get, set)**//
<code c>
const char *efl_comment_get(const Eo *obj);
void efl_comment_set(Eo *obj, const char *comment);
</code>

%%A human readable comment for the object%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:event_freeze_count|event_freeze_count]]** //**(get)**//
<code c>
int efl_event_freeze_count_get(const Eo *obj);
</code>

%%Return freeze events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:event_global_freeze_count|event_global_freeze_count]]** //**(get)**//
<code c>
int efl_event_global_freeze_count_get(const Eo *obj);
</code>

%%Return freeze events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:finalized|finalized]]** //**(get)**//
<code c>
Eina_Bool efl_finalized_get(const Eo *obj);
</code>

%%True if the object is already finalized, false otherwise.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:name|name]]** //**(get, set)**//
<code c>
const char *efl_name_get(const Eo *obj);
void efl_name_set(Eo *obj, const char *name);
</code>

%%The name of the object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:parent|parent]]** //**(get, set)**//
<code c>
Efl_Object *efl_parent_get(const Eo *obj);
void efl_parent_set(Eo *obj, Efl_Object *parent);
</code>

%%The parent of an object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:mixin:elm:interface_scrollable:method:constructor|constructor]]** //[Overridden here]//
<code c>
Efl_Object *efl_constructor(Eo *obj);
</code>

%%Call the object's constructor.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:method:fetch|fetch]]**
<code c>
Efl_Ui_Focus_Relations *efl_ui_focus_manager_fetch(Eo *obj, Efl_Ui_Focus_Object *child);
</code>

%%This will fetch the data from a registered node.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:method:focused|focused]]**
<code c>
Efl_Ui_Focus_Object *efl_ui_focus_manager_focused(Eo *obj);
</code>

%%Return the currently focused element of this manager.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:method:logical_end|logical_end]]**
<code c>
Efl_Ui_Focus_Object *efl_ui_focus_manager_logical_end(Eo *obj);
</code>

%%Return the last logical object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:method:move|move]]**
<code c>
Efl_Ui_Focus_Object *efl_ui_focus_manager_move(Eo *obj, Efl_Ui_Focus_Direction direction);
</code>

%%Move the focus into the given direction.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:method:register_logical|register_logical]]**
<code c>
Eina_Bool efl_ui_focus_manager_register_logical(Eo *obj, Efl_Ui_Focus_Object *child, Efl_Ui_Focus_Object *parent, Efl_Ui_Focus_Manager *redirect);
</code>

%%Register a new item just for the logical parent.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:method:register|register]]**
<code c>
Eina_Bool efl_ui_focus_manager_register(Eo *obj, Efl_Ui_Focus_Object *child, Efl_Ui_Focus_Object *parent, Efl_Ui_Focus_Manager *redirect);
</code>

%%Register a new item in the graph.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:method:request_move|request_move]]**
<code c>
Efl_Ui_Focus_Object *efl_ui_focus_manager_request_move(Eo *obj, Efl_Ui_Focus_Direction direction);
</code>

%%Returns the object which would be the next object to focus in the given direction.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:method:unregister|unregister]]**
<code c>
void efl_ui_focus_manager_unregister(Eo *obj, Efl_Ui_Focus_Object *child);
</code>

%%Unregister the given item from the focus graph.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:method:update_children|update_children]]**
<code c>
Eina_Bool efl_ui_focus_manager_update_children(Eo *obj, Efl_Ui_Focus_Object *parent, Eina_List *children);
</code>

%%Give the list of children a different order.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:method:update_order|update_order]]**
<code c>
void efl_ui_focus_manager_update_order(Eo *obj, Efl_Ui_Focus_Object *parent, Eina_List *children);
</code>

%%Give the given order to the parent's child.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:method:update_parent|update_parent]]**
<code c>
Eina_Bool efl_ui_focus_manager_update_parent(Eo *obj, Efl_Ui_Focus_Object *child, Efl_Ui_Focus_Object *parent);
</code>

%%Set a new logical parent for the given child.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:method:update_redirect|update_redirect]]**
<code c>
Eina_Bool efl_ui_focus_manager_update_redirect(Eo *obj, Efl_Ui_Focus_Object *child, Efl_Ui_Focus_Manager *redirect);
</code>

%%Set a new redirect object for the given child.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:property:redirect|redirect]]** //**(get, set)**//
<code c>
Efl_Ui_Focus_Manager *efl_ui_focus_manager_redirect_get(const Eo *obj);
void efl_ui_focus_manager_redirect_set(Eo *obj, Efl_Ui_Focus_Manager *redirect);
</code>

%%Add a another manager to serve the move requests.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:property:root|root]]** //**(get, set)**//
<code c>
Efl_Ui_Focus_Object *efl_ui_focus_manager_root_get(const Eo *obj);
Eina_Bool efl_ui_focus_manager_root_set(Eo *obj, Efl_Ui_Focus_Object *root);
</code>

%%Root node for all logical subtrees.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:mixin:elm:interface_scrollable:method:focus|focus]]** //[Overridden here]//
<code c>
void efl_ui_focus_manager_focus(Eo *obj, Efl_Ui_Focus_Object *focus);
</code>

%%Make the given object the currently focused object in this manager.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:mixin:elm:interface_scrollable:property:border_elements|border_elements]]** //**(get)**// //[Overridden here]//
<code c>
Eina_Iterator *efl_ui_focus_manager_border_elements_get(const Eo *obj);
</code>

%%The list of elements which are at the border of the graph.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:size:hint|Efl.Gfx.Size.Hint]].**[[:docs:efl:auto:class:efl:canvas:object:property:hint_align|hint_align]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_size_hint_align_get(const Eo *obj, double *x, double *y);
void efl_gfx_size_hint_align_set(Eo *obj, double x, double y);
</code>

%%Hints for an object's alignment.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:size:hint|Efl.Gfx.Size.Hint]].**[[:docs:efl:auto:class:efl:canvas:object:property:hint_aspect|hint_aspect]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_size_hint_aspect_get(const Eo *obj, Efl_Gfx_Size_Hint_Aspect *mode, int *w, int *h);
void efl_gfx_size_hint_aspect_set(Eo *obj, Efl_Gfx_Size_Hint_Aspect mode, int w, int h);
</code>

%%Defines the aspect ratio to respect when scaling this object.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:size:hint|Efl.Gfx.Size.Hint]].**[[:docs:efl:auto:class:efl:canvas:object:property:hint_combined_min|hint_combined_min]]** //**(get)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_size_hint_combined_min_get(const Eo *obj, int *w, int *h);
</code>

%%Read-only minimum size combining both %%[[:docs:efl:auto:interface:efl:gfx:size:hint:property:hint_restricted_min|Efl.Gfx.Size.Hint.hint_restricted_min]]%% and %%[[:docs:efl:auto:interface:efl:gfx:size:hint:property:hint_min|Efl.Gfx.Size.Hint.hint_min]]%% size hints.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:size:hint|Efl.Gfx.Size.Hint]].**[[:docs:efl:auto:class:efl:canvas:object:property:hint_display_mode|hint_display_mode]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
Efl_Gfx_Size_Hint_Mode efl_gfx_size_hint_display_mode_get(const Eo *obj);
void efl_gfx_size_hint_display_mode_set(Eo *obj, Efl_Gfx_Size_Hint_Mode dispmode);
</code>

%%A hint for an object's display mode.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:size:hint|Efl.Gfx.Size.Hint]].**[[:docs:efl:auto:class:efl:canvas:object:property:hint_margin|hint_margin]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_size_hint_margin_get(const Eo *obj, int *l, int *r, int *t, int *b);
void efl_gfx_size_hint_margin_set(Eo *obj, int l, int r, int t, int b);
</code>

%%Hints for an object's margin or padding space.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:size:hint|Efl.Gfx.Size.Hint]].**[[:docs:efl:auto:class:efl:canvas:object:property:hint_max|hint_max]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_size_hint_max_get(const Eo *obj, int *w, int *h);
void efl_gfx_size_hint_max_set(Eo *obj, int w, int h);
</code>

%%Hints on the object's maximum size.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:size:hint|Efl.Gfx.Size.Hint]].**[[:docs:efl:auto:class:efl:canvas:object:property:hint_min|hint_min]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_size_hint_min_get(const Eo *obj, int *w, int *h);
void efl_gfx_size_hint_min_set(Eo *obj, int w, int h);
</code>

%%Hints on the object's minimum size.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:size:hint|Efl.Gfx.Size.Hint]].**[[:docs:efl:auto:class:efl:canvas:object:property:hint_request|hint_request]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_size_hint_request_get(const Eo *obj, int *w, int *h);
void efl_gfx_size_hint_request_set(Eo *obj, int w, int h);
</code>

%%Hints for the object's optimum size.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:size:hint|Efl.Gfx.Size.Hint]].**[[:docs:efl:auto:class:efl:canvas:object:property:hint_restricted_min|hint_restricted_min]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]// ''protected set''
<code c>
void efl_gfx_size_hint_restricted_min_get(const Eo *obj, int *w, int *h);
void efl_gfx_size_hint_restricted_min_set(Eo *obj, int w, int h);
</code>

%%Internal hints for an object's minimum size.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:size:hint|Efl.Gfx.Size.Hint]].**[[:docs:efl:auto:class:efl:canvas:object:property:hint_weight|hint_weight]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_size_hint_weight_get(const Eo *obj, double *x, double *y);
void efl_gfx_size_hint_weight_set(Eo *obj, double x, double y);
</code>

%%Hints for an object's weight.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:size:hint|Efl.Gfx.Size.Hint]].**[[:docs:efl:auto:interface:efl:gfx:size:hint:property:hint_base|hint_base]]** //**(get, set)**//
<code c>
void efl_gfx_size_hint_base_get(const Eo *obj, int *w, int *h);
void efl_gfx_size_hint_base_set(Eo *obj, int w, int h);
</code>

%%Base size for objects with sizing restrictions.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:size:hint|Efl.Gfx.Size.Hint]].**[[:docs:efl:auto:interface:efl:gfx:size:hint:property:hint_step|hint_step]]** //**(get, set)**//
<code c>
void efl_gfx_size_hint_step_get(const Eo *obj, int *w, int *h);
void efl_gfx_size_hint_step_set(Eo *obj, int w, int h);
</code>

%%Step size for objects with sizing restrictions.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:stack|Efl.Gfx.Stack]].**[[:docs:efl:auto:class:efl:canvas:object:method:lower|lower]]** //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_stack_lower(Eo *obj);
</code>

%%Lower %%''obj''%% to the bottom of its layer.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:stack|Efl.Gfx.Stack]].**[[:docs:efl:auto:class:efl:canvas:object:method:raise|raise]]** //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_stack_raise(Eo *obj);
</code>

%%Raise %%''obj''%% to the top of its layer.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:stack|Efl.Gfx.Stack]].**[[:docs:efl:auto:class:efl:canvas:object:method:stack_above|stack_above]]** //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_stack_above(Eo *obj, Efl_Gfx_Stack *above);
</code>

%%Stack %%''obj''%% immediately %%''above''%%%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:stack|Efl.Gfx.Stack]].**[[:docs:efl:auto:class:efl:canvas:object:method:stack_below|stack_below]]** //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_stack_below(Eo *obj, Efl_Gfx_Stack *below);
</code>

%%Stack %%''obj''%% immediately %%''below''%%%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:stack|Efl.Gfx.Stack]].**[[:docs:efl:auto:class:efl:canvas:object:property:above|above]]** //**(get)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
Efl_Gfx_Stack *efl_gfx_stack_above_get(const Eo *obj);
</code>

%%Get the Evas object stacked right above %%''obj''%%%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:stack|Efl.Gfx.Stack]].**[[:docs:efl:auto:class:efl:canvas:object:property:below|below]]** //**(get)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
Efl_Gfx_Stack *efl_gfx_stack_below_get(const Eo *obj);
</code>

%%Get the Evas object stacked right below %%''obj''%%%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:stack|Efl.Gfx.Stack]].**[[:docs:efl:auto:class:efl:canvas:object:property:layer|layer]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
short efl_gfx_stack_layer_get(const Eo *obj);
void efl_gfx_stack_layer_set(Eo *obj, short l);
</code>

\\ 
[[:docs:efl:auto:interface:efl:gfx|Efl.Gfx]].**[[:docs:efl:auto:class:efl:canvas:object:property:color_part|color_part]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
Eina_Bool efl_gfx_color_part_get(const Eo *obj, const char *part, int *r, int *g, int *b, int *a);
Eina_Bool efl_gfx_color_part_set(Eo *obj, const char *part, int r, int g, int b, int a);
</code>

\\ 
[[:docs:efl:auto:interface:efl:gfx|Efl.Gfx]].**[[:docs:efl:auto:class:efl:canvas:object:property:color|color]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_color_get(const Eo *obj, int *r, int *g, int *b, int *a);
void efl_gfx_color_set(Eo *obj, int r, int g, int b, int a);
</code>

\\ 
[[:docs:efl:auto:interface:efl:gfx|Efl.Gfx]].**[[:docs:efl:auto:class:efl:canvas:object:property:geometry|geometry]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_geometry_get(const Eo *obj, int *x, int *y, int *w, int *h);
void efl_gfx_geometry_set(Eo *obj, int x, int y, int w, int h);
</code>

%%Rectangular geometry that combines both position and size.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx|Efl.Gfx]].**[[:docs:efl:auto:class:efl:canvas:object:property:position|position]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_position_get(const Eo *obj, int *x, int *y);
void efl_gfx_position_set(Eo *obj, int x, int y);
</code>

%%The 2D position of a canvas object.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx|Efl.Gfx]].**[[:docs:efl:auto:class:efl:canvas:object:property:size|size]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
void efl_gfx_size_get(const Eo *obj, int *w, int *h);
void efl_gfx_size_set(Eo *obj, int w, int h);
</code>

%%The 2D size of a canvas object.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx|Efl.Gfx]].**[[:docs:efl:auto:class:efl:canvas:object:property:visible|visible]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
Eina_Bool efl_gfx_visible_get(const Eo *obj);
void efl_gfx_visible_set(Eo *obj, Eina_Bool v);
</code>

\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:class:efl:canvas:object:property:seat_event_filter|seat_event_filter]]** //**(get, set)**// //[Overridden in [[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]]]//
<code c>
Eina_Bool efl_input_seat_event_filter_get(const Eo *obj, Efl_Input_Device *seat);
void efl_input_seat_event_filter_set(Eo *obj, Efl_Input_Device *seat, Eina_Bool enable);
</code>

\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:method:pointer_iterate|pointer_iterate]]**
<code c>
Eina_Iterator *efl_input_pointer_iterate(const Eo *obj, Eina_Bool hover);
</code>

%%Returns an iterator over the current known pointer positions.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:property:pointer_inside|pointer_inside]]** //**(get)**//
<code c>
Eina_Bool efl_input_pointer_inside_get(const Eo *obj);
</code>

%%Returns whether the mouse pointer is logically inside the canvas.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:property:pointer_xy|pointer_xy]]** //**(get)**//
<code c>
void efl_input_pointer_xy_get(const Eo *obj, int *x, int *y);
</code>

%%This function returns the current known pointer coordinates%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:method:lightning_3d_absolute|lightning_3d_absolute]]**
<code c>
void efl_gfx_map_lightning_3d_absolute(Eo *obj, double lx, double ly, double lz, int lr, int lg, int lb, int ar, int ag, int ab);
</code>

%%Apply a lightning effect on the object.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:method:lightning_3d|lightning_3d]]**
<code c>
void efl_gfx_map_lightning_3d(Eo *obj, const Efl_Gfx *pivot, double lx, double ly, double lz, int lr, int lg, int lb, int ar, int ag, int ab);
</code>

%%Apply a lightning effect on the object.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:method:map_has|map_has]]**
<code c>
Eina_Bool efl_gfx_map_has(Eo *obj);
</code>

%%Read-only property indicating whether an object is mapped.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:method:map_reset|map_reset]]**
<code c>
void efl_gfx_map_reset(Eo *obj);
</code>

%%Resets the map transformation to its default state.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:method:perspective_3d_absolute|perspective_3d_absolute]]**
<code c>
void efl_gfx_map_perspective_3d_absolute(Eo *obj, double px, double py, double z0, double foc);
</code>

%%Apply a perspective transform to the map%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:method:perspective_3d|perspective_3d]]**
<code c>
void efl_gfx_map_perspective_3d(Eo *obj, const Efl_Gfx *pivot, double px, double py, double z0, double foc);
</code>

%%Apply a perspective transform to the map%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:method:rotate_3d_absolute|rotate_3d_absolute]]**
<code c>
void efl_gfx_map_rotate_3d_absolute(Eo *obj, double dx, double dy, double dz, double cx, double cy, double cz);
</code>

%%Rotate the object around 3 axes in 3D, using absolute coordinates.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:method:rotate_3d|rotate_3d]]**
<code c>
void efl_gfx_map_rotate_3d(Eo *obj, double dx, double dy, double dz, const Efl_Gfx *pivot, double cx, double cy, double cz);
</code>

%%Rotate the object around 3 axes in 3D.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:method:rotate_absolute|rotate_absolute]]**
<code c>
void efl_gfx_map_rotate_absolute(Eo *obj, double degrees, double cx, double cy);
</code>

%%Apply a rotation to the object, using absolute coordinates.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:method:rotate_quat_absolute|rotate_quat_absolute]]**
<code c>
void efl_gfx_map_rotate_quat_absolute(Eo *obj, double qx, double qy, double qz, double qw, double cx, double cy, double cz);
</code>

%%Rotate the object in 3D using a unit quaternion, using absolute coordinates.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:method:rotate_quat|rotate_quat]]**
<code c>
void efl_gfx_map_rotate_quat(Eo *obj, double qx, double qy, double qz, double qw, const Efl_Gfx *pivot, double cx, double cy, double cz);
</code>

%%Rotate the object in 3D using a unit quaternion.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:method:rotate|rotate]]**
<code c>
void efl_gfx_map_rotate(Eo *obj, double degrees, const Efl_Gfx *pivot, double cx, double cy);
</code>

%%Apply a rotation to the object.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:method:translate|translate]]**
<code c>
void efl_gfx_map_translate(Eo *obj, double dx, double dy, double dz);
</code>

%%Apply a translation to the object using map.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:method:zoom_absolute|zoom_absolute]]**
<code c>
void efl_gfx_map_zoom_absolute(Eo *obj, double zoomx, double zoomy, double cx, double cy);
</code>

%%Apply a zoom to the object, using absolute coordinates.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:method:zoom|zoom]]**
<code c>
void efl_gfx_map_zoom(Eo *obj, double zoomx, double zoomy, const Efl_Gfx *pivot, double cx, double cy);
</code>

%%Apply a zoom to the object.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:property:map_alpha|map_alpha]]** //**(get, set)**//
<code c>
Eina_Bool efl_gfx_map_alpha_get(const Eo *obj);
void efl_gfx_map_alpha_set(Eo *obj, Eina_Bool alpha);
</code>

%%Alpha flag for map rendering.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:property:map_clockwise|map_clockwise]]** //**(get)**//
<code c>
Eina_Bool efl_gfx_map_clockwise_get(const Eo *obj);
</code>

%%Clockwise state of a map (read-only).%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:property:map_color|map_color]]** //**(get, set)**//
<code c>
void efl_gfx_map_color_get(const Eo *obj, int idx, int *r, int *g, int *b, int *a);
void efl_gfx_map_color_set(Eo *obj, int idx, int r, int g, int b, int a);
</code>

%%Color of a vertex in the map.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:property:map_coord_absolute|map_coord_absolute]]** //**(get, set)**//
<code c>
void efl_gfx_map_coord_absolute_get(const Eo *obj, int idx, double *x, double *y, double *z);
void efl_gfx_map_coord_absolute_set(Eo *obj, int idx, double x, double y, double z);
</code>

%%A point's absolute coordinate on the canvas.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:property:map_smooth|map_smooth]]** //**(get, set)**//
<code c>
Eina_Bool efl_gfx_map_smooth_get(const Eo *obj);
void efl_gfx_map_smooth_set(Eo *obj, Eina_Bool smooth);
</code>

%%Smoothing state for map rendering.%%\\ 
\\ 
[[:docs:efl:auto:mixin:efl:gfx:map|Efl.Gfx.Map]].**[[:docs:efl:auto:mixin:efl:gfx:map:property:map_uv|map_uv]]** //**(get, set)**//
<code c>
void efl_gfx_map_uv_get(const Eo *obj, int idx, double *u, double *v);
void efl_gfx_map_uv_set(Eo *obj, int idx, double u, double v);
</code>

%%Map point's U and V texture source point.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:canvas:object|Efl.Canvas.Object]].**[[:docs:efl:auto:class:efl:canvas:object:property:render_parent|render_parent]]** //**(get)**// ''protected''
<code c>
Efl_Canvas_Object *efl_canvas_object_render_parent_get(const Eo *obj);
</code>

%%Gets the parent smart object of a given Evas object, if it has one.%%\\ 
\\ 

===== Events =====

**[[:docs:efl:auto:mixin:elm:interface_scrollable:event:changed|changed]]**
<code c>
ELM_INTERFACE_SCROLLABLE_EVENT_CHANGED(void)
</code>

%%Called when content changed%%\\ 
\\ 
==== Inherited ====

[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:event:callback_add|callback,add]]**
<code c>
EFL_EVENT_CALLBACK_ADD(void, @hot)
</code>

%%A callback was added.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:event:callback_add|callback,add]]**
<code c>
EFL_EVENT_CALLBACK_ADD(void, @hot)
</code>

%%A callback was added.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:event:callback_add|callback,add]]**
<code c>
EFL_EVENT_CALLBACK_ADD(void, @hot)
</code>

%%A callback was added.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:event:callback_add|callback,add]]**
<code c>
EFL_EVENT_CALLBACK_ADD(void, @hot)
</code>

%%A callback was added.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:event:callback_del|callback,del]]**
<code c>
EFL_EVENT_CALLBACK_DEL(void, @hot)
</code>

%%A callback was deleted.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:event:callback_del|callback,del]]**
<code c>
EFL_EVENT_CALLBACK_DEL(void, @hot)
</code>

%%A callback was deleted.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:event:callback_del|callback,del]]**
<code c>
EFL_EVENT_CALLBACK_DEL(void, @hot)
</code>

%%A callback was deleted.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:event:callback_del|callback,del]]**
<code c>
EFL_EVENT_CALLBACK_DEL(void, @hot)
</code>

%%A callback was deleted.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:event:del|del]]**
<code c>
EFL_EVENT_DEL(void, @hot)
</code>

%%Object is being deleted.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:event:del|del]]**
<code c>
EFL_EVENT_DEL(void, @hot)
</code>

%%Object is being deleted.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:event:del|del]]**
<code c>
EFL_EVENT_DEL(void, @hot)
</code>

%%Object is being deleted.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:event:del|del]]**
<code c>
EFL_EVENT_DEL(void, @hot)
</code>

%%Object is being deleted.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:event:coords_dirty|coords,dirty]]**
<code c>
EFL_UI_FOCUS_MANAGER_EVENT_COORDS_DIRTY(void)
</code>

%%Emitted once the graph is dirty, this means there are potential changes in border_elements you want to know about%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:event:flush_pre|flush,pre]]**
<code c>
EFL_UI_FOCUS_MANAGER_EVENT_FLUSH_PRE(void)
</code>

%%Emitted once the graph calculationg will be performed%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:event:focused|focused]]**
<code c>
EFL_UI_FOCUS_MANAGER_EVENT_FOCUSED(Efl_Ui_Focus_Object *)
</code>

%%Emitted if the manager has focused an object%%\\ 
\\ 
[[:docs:efl:auto:class:efl:ui:focus:manager|Efl.Ui.Focus.Manager]].**[[:docs:efl:auto:class:efl:ui:focus:manager:event:redirect_changed|redirect,changed]]**
<code c>
EFL_UI_FOCUS_MANAGER_EVENT_REDIRECT_CHANGED(Efl_Ui_Focus_Manager *)
</code>

%%Emitted when the redirect object has changed, the old manager is passed as event info%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:animator|Efl.Animator]].**[[:docs:efl:auto:interface:efl:animator:event:animator_tick|animator,tick]]**
<code c>
EFL_EVENT_ANIMATOR_TICK(Efl_Event_Animator_Tick)
</code>

%%Animator tick synchronized with screen vsync if possible.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:size:hint|Efl.Gfx.Size.Hint]].**[[:docs:efl:auto:interface:efl:gfx:size:hint:event:change_size_hints|change,size,hints]]**
<code c>
EFL_GFX_EVENT_CHANGE_SIZE_HINTS(void)
</code>

%%Object size hints changed.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx:stack|Efl.Gfx.Stack]].**[[:docs:efl:auto:interface:efl:gfx:stack:event:restack|restack]]**
<code c>
EFL_GFX_EVENT_RESTACK(void)
</code>

%%Object stacking was changed.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx|Efl.Gfx]].**[[:docs:efl:auto:interface:efl:gfx:event:changed|changed]]**
<code c>
EFL_GFX_EVENT_CHANGED(void)
</code>

%%Object was changed%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx|Efl.Gfx]].**[[:docs:efl:auto:interface:efl:gfx:event:hide|hide]]**
<code c>
EFL_GFX_EVENT_HIDE(void)
</code>

%%Object just became invisible.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx|Efl.Gfx]].**[[:docs:efl:auto:interface:efl:gfx:event:move|move]]**
<code c>
EFL_GFX_EVENT_MOVE(void)
</code>

%%Object was moved, its position during the event is the new one.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx|Efl.Gfx]].**[[:docs:efl:auto:interface:efl:gfx:event:resize|resize]]**
<code c>
EFL_GFX_EVENT_RESIZE(void)
</code>

%%Object was resized, its size during the event is the new one.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:gfx|Efl.Gfx]].**[[:docs:efl:auto:interface:efl:gfx:event:show|show]]**
<code c>
EFL_GFX_EVENT_SHOW(void)
</code>

%%Object just became visible.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:finger_down|finger,down]]**
<code c>
EFL_EVENT_FINGER_DOWN(Efl_Input_Pointer *)
</code>

%%Finger pressed (finger id is known).%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:finger_move|finger,move]]**
<code c>
EFL_EVENT_FINGER_MOVE(Efl_Input_Pointer *)
</code>

%%Finger moved (current and previous positions are known).%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:finger_up|finger,up]]**
<code c>
EFL_EVENT_FINGER_UP(Efl_Input_Pointer *)
</code>

%%Finger released (finger id is known).%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:focus_in|focus,in]]**
<code c>
EFL_EVENT_FOCUS_IN(Efl_Input_Focus *)
</code>

%%A focus in event.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:focus_out|focus,out]]**
<code c>
EFL_EVENT_FOCUS_OUT(Efl_Input_Focus *)
</code>

%%A focus out event.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:hold|hold]]**
<code c>
EFL_EVENT_HOLD(Efl_Input_Hold *)
</code>

%%All input events are on hold or resumed.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:key_down|key,down]]**
<code c>
EFL_EVENT_KEY_DOWN(Efl_Input_Key *)
</code>

%%Keyboard key press.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:key_up|key,up]]**
<code c>
EFL_EVENT_KEY_UP(Efl_Input_Key *)
</code>

%%Keyboard key release.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:pointer_axis|pointer,axis]]**
<code c>
EFL_EVENT_POINTER_AXIS(Efl_Input_Pointer *)
</code>

%%Pen or other axis event update.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:pointer_cancel|pointer,cancel]]**
<code c>
EFL_EVENT_POINTER_CANCEL(Efl_Input_Pointer *)
</code>

%%Main pointer button press was cancelled (button id is known). This can happen in rare cases when the window manager passes the focus to a more urgent window, for instance. You probably don't need to listen to this event, as it will be accompanied by an up event.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:pointer_down|pointer,down]]**
<code c>
EFL_EVENT_POINTER_DOWN(Efl_Input_Pointer *)
</code>

%%Main pointer button pressed (button id is known).%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:pointer_in|pointer,in]]**
<code c>
EFL_EVENT_POINTER_IN(Efl_Input_Pointer *)
</code>

%%Pointer entered a window or a widget.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:pointer_move|pointer,move]]**
<code c>
EFL_EVENT_POINTER_MOVE(Efl_Input_Pointer *)
</code>

%%Main pointer move (current and previous positions are known).%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:pointer_out|pointer,out]]**
<code c>
EFL_EVENT_POINTER_OUT(Efl_Input_Pointer *)
</code>

%%Pointer left a window or a widget.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:pointer_up|pointer,up]]**
<code c>
EFL_EVENT_POINTER_UP(Efl_Input_Pointer *)
</code>

%%Main pointer button released (button id is known).%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:input:interface|Efl.Input.Interface]].**[[:docs:efl:auto:interface:efl:input:interface:event:pointer_wheel|pointer,wheel]]**
<code c>
EFL_EVENT_POINTER_WHEEL(Efl_Input_Pointer *)
</code>

%%Mouse wheel event.%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:ui:scrollable|Efl.Ui.Scrollable]].**[[:docs:efl:auto:interface:efl:ui:scrollable:event:scroll_anim_start|scroll,anim,start]]**
<code c>
EFL_UI_EVENT_SCROLL_ANIM_START(void)
</code>

%%Called when scroll animation started%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:ui:scrollable|Efl.Ui.Scrollable]].**[[:docs:efl:auto:interface:efl:ui:scrollable:event:scroll_anim_stop|scroll,anim,stop]]**
<code c>
EFL_UI_EVENT_SCROLL_ANIM_STOP(void)
</code>

%%Called when scroll animation stopped%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:ui:scrollable|Efl.Ui.Scrollable]].**[[:docs:efl:auto:interface:efl:ui:scrollable:event:scroll_drag_start|scroll,drag,start]]**
<code c>
EFL_UI_EVENT_SCROLL_DRAG_START(void)
</code>

%%Called when scroll drag started%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:ui:scrollable|Efl.Ui.Scrollable]].**[[:docs:efl:auto:interface:efl:ui:scrollable:event:scroll_drag_stop|scroll,drag,stop]]**
<code c>
EFL_UI_EVENT_SCROLL_DRAG_STOP(void)
</code>

%%Called when scroll drag stopped%%\\ 
\\ 
[[:docs:efl:auto:interface:efl:ui:scrollable|Efl.Ui.Scrollable]].**[[:docs:efl:auto:interface:efl:ui:scrollable:event:scroll|scroll]]**
<code c>
EFL_UI_EVENT_SCROLL(void)
</code>

%%Called when scroll operation started%%\\ 
\\ 
