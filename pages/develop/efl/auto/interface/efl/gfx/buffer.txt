<title>Efl.Gfx.Buffer</title>
++++ Inheritance graph |

<graphviz>
digraph hierarchy {
    bgcolor = "transparent"
    size = "6"
    rankdir = "TB"

    node [shape = "box"]
    edge [color = "gray35"]

    efl_gfx_buffer [fillcolor = "dodgerblue4", label = "Efl.Gfx.Buffer", color = "cornflowerblue", fontcolor = "white", style = "filled"]

}
</graphviz>

++++

===== Inheritance hierarchy =====

  * **[[:develop:efl:auto:interface:efl:gfx:buffer|Efl.Gfx.Buffer]] //(interface)//**

===== Description =====

%%Common APIs for all objects representing images and 2D pixel buffers.%%

{{page>:develop:efl:user:interface:efl:gfx:buffer:description&nouser&nolink&nodate}}

===== Members =====

**[[:develop:efl:auto:interface:efl:gfx:buffer:method:buffer_copy_set|buffer_copy_set]]**
<code c>
Eina_Bool efl_gfx_buffer_copy_set(Eo *obj, const Eina_Slice *slice, Eina_Size2D size, int stride, Efl_Gfx_Colorspace cspace, int plane);
</code>

%%Set the pixels for this buffer by copying them, or allocate a new memory region.%%\\ 
\\ 
**[[:develop:efl:auto:interface:efl:gfx:buffer:method:buffer_managed_get|buffer_managed_get]]**
<code c>
Eina_Slice efl_gfx_buffer_managed_get(Eo *obj, int plane);
</code>

%%Get a direct pointer to the internal pixel data, if available.%%\\ 
\\ 
**[[:develop:efl:auto:interface:efl:gfx:buffer:method:buffer_managed_set|buffer_managed_set]]**
<code c>
Eina_Bool efl_gfx_buffer_managed_set(Eo *obj, const Eina_Slice *slice, Eina_Size2D size, int stride, Efl_Gfx_Colorspace cspace, int plane);
</code>

%%Set the pixels for this buffer, managed externally by the client.%%\\ 
\\ 
**[[:develop:efl:auto:interface:efl:gfx:buffer:method:buffer_map|buffer_map]]**
<code c>
Eina_Rw_Slice efl_gfx_buffer_map(Eo *obj, Efl_Gfx_Buffer_Access_Mode mode, const Eina_Rect *region, Efl_Gfx_Colorspace cspace, int plane, int *stride);
</code>

%%Map a region of this buffer for read or write access by the CPU.%%\\ 
\\ 
**[[:develop:efl:auto:interface:efl:gfx:buffer:method:buffer_unmap|buffer_unmap]]**
<code c>
Eina_Bool efl_gfx_buffer_unmap(Eo *obj, Eina_Rw_Slice slice);
</code>

%%Unmap a region of this buffer, and update the internal data if needed.%%\\ 
\\ 
**[[:develop:efl:auto:interface:efl:gfx:buffer:method:buffer_update_add|buffer_update_add]]**
<code c>
void efl_gfx_buffer_update_add(Eo *obj, const Eina_Rect *region);
</code>

%%Mark a sub-region of the given image object to be redrawn.%%\\ 
\\ 
**[[:develop:efl:auto:interface:efl:gfx:buffer:property:alpha|alpha]]** //**(get, set)**//
<code c>
Eina_Bool efl_gfx_buffer_alpha_get(const Eo *obj);
void efl_gfx_buffer_alpha_set(Eo *obj, Eina_Bool alpha);
</code>

%%Indicates whether the alpha channel should be used.%%\\ 
\\ 
**[[:develop:efl:auto:interface:efl:gfx:buffer:property:buffer_borders|buffer_borders]]** //**(get)**//
<code c>
void efl_gfx_buffer_borders_get(const Eo *obj, unsigned int *l, unsigned int *r, unsigned int *t, unsigned int *b);
</code>

%%Duplicated pixel borders inside this buffer.%%\\ 
\\ 
**[[:develop:efl:auto:interface:efl:gfx:buffer:property:buffer_size|buffer_size]]** //**(get, set)**//
<code c>
Eina_Size2D efl_gfx_buffer_size_get(const Eo *obj);
void efl_gfx_buffer_size_set(Eo *obj, Eina_Size2D sz);
</code>

%%Rectangular size of the pixel buffer as allocated in memory.%%\\ 
\\ 
**[[:develop:efl:auto:interface:efl:gfx:buffer:property:colorspace|colorspace]]** //**(get)**//
<code c>
Efl_Gfx_Colorspace efl_gfx_buffer_colorspace_get(const Eo *obj);
</code>

%%The colorspace defines how pixels are encoded in the image in memory.%%\\ 
\\ 
**[[:develop:efl:auto:interface:efl:gfx:buffer:property:stride|stride]]** //**(get)**//
<code c>
int efl_gfx_buffer_stride_get(const Eo *obj);
</code>

%%Length in bytes of one row of pixels in memory.%%\\ 
\\ 

