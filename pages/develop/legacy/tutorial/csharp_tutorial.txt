~~Title: C# Tutorial~~
===== C# Tutorial =====

This tutorial shows how to compile and install the Enlightenment Foundation Libraries (EFL) with C# bindings support, and some examples of how to use it.

<note important>
The C# bindings are currently in BETA state.
</note>

==== Getting Started ====

=== Prerequisite ===

Before you start you may want to read about how to compile the EFL:

    * Installed from source: [[docs/distros/start]].

=== Dependencies ===

== On Linux ==

You need a compatible version of [[http://www.mono-project.com|Mono]] (4.0 or higher).
The paths to the ''mcs'' compiler and to the ''mono'' application must be in the ''PATH'' environment variable before compiling.

Once all conditions are met proceed to [[#Compilation]].

== On Windows ==

In order to have EFL on a Windows environment we highly recommend following [[https://phab.enlightenment.org/w/windows/|this guide]] which accomplishes that using [[http://win-builds.org|win-builds]] and [[http://www.msys2.org/|MSYS2]].

You need a compatible version of [[http://www.mono-project.com|Mono]] (4.0 or higher).
You can use Mono binaries installed directly to your Windows system (i.e. outside the MSYS2 environment), you just need to make sure that the paths to the ''mcs.exe'' compiler and to the ''mono.exe'' application are in the ''PATH'' environment variable in your MSYS2 terminal.
Using the default installation path, Mono binaries normally goes in ''C:\Program Files\Mono''; so in MSYS2 you can point to the binaries using the path ''/c/Program Files/Mono/bin''.
You can also permanently set this in your ''/etc/profile'' in MSYS2 adding something like this at the end of the file:
<code bash>
export PATH="$PATH:/c/Program Files/Mono/bin"
</code>
If you used another installation path to Mono just adjust the paths used.

<note important>
It is advisable to add the Mono path at the **end** of the ''PATH'' environment variable, like in the example above.
Mono has its own version of some applications (like ''pkg-config'') which can take priority over the ones from MSYS2 and cause things to fail.
</note>

Now you can use the MSYS2 console to compile, install and run EFL and your applications.
Once all conditions are met proceed to [[#Compilation]].

=== Compiling and Installing ===

In order to compile and install EFL with C# binding support, in both Windows and Linux just compile the EFL like the respective guide suggests, only add the argument ''--enable-csharp-bindings'' to the ''autogen.sh'' or ''configure'' command.
Like:
<code bash>
./autogen.sh --enable-csharp-bindings #other arguments
make -j4
sudo make install
</code>

<note>
It is known that some tutorials can get a bit outdated from time to time, causing the building process to fail, usually because of a missing dependency.
Normally reading the error message and installing the missing package solves the problem.
If you can not solve the problem by yourself, try [[/contact|contacting]] the community.
</note>

==== Examples ====

Now that you can compile and install EFL with C# bindings lets see some code examples.

=== Button Example ===

Lets start with a very simple example that just creates a window with a button and show how to compile it.
After, the code will be explained.

<note tip>
You can find this example in ''<efl_source>/src/examples/elementary/button_example_00.cs''
</note>

The code:
<code csharp>
using System;

public class Example
{
#if WIN32
    [STAThreadAttribute()]
#endif
    public static void Main()
    {
        efl.All.Init(efl.Components.Ui);

        efl.ui.IWin win = new efl.ui.Win(null);
        win.SetText("Hello, World!");
        win.SetAutohide(true);
        win.SetSize(240, 60);
        win.SetVisible(true);

        efl.ui.IButton btn = new efl.ui.Button(win);
        btn.SetText("Good-Bye, World!");
        btn.SetSize(120, 30);
        eina.Position2D pos;
        pos.X = 60;
        pos.Y = 15;
        btn.SetPosition(pos);
        btn.SetVisible(true);
        btn.ClickedEvt += (object sender, EventArgs e) => {
                           efl.ui.Config.Exit();
                       };

        efl.ui.Config.Run();

        efl.All.Shutdown();
    }
}
</code>

== Compiling and running ==

If you have EFL installed you can compile the example using ''pkg-config'' to get the proper flags for using the C# binding:
<code bash>
mcs button_example_00.cs -out:button_example_00.exe `pkg-config --libs efl-mono`
</code>

Otherwise, you have to point the library location manually, like:
<code bash>
mcs button_example_00.cs -out:button_example_00.exe -r:/home/my_user/efl/build/src/lib/efl_mono/libefl_mono.dll
</code>

To run the application you can either copy the EFL C# binding library to your folder or set the ''MONO_PATH'' environment variable, them execute it using ''mono''.
In both cases, you can use ''pkg-config'' to get the right paths.

Example coping the library:
<code bash>
cp `pkg-config --variable=Libraries efl-mono` .
mono button_example_00.exe
</code>

Example setting ''MONO_PATH'':
<code bash>
export MONO_PATH=`pkg-config --variable=assemblies_dir efl-mono`
mono button_example_00.exe
</code>

Note that if you installed EFL in a path that is not directly accessible to ''pkg-config'' or to your application you have to manually make it accessible someway,
for example setting proper environment variables before compiling and running:
<code bash>
export PKG_CONFIG_PATH=/opt/my_install_prefix/lib/pkgconfig
export LD_LIBRARY_PATH=/opt/my_install_prefix/lib
</code>

== Explaining the code ==

First, we start with a basic class structure to define our ''Main'' entry point:
<code csharp>
using System;

public class Example
{
#if WIN32
    [STAThreadAttribute()]
#endif
    public static void Main()
    {
        // <code goes here>
    }
}
</code>
<note important>
The ''STAThreadAttribute'' is currently necessary in Windows systems because of limitations in ''ecore_win32''.
You can compile passing ''-define:WIN32'' to ''mcs'' to flag when you are compiling on a Windows system.
</note>

Then we initialize EFL with Ui components enabled:
<code csharp>
        efl.All.Init(efl.Components.Ui);
</code>

And create a new Window with auto-hide (the window is automatically hidden when the close button is clicked), set its title, give it a dimension and turn it visible:
<code csharp>
        efl.ui.IWin win = new efl.ui.Win(null);
        win.SetText("Hello, World!");
        win.SetAutohide(true);
        win.SetSize(240, 60);
        win.SetVisible(true);
</code>

Create a new Button (passing the newly created window as the parent), set new label text to the button, give it a dimension and position and turn it visible:
<code csharp>
        efl.ui.IButton btn = new efl.ui.Button(win);
        btn.SetText("Good-Bye, World!");
        btn.SetSize(120, 30);
        eina.Position2D pos;
        pos.X = 60;
        pos.Y = 15;
        btn.SetPosition(pos);
        btn.SetVisible(true);
</code>

And then register a function to the button ''CLICKED'' event:
<code csharp>
        btn.ClickedEvt += (object sender, EventArgs e) => {
                           efl.ui.Config.Exit();
                       };
</code>
We use a simple lambda that calls a function to end the event loop, exiting ''efl.ui.Config.Run()'' and finishing the application.

Once the setup is finished, we call:
<code csharp>
        efl.ui.Config.Run();
</code>
It starts the event loop and display the application main window.

After the event loop is finished (when closing the last window or by calling ''efl.ui.Config.Exit()'') we shut down the EFL components and let the application end:
<code csharp>
        efl.All.Shutdown();
</code>

And this concludes the basic button example.

=== Efl.Ui.List and Efl.Model Example ===

WIP