<title>Efl.Canvas.Scene3d.buffer_unmap</title>
//Overridden from [[:docs:efl:auto:interface:efl:gfx:buffer:method:buffer_unmap|Efl.Gfx.Buffer.buffer_unmap]].//===== Signature =====

<code>
buffer_unmap @pure_virtual {
    params {
        @in slice: ptr(const(Eina.Rw_Slice));
    }
    return: bool;
}
</code>

===== C signature =====

<code c>
Eina_Bool efl_gfx_buffer_unmap(Eo *obj, const Eina_Rw_Slice *slice);
</code>

===== Parameters =====

  * **slice** //(in)// - %%Data slice returned by a previous call to map.%%

===== Description =====

%%Unmap a region of this buffer, and update the internal data if needed.%%

%%EFL will update the internal image if the map had write access.%%

%%The %%''slice''%% struct does not need to be the one returned by %%[[:docs:efl:auto:interface:efl:gfx:buffer:method:buffer_map|Efl.Gfx.Buffer.buffer_map]]%%, only its contents (%%''mem''%% and %%''len''%%) must match. But after a call to %%[[:docs:efl:auto:interface:efl:gfx:buffer:method:buffer_unmap|Efl.Gfx.Buffer.buffer_unmap]]%% the original %%''slice''%% structure is not valid anymore.%%
</note>
{{page>:docs:efl:user:class:efl:canvas:scene3d:method:buffer_unmap:description&nodate&nolink&nouser}}

===== Implemented by =====

  * [[:docs:efl:auto:interface:efl:gfx:buffer:method:buffer_unmap|Efl.Gfx.Buffer.buffer_unmap]]
  * **Efl.Canvas.Scene3d.buffer_unmap**
  * [[:docs:efl:auto:class:efl:canvas:image:method:buffer_unmap|Efl.Canvas.Image.buffer_unmap]]
  * [[:docs:efl:auto:class:efl:canvas:proxy:method:buffer_unmap|Efl.Canvas.Proxy.buffer_unmap]]

