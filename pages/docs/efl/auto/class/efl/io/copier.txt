<title>Efl.Io.Copier</title>
++++ Inheritance graph |

<graphviz>
digraph hierarchy {
    bgcolor = "transparent"
    size = "6"
    rankdir = "TB"

    node [shape = "box"]
    edge [color = "gray35"]

    efl_io_copier [fillcolor = "black", label = "Efl.Io.Copier", color = "gray15", fontcolor = "white", style = "filled"]
    efl_loop_user [fillcolor = "gray15", label = "Efl.Loop_User", color = "gray15", fontcolor = "white", style = "filled"]
    efl_object [fillcolor = "gray15", label = "Efl.Object", color = "gray15", fontcolor = "white", style = "filled"]
    efl_io_closer [fillcolor = "gray15", label = "Efl.Io.Closer", color = "deepskyblue", fontcolor = "white", style = "filled"]

    efl_io_copier -> efl_loop_user
    efl_loop_user -> efl_object
    efl_io_copier -> efl_io_closer
}
</graphviz>

++++

===== Inheritance hierarchy =====

  * **[[:docs:efl:auto:class:efl:io:copier|Efl.Io.Copier]] //(class)//**
    * [[:docs:efl:auto:class:efl:loop_user|Efl.Loop_User]] //(class)//
      * [[:docs:efl:auto:class:efl:object|Efl.Object]] //(class)//
    * [[:docs:efl:auto:mixin:efl:io:closer|Efl.Io.Closer]] //(mixin)//

===== Description =====

%%Copy from an %%[[:docs:efl:auto:interface:efl:io:reader|Efl.Io.Reader]]%% source to %%[[:docs:efl:auto:interface:efl:io:writer|Efl.Io.Writer]]%% destination.%%

%%During usage it will keep reference to %%[[:docs:efl:auto:class:efl:io:copier:property:source|Efl.Io.Copier.source]]%% and %%[[:docs:efl:auto:class:efl:io:copier:property:destination|Efl.Io.Copier.destination]]%% objects, automatically relasing them on destructor.%%

%%By default the read-write process is done based on fixed-size chunks (%%[[:docs:efl:auto:class:efl:io:copier:property:read_chunk_size|Efl.Io.Copier.read_chunk_size]]%%), however if %%[[:docs:efl:auto:class:efl:io:copier:property:line_delimiter|Efl.Io.Copier.line_delimiter]]%% is set, the behavior changes to wait for such delimiter or a maximum buffer limit is reached (%%[[:docs:efl:auto:class:efl:io:copier:property:buffer_limit|Efl.Io.Copier.buffer_limit]]%%).%%

%%While a %%[[:docs:efl:auto:class:efl:io:copier:property:source|Efl.Io.Copier.source]]%% is mandatory for the copier to operate properly, the %%[[:docs:efl:auto:class:efl:io:copier:property:destination|Efl.Io.Copier.destination]]%% is optional: if it's not provided, all read data is stored in an internal buffer that can be retrieved using %%[[:docs:efl:auto:class:efl:io:copier:method:binbuf_steal|Efl.Io.Copier.binbuf_steal]]%%, usually called when one of "data", "line" or "done" events are emitted.%%

%%Most important events:%%

%%- The "data" event is general and notifies some data was written to %%[[:docs:efl:auto:class:efl:io:copier:property:destination|Efl.Io.Copier.destination]]%% (if any, otherwise it will be reported for data when it's read from %%[[:docs:efl:auto:class:efl:io:copier:property:source|Efl.Io.Copier.source]]%%).%%

%%- The "line" event is only emitted when %%[[:docs:efl:auto:class:efl:io:copier:property:line_delimiter|Efl.Io.Copier.line_delimiter]]%% is set and not empty. It's simiar to "data".%%

%%- The "done" event is emitted if %%[[:docs:efl:auto:class:efl:io:copier:property:source|Efl.Io.Copier.source]]%% is %%[[:docs:efl:auto:interface:efl:io:reader:property:eos|Efl.Io.Reader.eos]]%% %%''true''%% and all data was written to %%[[:docs:efl:auto:class:efl:io:copier:property:destination|Efl.Io.Copier.destination]]%% (if any, otherwise it will be reported when all data was read from %%[[:docs:efl:auto:class:efl:io:copier:property:source|Efl.Io.Copier.source]]%%).%%

%%- The "error" event is reported if the %%[[:docs:efl:auto:interface:efl:io:reader:method:read|Efl.Io.Reader.read]]%%, %%[[:docs:efl:auto:interface:efl:io:writer:method:write|Efl.Io.Writer.write]]%% or some other internal error happened, like out of memory. Another common error is ETIMEDOUT if %%[[:docs:efl:auto:class:efl:io:copier:property:timeout_inactivity|Efl.Io.Copier.timeout_inactivity]]%% is set.%%

%%A copier is handful to simplify common I/O use cases, such as:%%

%%- Read a file or download content to memory: provide only the source and wait for "done" event, calling %%[[:docs:efl:auto:class:efl:io:copier:method:binbuf_steal|Efl.Io.Copier.binbuf_steal]]%% afterwards.%%

%%- Download content to disk: provide a network socket as source and use %%[[:docs:efl:auto:class:efl:io:file|Efl.Io.File]]%% as destination, then wait for "done" event.%%

%%- Link two I/O streams: provide both source and destination streams, such as %%[[:docs:efl:auto:class:efl:io:stdin|Efl.Io.Stdin]]%% and %%[[:docs:efl:auto:class:efl:io:stdout|Efl.Io.Stdout]]%%, or some network socket. As data is received from source it will be copied to destination in an endless (asynchronous) loop. You may monitor for "done" if the source may be closed.%%

%%If %%[[:docs:efl:auto:mixin:efl:io:closer:method:close|Efl.Io.Closer.close]]%% is called, then it will be called on %%[[:docs:efl:auto:class:efl:io:copier:property:source|Efl.Io.Copier.source]]%% and %%[[:docs:efl:auto:class:efl:io:copier:property:destination|Efl.Io.Copier.destination]]%% if they implement those interfaces.%%

%%%%[[:docs:efl:auto:mixin:efl:io:closer:property:close_on_exec|Efl.Io.Closer.close_on_exec]]%% and %%[[:docs:efl:auto:mixin:efl:io:closer:property:close_on_destructor|Efl.Io.Closer.close_on_destructor]]%% are respected and applied to both source and destination. Both default to %%''true''%%.%%

//Since 1.19//

{{page>:docs:efl:user:class:efl:io:copier:description&nodate&nolink&nouser}}

===== Members =====

**[[:docs:efl:auto:class:efl:io:copier:method:binbuf_steal|binbuf_steal]]**
<code c>
Eina_Binbuf *efl_io_copier_binbuf_steal(Eo *obj);
</code>

%%Steals the internal binbuf and return it to caller.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:method:flush|flush]]**
<code c>
Eina_Bool efl_io_copier_flush(Eo *obj, Eina_Bool may_block, Eina_Bool ignore_line_delimiter);
</code>

%%Forces reading from source and writing to destination.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:property:buffer_limit|buffer_limit]]** //**(get, set)**//
<code c>
size_t efl_io_copier_buffer_limit_get(const Eo *obj);
void efl_io_copier_buffer_limit_set(Eo *obj, size_t size);
</code>

%%Copier buffer limit property, in bytes.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:property:destination|destination]]** //**(get, set)**//
<code c>
Efl_Io_Writer *efl_io_copier_destination_get(const Eo *obj);
void efl_io_copier_destination_set(Eo *obj, Efl_Io_Writer *destination);
</code>

%%Copier destination object.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:property:done|done]]** //**(get, set)**//
<code c>
Eina_Bool efl_io_copier_done_get(const Eo *obj);
void efl_io_copier_done_set(Eo *obj, Eina_Bool done);
</code>

%%Reports if copier is done.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:property:line_delimiter|line_delimiter]]** //**(get, set)**//
<code c>
Eina_Slice efl_io_copier_line_delimiter_get(const Eo *obj);
void efl_io_copier_line_delimiter_set(Eo *obj, Eina_Slice slice);
</code>

%%If there is a line delimiter, the reads will buffer/queue up to the line delimiter before calling %%[[:docs:efl:auto:interface:efl:io:writer:method:write|Efl.Io.Writer.write]]%% on the %%[[:docs:efl:auto:class:efl:io:copier:property:destination|Efl.Io.Copier.destination]]%% and the event line is emitted with current line. The line may include the delimiter, unless it's end-of-stream on %%[[:docs:efl:auto:class:efl:io:copier:property:source|Efl.Io.Copier.source]]%% or %%[[:docs:efl:auto:class:efl:io:copier:property:buffer_limit|Efl.Io.Copier.buffer_limit]]%% was reached.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:property:pending_size|pending_size]]** //**(get)**//
<code c>
size_t efl_io_copier_pending_size_get(const Eo *obj);
</code>

%%Returns the size of the pending buffer.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:property:progress|progress]]** //**(get)**//
<code c>
void efl_io_copier_progress_get(const Eo *obj, uint64_t *read, uint64_t *written, uint64_t *total);
</code>

%%Progress for read and write.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:property:read_chunk_size|read_chunk_size]]** //**(get, set)**//
<code c>
size_t efl_io_copier_read_chunk_size_get(const Eo *obj);
void efl_io_copier_read_chunk_size_set(Eo *obj, size_t size);
</code>

%%Copier read chunk size property, in bytes.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:property:source|source]]** //**(get, set)**//
<code c>
Efl_Io_Reader *efl_io_copier_source_get(const Eo *obj);
void efl_io_copier_source_set(Eo *obj, Efl_Io_Reader *source);
</code>

%%Copier source object.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:property:timeout_inactivity|timeout_inactivity]]** //**(get, set)**//
<code c>
double efl_io_copier_timeout_inactivity_get(const Eo *obj);
void efl_io_copier_timeout_inactivity_set(Eo *obj, double seconds);
</code>

%%Terminate the copier with ETIMEDOUT if it becomes inactive for some time.%%\\ 
\\ 

===== Overrides =====

**[[:docs:efl:auto:class:efl:io:copier:method:close|close]]** //[from [[:docs:efl:auto:mixin:efl:io:closer|Efl.Io.Closer]]]//
<code c>
Eina_Error efl_io_closer_close(Eo *obj);
</code>

%%Closes the Input/Output object.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:method:constructor|constructor]]** //[from [[:docs:efl:auto:class:efl:object|Efl.Object]]]//
<code c>
Efl_Object *efl_constructor(Eo *obj);
</code>

%%Call the object's constructor.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:method:destructor|destructor]]** //[from [[:docs:efl:auto:class:efl:object|Efl.Object]]]//
<code c>
void efl_destructor(Eo *obj);
</code>

%%Call the object's destructor.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:method:finalize|finalize]]** //[from [[:docs:efl:auto:class:efl:object|Efl.Object]]]//
<code c>
Efl_Object *efl_finalize(Eo *obj);
</code>

%%Called at the end of #eo_add. Should not be called, just overridden.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:property:close_on_destructor|close_on_destructor]]** //**(get, set)**// //[from [[:docs:efl:auto:mixin:efl:io:closer|Efl.Io.Closer]]]//
<code c>
Eina_Bool efl_io_closer_close_on_destructor_get(const Eo *obj);
void efl_io_closer_close_on_destructor_set(Eo *obj, Eina_Bool close_on_destructor);
</code>

%%If true will automatically close() on object destructor.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:property:close_on_exec|close_on_exec]]** //**(get, set)**// //[from [[:docs:efl:auto:mixin:efl:io:closer|Efl.Io.Closer]]]//
<code c>
Eina_Bool efl_io_closer_close_on_exec_get(const Eo *obj);
Eina_Bool efl_io_closer_close_on_exec_set(Eo *obj, Eina_Bool close_on_exec);
</code>

%%If true will automatically close resources on exec() calls.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:io:copier:property:closed|closed]]** //**(get)**// //[from [[:docs:efl:auto:mixin:efl:io:closer|Efl.Io.Closer]]]//
<code c>
Eina_Bool efl_io_closer_closed_get(const Eo *obj);
</code>

%%If true will notify object was closed.%%\\ 
\\ 

===== Others =====

[[:docs:efl:auto:class:efl:loop_user|Efl.Loop_User]].**[[:docs:efl:auto:class:efl:loop_user:property:loop|loop]]** //**(get)**//
<code c>
Efl_Loop *efl_loop_get(const Eo *obj);
</code>

%%The loop to which this object belongs to.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:loop_user|Efl.Loop_User]].**[[:docs:efl:auto:class:efl:loop_user:property:parent|parent]]** //**(set)**// //[from [[:docs:efl:auto:class:efl:object|Efl.Object]]]//
<code c>
void efl_parent_set(Eo *obj, Efl_Object *parent);
</code>

%%The parent of an object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:children_iterator_new|children_iterator_new]]**
<code c>
Eina_Iterator *efl_children_iterator_new(Eo *obj);
</code>

%%Get an iterator on all childrens%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:composite_attach|composite_attach]]**
<code c>
Eina_Bool efl_composite_attach(Eo *obj, Efl_Object *comp_obj);
</code>

%%Make an object a composite object of another.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:composite_detach|composite_detach]]**
<code c>
Eina_Bool efl_composite_detach(Eo *obj, Efl_Object *comp_obj);
</code>

%%Detach a composite object from another object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:composite_part_is|composite_part_is]]**
<code c>
Eina_Bool efl_composite_part_is(Eo *obj);
</code>

%%Check if an object is part of a composite object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:dbg_info_get|dbg_info_get]]**
<code c>
void efl_dbg_info_get(Eo *obj, Efl_Dbg_Info *root_node);
</code>

%%Get debug information from the object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:del|del]]**
<code c>
void efl_del(const Eo *obj);
</code>

%%Unrefs the object and reparents it to NULL.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_callback_array_del|event_callback_array_del]]**
<code c>
Eina_Bool efl_event_callback_array_del(Eo *obj, const Efl_Callback_Array_Item *array, const void *user_data);
</code>

%%Del a callback array with a specific data associated to it for an event. The callbacks from the array will never be emitted again after this call, even if a event emission is going on.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_callback_array_priority_add|event_callback_array_priority_add]]**
<code c>
Eina_Bool efl_event_callback_array_priority_add(Eo *obj, const Efl_Callback_Array_Item *array, Efl_Callback_Priority priority, const void *data);
</code>

%%Add an array of callbacks created by @ref EFL_CALLBACKS_ARRAY_DEFINE for an event with a specific priority. The array need to be sorted with @ref efl_callbacks_cmp if you are not using the @ref EFL_CALLBACKS_ARRAY_DEFINE macro.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_callback_call|event_callback_call]]**
<code c>
Eina_Bool efl_event_callback_call(Eo *obj, const Efl_Event_Description *desc, void *event_info);
</code>

%%Call the callbacks for an event of an object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_callback_del|event_callback_del]]**
<code c>
Eina_Bool efl_event_callback_del(Eo *obj, const Efl_Event_Description *desc, Efl_Event_Cb func, const void *user_data);
</code>

%%Delete a callback with a specific data associated to it for an event.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_callback_forwarder_add|event_callback_forwarder_add]]**
<code c>
void efl_event_callback_forwarder_add(Eo *obj, const Efl_Event_Description *desc, Efl_Object *new_obj);
</code>

%%Add an event callback forwarder for an event and an object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_callback_forwarder_del|event_callback_forwarder_del]]**
<code c>
void efl_event_callback_forwarder_del(Eo *obj, const Efl_Event_Description *desc, Efl_Object *new_obj);
</code>

%%Remove an event callback forwarder for an event and an object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_callback_legacy_call|event_callback_legacy_call]]**
<code c>
Eina_Bool efl_event_callback_legacy_call(Eo *obj, const Efl_Event_Description *desc, void *event_info);
</code>

%%Call the callbacks for an event of an object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_callback_priority_add|event_callback_priority_add]]**
<code c>
Eina_Bool efl_event_callback_priority_add(Eo *obj, const Efl_Event_Description *desc, Efl_Callback_Priority priority, Efl_Event_Cb cb, const void *data);
</code>

%%Add a callback for an event with a specific priority.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_callback_stop|event_callback_stop]]**
<code c>
void efl_event_callback_stop(Eo *obj);
</code>

%%Stop the current callback call.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_freeze|event_freeze]]**
<code c>
void efl_event_freeze(Eo *obj);
</code>

%%Freeze events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_global_freeze|event_global_freeze]]**
<code c>
void efl_event_global_freeze(const Eo *obj);
</code>

%%Freeze events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_global_thaw|event_global_thaw]]**
<code c>
void efl_event_global_thaw(const Eo *obj);
</code>

%%Thaw events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_thaw|event_thaw]]**
<code c>
void efl_event_thaw(Eo *obj);
</code>

%%Thaw events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:future_link|future_link]]**
<code c>
Eina_Bool efl_future_link(Eo *obj, Efl_Future *link);
</code>

%%Track a future life cycle and cancel it if the object die%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:name_find|name_find]]**
<code c>
Efl_Object *efl_name_find(Eo *obj, const char *search);
</code>

%%Find a child object with the given name and return it. The search string can be a glob (shell style). It can also specify class name in the format of "class:name" where ":" separates class and name. Both class and name can be globs. If class is specified, and name is empty like "class:" then the search will match any object of that class.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:provider_find|provider_find]]**
<code c>
Efl_Object *efl_provider_find(Eo *obj, const Efl_Object *klass);
</code>

%%Searches up in the object tree for a provider which knows the given class/interface.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:wref_add|wref_add]]**
<code c>
void efl_wref_add(Eo *obj, Efl_Object **wref);
</code>

%%Add a new weak reference to obj.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:wref_del|wref_del]]**
<code c>
void efl_wref_del(Eo *obj, Efl_Object **wref);
</code>

%%Delete the weak reference passed.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:comment|comment]]** //**(get, set)**//
<code c>
const char *efl_comment_get(const Eo *obj);
void efl_comment_set(Eo *obj, const char *comment);
</code>

%%A human readable comment for the object%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:event_freeze_count|event_freeze_count]]** //**(get)**//
<code c>
int efl_event_freeze_count_get(const Eo *obj);
</code>

%%Return freeze events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:event_global_freeze_count|event_global_freeze_count]]** //**(get)**//
<code c>
int efl_event_global_freeze_count_get(const Eo *obj);
</code>

%%Return freeze events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:finalized|finalized]]** //**(get)**//
<code c>
Eina_Bool efl_finalized_get(const Eo *obj);
</code>

%%True if the object is already finalized, false otherwise.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:key_data|key_data]]** //**(get, set)**//
<code c>
void *efl_key_data_get(const Eo *obj, const char *key);
void efl_key_data_set(Eo *obj, const char *key, const void *data);
</code>

%%Generic data with string key on an object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:key_ref|key_ref]]** //**(get, set)**//
<code c>
Efl_Object *efl_key_ref_get(const Eo *obj, const char *key);
void efl_key_ref_set(Eo *obj, const char *key, const Efl_Object *objdata);
</code>

%%Generic object reference with string key to object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:key_value|key_value]]** //**(get, set)**//
<code c>
Eina_Value *efl_key_value_get(const Eo *obj, const char *key);
void efl_key_value_set(Eo *obj, const char *key, Eina_Value *value);
</code>

%%Value on with string key on the object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:key_wref|key_wref]]** //**(get, set)**//
<code c>
Efl_Object *efl_key_wref_get(const Eo *obj, const char *key);
void efl_key_wref_set(Eo *obj, const char *key, const Efl_Object *objdata);
</code>

%%Generic weak object reference with string key to object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:name|name]]** //**(get, set)**//
<code c>
const char *efl_name_get(const Eo *obj);
void efl_name_set(Eo *obj, const char *name);
</code>

%%The name of the object.%%\\ 
\\ 

===== Events =====

^ Event name ^ Brief description ^
| [[:docs:efl:auto:class:efl:io:copier:event:data|data]] | %%When data is read to internal buffer, it's emitted in this event. The memory is only valid during event callback dispatched and should not be modified.%% |
| [[:docs:efl:auto:class:efl:io:copier:event:done|done]] | %%All available data was copied from source to destination%% |
| [[:docs:efl:auto:class:efl:io:copier:event:error|error]] | %%An error happened and the copy stopped%% |
| [[:docs:efl:auto:class:efl:io:copier:event:line|line]] | %%If %%[[:docs:efl:auto:class:efl:io:copier:property:line_delimiter|Efl.Io.Copier.line_delimiter]]%% is set, will be emitted with current line. The memory is only valid during event callback dispatched and should not be modified.%% |
| [[:docs:efl:auto:class:efl:io:copier:event:progress|progress]] | %%Total size changed or Data was read/written%% |
===== Inherited Events =====

^ Event name ^ Brief description ^
| [[:docs:efl:auto:class:efl:object:event:callback_add|Efl.Object.callback,add]] | %%A callback was added.%% |
| [[:docs:efl:auto:class:efl:object:event:callback_del|Efl.Object.callback,del]] | %%A callback was deleted.%% |
| [[:docs:efl:auto:class:efl:object:event:del|Efl.Object.del]] | %%Object is being deleted.%% |
| [[:docs:efl:auto:mixin:efl:io:closer:event:closed|Efl.Io.Closer.closed]] | %%Notifies closed, when property is marked as true%% |
