<title>Efl.Loop</title>
++++ Inheritance graph |

<graphviz>
digraph hierarchy {
    bgcolor = "transparent"
    size = "6"
    rankdir = "TB"

    node [shape = "box"]
    edge [color = "gray35"]

    efl_loop [fillcolor = "black", label = "Efl.Loop", color = "gray15", fontcolor = "white", style = "filled"]
    efl_object [fillcolor = "gray15", label = "Efl.Object", color = "gray15", fontcolor = "white", style = "filled"]

    efl_loop -> efl_object
}
</graphviz>

++++

===== Inheritance hierarchy =====

  * **[[:docs:efl:auto:class:efl:loop|Efl.Loop]] //(class)//**
    * [[:docs:efl:auto:class:efl:object|Efl.Object]] //(class)//

===== Description =====

%%The Efl Main Loop%%

%%Efl main loop provide a clean and tiny event loop library with many modules to do lots of convenient things for a programmer, to save time and effort. It's small and lean, designed to work from embedded systems all the way up to large and powerful multi-cpu workstations. The main loop has a number of primitives to be used with its main loop. It serializes all the primitives and allows for great responsiveness without the need for threads (or any other concurrency), but provide them if you need to.%%

{{page>:docs:efl:user:class:efl:loop:description&nodate&nolink&nouser}}

===== Members =====

**[[:docs:efl:auto:class:efl:loop:method:begin|begin]]**
<code c>
unsigned char efl_loop_begin(Eo *obj);
</code>

%%Runs the application main loop.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:loop:method:iterate_may_block|iterate_may_block]]**
<code c>
int efl_loop_iterate_may_block(Eo *obj, int may_block);
</code>

%%Runs a single iteration of the main loop to process everything on the queue with block/non-blocking status.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:loop:method:iterate|iterate]]**
<code c>
void efl_loop_iterate(Eo *obj);
</code>

%%Runs a single iteration of the main loop to process everything on the queue.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:loop:method:job|job]]**
<code c>
Efl_Future *efl_loop_job(Eo *obj, const void *data);
</code>

%%Will execute that promise in the near future.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:loop:method:quit|quit]]**
<code c>
void efl_loop_quit(Eo *obj, unsigned char exit_code);
</code>

%%Quits the main loop once all the events currently on the queue have been processed.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:loop:method:register|register]]**
<code c>
Eina_Bool efl_loop_register(Eo *obj, const Efl_Class *klass, const Efl_Object *provider);
</code>

%%Will register a manager of a specific class to be answered by eo.provider_find.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:loop:method:timeout|timeout]]**
<code c>
Efl_Future *efl_loop_timeout(Eo *obj, double time, const void *data);
</code>

%%Will trigger this promise when the specified timeout occur.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:loop:method:unregister|unregister]]**
<code c>
Eina_Bool efl_loop_unregister(Eo *obj, const Efl_Class *klass, const Efl_Object *provider);
</code>

%%Will unregister a manager of a specific class that was previously registered and answered by eo.provider_find.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:loop:property:app_efl_version|app_efl_version]]** //**(get)**//
<code c>
const Efl_Version *efl_loop_app_efl_version_get(const Eo *obj);
</code>

%%Indicates the version of EFL with which this application was compiled.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:loop:property:efl_version|efl_version]]** //**(get)**//
<code c>
const Efl_Version *efl_loop_efl_version_get(const Eo *obj);
</code>

%%Indicates the currently running version of EFL.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:loop:property:main|main]]** //**(get)**//
<code c>
Efl_Loop *efl_loop_main_get(const Eo *obj);
</code>

%%Points to the main loop instance of the application.%%\\ 
\\ 

==== Inherited ====

[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:loop:method:constructor|constructor]]** //[Overridden here]//
<code c>
Efl_Object *efl_constructor(Eo *obj);
</code>

%%Call the object's constructor.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:loop:method:destructor|destructor]]** //[Overridden here]//
<code c>
void efl_destructor(Eo *obj);
</code>

%%Call the object's destructor.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:loop:method:provider_find|provider_find]]** //[Overridden here]//
<code c>
Efl_Object *efl_provider_find(Eo *obj, const Efl_Object *klass);
</code>

%%Searches up in the object tree for a provider which knows the given class/interface.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:children_iterator_new|children_iterator_new]]**
<code c>
Eina_Iterator *efl_children_iterator_new(Eo *obj);
</code>

%%Get an iterator on all childrens%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:composite_attach|composite_attach]]**
<code c>
Eina_Bool efl_composite_attach(Eo *obj, Efl_Object *comp_obj);
</code>

%%Make an object a composite object of another.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:composite_detach|composite_detach]]**
<code c>
Eina_Bool efl_composite_detach(Eo *obj, Efl_Object *comp_obj);
</code>

%%Detach a composite object from another object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:composite_part_is|composite_part_is]]**
<code c>
Eina_Bool efl_composite_part_is(Eo *obj);
</code>

%%Check if an object is part of a composite object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:del|del]]**
<code c>
void efl_del(const Eo *obj);
</code>

%%Unrefs the object and reparents it to NULL.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_callback_forwarder_add|event_callback_forwarder_add]]**
<code c>
void efl_event_callback_forwarder_add(Eo *obj, const Efl_Event_Description *desc, Efl_Object *new_obj);
</code>

%%Add an event callback forwarder for an event and an object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_callback_forwarder_del|event_callback_forwarder_del]]**
<code c>
void efl_event_callback_forwarder_del(Eo *obj, const Efl_Event_Description *desc, Efl_Object *new_obj);
</code>

%%Remove an event callback forwarder for an event and an object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_callback_stop|event_callback_stop]]**
<code c>
void efl_event_callback_stop(Eo *obj);
</code>

%%Stop the current callback call.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_freeze|event_freeze]]**
<code c>
void efl_event_freeze(Eo *obj);
</code>

%%Freeze events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_global_freeze|event_global_freeze]]**
<code c>
void efl_event_global_freeze(const Eo *obj);
</code>

%%Freeze events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_global_thaw|event_global_thaw]]**
<code c>
void efl_event_global_thaw(const Eo *obj);
</code>

%%Thaw events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:event_thaw|event_thaw]]**
<code c>
void efl_event_thaw(Eo *obj);
</code>

%%Thaw events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:finalize|finalize]]**
<code c>
Efl_Object *efl_finalize(Eo *obj);
</code>

%%Called at the end of #eo_add. Should not be called, just overridden.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:method:name_find|name_find]]**
<code c>
Efl_Object *efl_name_find(Eo *obj, const char *search);
</code>

%%Find a child object with the given name and return it. The search string can be a glob (shell style). It can also specify class name in the format of "class:name" where ":" separates class and name. Both class and name can be globs. If class is specified, and name is empty like "class:" then the search will match any object of that class.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:comment|comment]]** //**(get, set)**//
<code c>
const char *efl_comment_get(const Eo *obj);
void efl_comment_set(Eo *obj, const char *comment);
</code>

%%A human readable comment for the object%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:event_freeze_count|event_freeze_count]]** //**(get)**//
<code c>
int efl_event_freeze_count_get(const Eo *obj);
</code>

%%Return freeze events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:event_global_freeze_count|event_global_freeze_count]]** //**(get)**//
<code c>
int efl_event_global_freeze_count_get(const Eo *obj);
</code>

%%Return freeze events of object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:finalized|finalized]]** //**(get)**//
<code c>
Eina_Bool efl_finalized_get(const Eo *obj);
</code>

%%True if the object is already finalized, false otherwise.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:name|name]]** //**(get, set)**//
<code c>
const char *efl_name_get(const Eo *obj);
void efl_name_set(Eo *obj, const char *name);
</code>

%%The name of the object.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:property:parent|parent]]** //**(get, set)**//
<code c>
Efl_Object *efl_parent_get(const Eo *obj);
void efl_parent_set(Eo *obj, Efl_Object *parent);
</code>

%%The parent of an object.%%\\ 
\\ 

===== Events =====

**[[:docs:efl:auto:class:efl:loop:event:arguments|arguments]]**
<code c>
EFL_LOOP_EVENT_ARGUMENTS(Efl_Loop_Arguments)
</code>

%%Event happens when args are provided to the loop by args_add().%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:loop:event:idle_enter|idle,enter]]**
<code c>
EFL_LOOP_EVENT_IDLE_ENTER(void, @restart)
</code>

%%Event occurs once the main loop enters the idle state.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:loop:event:idle_exit|idle,exit]]**
<code c>
EFL_LOOP_EVENT_IDLE_EXIT(void, @restart)
</code>

%%Event occurs once the main loop exits the idle state.%%\\ 
\\ 
**[[:docs:efl:auto:class:efl:loop:event:idle|idle]]**
<code c>
EFL_LOOP_EVENT_IDLE(void, @restart)
</code>

%%Event occurs once the main loop is idler. Be carefull, this will spin your CPU high if you keep listening on this event.%%\\ 
\\ 
==== Inherited ====

[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:event:callback_add|callback,add]]**
<code c>
EFL_EVENT_CALLBACK_ADD(void, @hot)
</code>

%%A callback was added.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:event:callback_del|callback,del]]**
<code c>
EFL_EVENT_CALLBACK_DEL(void, @hot)
</code>

%%A callback was deleted.%%\\ 
\\ 
[[:docs:efl:auto:class:efl:object|Efl.Object]].**[[:docs:efl:auto:class:efl:object:event:del|del]]**
<code c>
EFL_EVENT_DEL(void, @hot)
</code>

%%Object is being deleted.%%\\ 
\\ 
